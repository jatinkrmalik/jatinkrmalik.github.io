{"status":"ok","feed":{"url":"https://medium.com/feed/@jatinkrmalik","title":"Stories by Jatin K Malik on Medium","link":"https://medium.com/@jatinkrmalik?source=rss-ec576e4b06b0------2","author":"","description":"Stories by Jatin K Malik on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/2*9w8uaQp8uqA5wtRu-DltrQ.png"},"items":[{"title":"[Day 20] Pulse Propagation // Advent of Code 2023 (Python)","pubDate":"2023-12-29 12:31:13","link":"https://medium.com/@jatinkrmalik/day-20-pulse-propagation-advent-of-code-2023-python-844ad63b515a?source=rss-ec576e4b06b0------2","guid":"https://medium.com/p/844ad63b515a","author":"Jatin K Malik","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*pXNUwjPLdDqRpZmE\"><figcaption>Pulse Propagation (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/20\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>With your help, the Elves manage to find the right parts and fix all of the machines. Now, they just need to send the command to boot up the machines and get the sand flowing\u00a0again.</blockquote>\n<blockquote>The machines are far apart and wired together with long cables. The cables don\u2019t connect to the machines directly, but rather to communication modules attached to the machines that perform various initialization tasks and also act as communication relays.</blockquote>\n<blockquote>Modules communicate using pulses. Each pulse is either a high pulse or a low pulse. When a module sends a pulse, it sends that type of pulse to each module in its list of destination modules.</blockquote>\n<blockquote>There are several different types of\u00a0modules:</blockquote>\n<blockquote>Flip-flop modules (prefix %) are either on or off; they are initially off. If a flip-flop module receives a high pulse, it is ignored and nothing happens. However, if a flip-flop module receives a low pulse, it flips between on and off. If it was off, it turns on and sends a high pulse. If it was on, it turns off and sends a low\u00a0pulse.</blockquote>\n<blockquote>Conjunction modules (prefix &amp;) remember the type of the most recent pulse received from each of their connected input modules; they initially default to remembering a low pulse for each input. When a pulse is received, the conjunction module first updates its memory for that input. Then, if it remembers high pulses for all inputs, it sends a low pulse; otherwise, it sends a high\u00a0pulse.</blockquote>\n<blockquote>There is a single broadcast module (named broadcaster). When it receives a pulse, it sends the same pulse to all of its destination modules.</blockquote>\n<blockquote>Here at Desert Machine Headquarters, there is a module with a single button on it called, aptly, the button module. When you push the button, a single low pulse is sent directly to the broadcaster module.</blockquote>\n<blockquote>After pushing the button, you must wait until all pulses have been delivered and fully handled before pushing it again. Never push the button if modules are still processing pulses.</blockquote>\n<blockquote>Pulses are always processed in the order they are sent. So, if a pulse is sent to modules a, b, and c, and then module a processes its pulse and sends more pulses, the pulses sent to modules b and c would have to be handled\u00a0first.</blockquote>\n<blockquote>The module configuration (your puzzle input) lists each module. The name of the module is preceded by a symbol identifying its type, if any. The name is then followed by an arrow and a list of its destination modules. For\u00a0example:</blockquote>\n<blockquote>broadcaster -&gt; a, b, c<br>%a -&gt; b<br>%b -&gt; c<br>%c -&gt; inv<br>&amp;inv -&gt;\u00a0a</blockquote>\n<blockquote>In this module configuration, the broadcaster has three destination modules named a, b, and c. Each of these modules is a flip-flop module (as indicated by the % prefix). a outputs to b which outputs to c which outputs to another module named inv. inv is a conjunction module (as indicated by the &amp; prefix) which, because it has only one input, acts like an inverter(it sends the opposite of the pulse type it receives); it outputs to\u00a0a.</blockquote>\n<blockquote>By pushing the button once, the following pulses are\u00a0sent:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>broadcaster -low-&gt; b<br>broadcaster -low-&gt; c<br>a -high-&gt; b<br>b -high-&gt; c<br>c -high-&gt; inv<br>inv -low-&gt; a<br>a -low-&gt; b<br>b -low-&gt; c<br>c -low-&gt; inv<br>inv -high-&gt;\u00a0a</blockquote>\n<blockquote>After this sequence, the flip-flop modules all end up off, so pushing the button again repeats the same sequence.</blockquote>\n<blockquote>Here\u2019s a more interesting example:</blockquote>\n<blockquote>broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt;\u00a0output</blockquote>\n<blockquote>This module configuration includes the broadcaster, two flip-flops (named aand b), a single-input conjunction module (inv), a multi-input conjunction module (con), and an untyped module named output (for testing purposes). The multi-input conjunction module con watches the two flip-flop modules and, if they're both on, sends a low pulse to the output\u00a0module.</blockquote>\n<blockquote>Here\u2019s what happens if you push the button\u00a0once:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -high-&gt; output<br>b -high-&gt; con<br>con -low-&gt;\u00a0output</blockquote>\n<blockquote>Both flip-flops turn on and a low pulse is sent to output! However, now that both flip-flops are on and con remembers a high pulse from each of its two inputs, pushing the button a second time does something different:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt;\u00a0output</blockquote>\n<blockquote>Flip-flop a turns off! Now, con remembers a low pulse from module a, and so it sends only a high pulse to\u00a0output.</blockquote>\n<blockquote>Push the button a third\u00a0time:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -low-&gt; output<br>b -low-&gt; con<br>con -high-&gt;\u00a0output</blockquote>\n<blockquote>This time, flip-flop a turns on, then flip-flop b turns off. However, before b can turn off, the pulse sent to con is handled first, so it briefly remembers all high pulses for its inputs and sends a low pulse to output. After that, flip-flop b turns off, which causes con to update its state and send a high pulse to\u00a0output.</blockquote>\n<blockquote>Finally, with a on and b off, push the button a fourth\u00a0time:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt;\u00a0output</blockquote>\n<blockquote>This completes the cycle: a turns off, causing con to remember only low pulses and restoring all modules to their original\u00a0states.</blockquote>\n<blockquote>To get the cables warmed up, the Elves have pushed the button 1000 times. How many pulses got sent as a result (including the pulses sent by the button\u00a0itself)?</blockquote>\n<blockquote>In the first example, the same thing happens every time the button is pushed: 8 low pulses and 4 high pulses are sent. So, after pushing the button 1000 times, 8000 low pulses and 4000 high pulses are sent. Multiplying these together gives 32000000.</blockquote>\n<blockquote>In the second example, after pushing the button 1000 times, 4250 low pulses and 2750 high pulses are sent. Multiplying these together gives 11687500.</blockquote>\n<blockquote>Consult your module configuration; determine the number of low pulses and high pulses that would be sent after pushing the button 1000 times, waiting for all pulses to be fully handled after each push of the button. What do you get if you multiply the total number of low pulses sent by the total number of high pulses\u00a0sent?</blockquote>\n<p>So, let\u2019s begin with a simple visualization of a case with just 2 machines connected:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Y70DVIH19S3lfweAYNLiAw.png\"></figure><p>CM aka Communication modules are attached to machines that perform various initialization tasks and also act as communication relays.</p>\n<p><strong>Types:</strong></p>\n<ul>\n<li>\n<strong>Flip-flop</strong> (%)\u200a\u2014\u200aON | <em>OFF (Default)<br></em> * High Pulse: Ignore<br> * Low Pulse: Flips state<br>\u200a\u2014\u200aif Off: flips to ON + returns High Pulse<br>\u200a\u2014\u200aif ON: flips to OFF + returns Low\u00a0Pulse</li>\n<li>\n<strong>Conjunction</strong> (&amp;)\u200a\u2014\u200a<em>Low pulse (Default)<br></em> * Remembers the most recent pulse for each input module<br> * for input pulse: updates memory, return High or\u00a0Low</li>\n<li>\n<strong>Broadcast</strong> (broadcaster)<br> * input pulse -&gt; sends the same pulse to all destination modules</li>\n</ul>\n<blockquote>Now, at Desert Machine Headquarters, there is a module with a single button on it called, <strong>aptly</strong>, the button module. <strong>When you push the button</strong>, a single <strong>low pulse</strong> is sent directly to the broadcaster module.</blockquote>\n<p>Once we push aptly we must wait until all pulses have been processed for all modules in our\u00a0network.</p>\n<blockquote>Pulses are <strong>always processed in the order</strong> they are\u00a0sent.</blockquote>\n<blockquote>So, if a pulse is sent to modules a, b, and c, and then module a processes its pulse and sends more pulses, the pulses sent to modules b and c would have to be handled\u00a0first.</blockquote>\n<p>So, we can see that the system in a way is \u201c<strong><em>queueing</em></strong>\u201d the requests!</p>\n<p>Now, we are given a <strong><em>module configuration</em></strong> (input)<strong><em> </em></strong>which is something like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/661/1*1ONY5Hc4KshvHMd3nfVXmg.png\"></figure><blockquote>where, the <strong>broadcaster</strong> has <strong>three destination modules</strong> named a, b, and c. Each of these modules is a <strong>flip-flop module</strong> (as indicated by the %\u00a0prefix).</blockquote>\n<blockquote>- a outputs to b which outputs to c which outputs to another module named\u00a0inv.</blockquote>\n<blockquote>- inv is a <strong>conjunction</strong> module (as indicated by the &amp; prefix) which, because it has only one input, acts like an <strong>inverter</strong>(it sends the opposite of the pulse type it receives); it outputs to\u00a0a.</blockquote>\n<p>By pushing the aptly button once, the following pulses are\u00a0sent:</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>broadcaster -low-&gt; b<br>broadcaster -low-&gt; c<br>a -high-&gt; b<br>b -high-&gt; c<br>c -high-&gt; inv<br>inv -low-&gt; a<br>a -low-&gt; b<br>b -low-&gt; c<br>c -low-&gt; inv<br>inv -high-&gt; a</pre>\n<p>Let\u2019s understand this with a visualization:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*_6D9nF-fllU8iipiJcCUGQ.png\"><figcaption>Starting from 1 \u2192\u00a012</figcaption></figure><p>After this sequence, the flip-flop modules all end up <strong>OFF</strong>, so pushing the button again <strong>repeats the same sequence</strong>.</p>\n<p>We are given another\u00a0example:</p>\n<pre>broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output</pre>\n<p>Here\u2019s what happens if you push the button\u00a0<strong>once</strong>:</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -high-&gt; output<br>b -high-&gt; con<br>con -low-&gt; output</pre>\n<blockquote>Both flip-flops turn on and a low pulse is sent to output! However, now that both flip-flops are on and con remembers a high pulse from each of its two\u00a0inputs</blockquote>\n<p>Pushing the button <strong>second</strong>\u00a0time?</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt; output</pre>\n<blockquote>Flip-flop a turns off! Now, con remembers a low pulse from module a, and so it sends only a high pulse to\u00a0output.</blockquote>\n<p>And <strong>third</strong>\u00a0time?</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -low-&gt; output<br>b -low-&gt; con<br>con -high-&gt; output</pre>\n<blockquote>This time, flip-flop a turns on, then flip-flop b turns off. However, before b can turn off, the pulse sent to con is handled first, so it briefly remembers all high pulses for its inputs and sends a low pulse to output. After that, flip-flop b turns off, which causes con to update its state and send a high pulse to\u00a0output.</blockquote>\n<p>Finally, with a on and b off, push the button a <strong>fourth</strong>\u00a0time:</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt; output</pre>\n<blockquote>This completes the cycle: a turns off, causing con to remember only low pulses and restoring all modules to their original\u00a0states.</blockquote>\n<p>Now, the problem states\u00a0that:</p>\n<blockquote>To get the cables warmed up, the Elves have pushed the button <strong>1000</strong> times. <strong>How many pulses got sent as a result (including the pulses sent by the button\u00a0itself)?</strong>\n</blockquote>\n<p>\u2014\u200a\u2014\u200a\u2014</p>\n<p>Phew! This one is going to be intense! I can feel it. We need to simulate the circuit and remember the states. Seems like OOP might be the perfect way to solve this one!\u00a0;)</p>\n<p>Let\u2019s first write our base\u00a0case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/990/1*HlVJcsTXqVz26jf_ZTL1Tw.png\"><figcaption>Skelton code, a good point to\u00a0start!</figcaption></figure><p>As mentioned, I am heavily leaning towards an object-oriented approach here as it will allow us to simulate the behavior of the different types of modules and their interactions when the button is\u00a0pressed!</p>\n<p>The key components on top of my mind\u00a0are:</p>\n<ol>\n<li>\n<strong>Module Classes</strong>: Representing different types of modules (Flip-flop, Conjunction, Broadcaster and\u00a0Untyped</li>\n<li>\n<strong>Pulse Management</strong>: Handling the sending and processing of\u00a0pulses.</li>\n<li>\n<strong>Simulation Logic</strong>: To simulate the process of pushing the button and propagating the\u00a0pulses.</li>\n</ol>\n<p>Let\u2019s start by defining the classes and their\u00a0methods:</p>\n<p><strong>Module Classes</strong></p>\n<ul>\n<li>BaseModule: An abstract class for common module functionality.</li>\n<li>FlipFlopModule: Represents a flip-flop module.</li>\n<li>ConjunctionModule: Represents a conjunction module.</li>\n<li>BroadcasterModule: Represents the broadcaster module.</li>\n<li>Untyped: Represents the untyped\u00a0module.</li>\n</ul>\n<p>Also, to keep track of Pulse Type and Module State, we can just define enum classes to make the code\u00a0cleaner?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/255/1*I1c-BOKWFnoccuWn6NbX3w.png\"></figure><p>Let\u2019s see our base class for Module\u00a0?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/886/1*ofTrW1MllkJJg9fGL2VyYg.png\"><figcaption>We are leaving receive_pulse to be implemented by it\u2019s derived\u00a0classes</figcaption></figure><p>Now let\u2019s implement:</p>\n<h4><strong>FlipFlopModule</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/880/1*Cn5YlWI4wpCzvgEkW0INrg.png\"></figure><p>The FlipFlopModule class initialises the object with State.OFF. We implement the receive_pulse method that changes the state of the module based on the received\u00a0pulse.</p>\n<ul>\n<li>If the received pulse is LOW, the state of the module is\u00a0toggled.</li>\n<li>If the current state is OFF, it is changed to ON, and vice\u00a0versa.</li>\n</ul>\n<p>After changing the state, the module sends a\u00a0pulse.</p>\n<ul><li>If the new state is ON, it sends a HIGH pulse, otherwise it sends a LOW\u00a0pulse.</li></ul>\n<h4><strong>ConjunctionModule</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/912/1*VfOa_n3I5GJbnitIfEuiPw.png\"></figure><p>The ConjunctionModule class has a __init__ method that sets the name of the module and initializes a list of input states. The number of input states is determined by the inputs parameter, which is a list of input module names. Initially, all input states are set to\u00a0LOW.</p>\n<p>The receive_pulse method is used to receive a pulse at a specific input. The pulse can be either HIGH or LOW, and the corresponding input state is updated accordingly. After updating the input state, the method checks if all input states are HIGH. If they are, it sends a LOW pulse; otherwise, it sends a HIGH pulse. This behavior is the opposite of a typical AND gate, which would output HIGH when all inputs are\u00a0HIGH.</p>\n<h4>BroadcasterModule</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/391/1*3EtOqzJ_62qm0hIiS8KtLQ.png\"></figure><p>This represents a broadcaster module, which is a type of digital circuit that broadcasts the same pulse to all of its destination modules.</p>\n<p>The BroadcasterModule class has a receive_pulse method that immediately sends the received pulse to all destination modules. The pulse can be either HIGH or LOW. This behavior is implemented by calling the send_pulse method with the received pulse as the argument.</p>\n<h4>UntypedModule</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/520/1*RVfi_3TB_awl3Kb7j1cmCg.png\"></figure><p>It represents a module that can receive pulses but does not have a specific\u00a0type.</p>\n<p>The receive_pulse method is used to receive a pulse and the name of the input module. The pulse can be either HIGH or LOW. The method appends the received pulse to the list of received pulses and then do\u00a0nothing!</p>\n<h4>ModuleFactory</h4>\n<blockquote>\ud83d\udcad I think this is a cookie-cutter case for <a href=\"https://refactoring.guru/design-patterns/factory-method\">Factory Pattern</a> as we can create module instances based on their types as indicated by their names or prefixes.</blockquote>\n<p>We can define a<strong>ModuleFactory</strong> class responsible for creating module instances based on the input\u00a0string.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/780/1*UGX9EiIMNauksqNmN5npMA.png\"></figure><p>This is pretty much self explanatory!</p>\n<h3>Simulation</h3>\n<p>Once all our pieces are set up! We are good to go to implement our simulation class that will orchestrate a pulse run for each button press and track everything we\u00a0need!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/784/1*2IqQGmpd_CmjD7yWctpobw.png\"></figure><p>Now to orchestrate all of this, one of the most important parts is to parse the config_lines and set up our modules correctly with the type, state and destination so when they receive a Pulse, they can send it forward correctly!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VMVnpRAsA7fWBIccMghhng.png\"><figcaption>Here, we are setting up both modules and their respective connections in the destinations.</figcaption></figure><p>Let\u2019s now run our first base test\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/804/1*1zKsJ-qF1GJEwNP9-phpIg.png\"></figure><p>And it failed! Let\u2019s\u00a0debug?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*hIXwdJ3DA1z9hz4mrFqyNw.png\"></figure><p>And after some debugging and back and forth, we can see it is counting <strong>LOW_PULSE_COUNT</strong> and <strong>HIGH_PULSE_COUNT</strong> correctly for the first run, now we just need to let it run <strong>1000</strong> times and return the product of both\u00a0counts!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>\u2705 test_count_pulses_in_the_circuit() passed<br><br>[Done] exited with code=0 in 0.237 seconds</pre>\n<p>Perfect! Now, let\u2019s test our code for thesecond example in the problem? This way we will be able to ensure we are covering all the edge\u00a0cases!</p>\n<pre>broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/799/1*UOljqE7Ol8Pi9zI7TrJzdQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>\u2705 test_count_pulses_in_the_circuit() passed<br>Traceback (most recent call last):<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\", line 195, in &lt;module&gt;<br>    test_count_pulses_in_the_circuit_b()<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\", line 185, in test_count_pulses_in_the_circuit_b<br>    modules = setup_modules(input_str.splitlines())<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\", line 158, in setup_modules<br>    modules[source_name].add_destination(modules[dest_name])<br>KeyError: 'output'<br><br>[Done] exited with code=1 in 0.244 seconds</pre>\n<p>Whoops! We got stuck in an error as we are not initiating Modules for destinations, which is leading to an error for Output which should be an UntypedModule.</p>\n<p>We can update our setup_modules() code to handle that once we create all modules for the source part of the\u00a0config:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/879/1*VXdtM5pVeItvdWbDGgdY-g.png\"></figure><p>Let\u2019s run the test case again? And\u00a0voila!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>\u2705 test_count_pulses_in_the_circuit_b() passed<br><br>[Done] exited with code=0 in 0.231 seconds</pre>\n<p>I feel pretty good about this code as it has a good runtime and has quite a clean code making it easy to\u00a0debug.</p>\n<p>Let\u2019s load up our puzzle input and see if we get an\u00a0answer?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*q3AM8ioIDVERo9qxGvIlkw.png\"></figure><p>And\u2026executing the\u00a0code\u2026</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>\u2757\ufe0f Product of total number of low pulses sent by the total number of high pulses sent: XXXXXXXXX<br><br>[Done] exited with code=0 in 0.248 seconds</pre>\n<p>We get an answer! Let\u2019s input this in our answer\u00a0box?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Vwpxsur1qGWQ8e3b8g6ErQ.png\"><figcaption>\u2b50\ufe0f</figcaption></figure><p>Boom! Let me paste our well-structured object-oriented code till\u00a0now:</p>\n<pre># Day 20 - Pulse Propagation<br><br>from enum import Enum<br>from collections import deque<br><br># Constants<br><br># dict to hold the count of inputs for each module<br>INPUT_TRACKER = {}<br># global queue to hold pulses<br>PULSE_QUEUE = deque()<br># to hold the count of low and high pulses<br>LOW_PULSE_COUNT, HIGH_PULSE_COUNT = 0, 0<br><br># Enums<br><br>class State(Enum):<br>    ON = 1<br>    OFF = 0<br><br><br>class Pulse(Enum):<br>    HIGH = 1<br>    LOW = 0<br><br><br>class ModuleType(Enum):<br>    FLIP_FLOP = \"%\"<br>    CONJUNCTION = \"&amp;\"<br>    BROADCASTER = \"broadcaster\"<br><br># Classes<br><br>class Module:<br>    def __init__(self, name):<br>        self.name = name<br>        self.destinations = []<br><br>    def add_destination(self, module):<br>        self.destinations.append(module)<br><br>    def send_pulse(self, pulse):<br>        for dest_module in self.destinations:<br>            PULSE_QUEUE.append((pulse, dest_module.name, self.name))<br>            update_pulse_count(pulse)<br><br>    def receive_pulse(self, pulse, input_name):<br>        raise NotImplementedError(\"Subclass must implement receive_pulse method\")<br><br><br>class FlipFlopModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.state = State.OFF<br><br>    def receive_pulse(self, pulse, src_module):<br>        if pulse == Pulse.LOW:<br>            self.state = State.ON if self.state == State.OFF else State.OFF<br>            self.send_pulse(Pulse.HIGH if self.state == State.ON else Pulse.LOW)<br><br><br>class ConjunctionModule(Module):<br>    def __init__(self, name, inputs):<br>        super().__init__(name)<br>        self.inputs = inputs  # List of input module names<br>        self.input_states = {input_name: Pulse.LOW for input_name in inputs}<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.input_states[src_module] = pulse<br><br>        if all(state == Pulse.HIGH for state in self.input_states.values()):<br>            self.send_pulse(Pulse.LOW)<br>        else:<br>            self.send_pulse(Pulse.HIGH)<br><br><br>class BroadcasterModule(Module):<br>    def receive_pulse(self, pulse, src_module):<br>        self.send_pulse(pulse)<br><br><br>class UntypedModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.received_pulses = []<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.received_pulses.append(pulse)<br><br><br>class ModuleFactory:<br>    @staticmethod<br>    def create_module(module_identifier):<br>        if module_identifier.startswith(ModuleType.FLIP_FLOP.value):<br>            return FlipFlopModule(module_identifier[1:])<br>        elif module_identifier.startswith(ModuleType.CONJUNCTION.value):<br>            # Determine the number of inputs for the conjunction module<br>            name = module_identifier[1:]<br>            module_inputs = INPUT_TRACKER[name]<br>            return ConjunctionModule(name, module_inputs)<br>        elif module_identifier == ModuleType.BROADCASTER.value:<br>            return BroadcasterModule(module_identifier)<br>        else:<br>            return UntypedModule(module_identifier)<br><br><br>class Simulation:<br>    def __init__(self, modules):<br>        self.modules = modules<br><br>    def run_simulation(self, button_presses):<br>        for _ in range(button_presses):<br>            # Simulate button press - send a low pulse to broadcaster<br>            update_pulse_count(Pulse.LOW)<br>            self.modules[\"broadcaster\"].receive_pulse(Pulse.LOW, \"button\")<br><br>            # Process pulses in the queue<br>            while PULSE_QUEUE:<br>                pulse, dest_module, src_module = PULSE_QUEUE.popleft()<br>                self.modules[dest_module].receive_pulse(pulse, src_module)<br><br># Util functions<br><br>def update_pulse_count(pulse):<br>    global LOW_PULSE_COUNT, HIGH_PULSE_COUNT<br>    if pulse == Pulse.LOW:<br>        LOW_PULSE_COUNT += 1<br>    elif pulse == Pulse.HIGH:<br>        HIGH_PULSE_COUNT += 1<br><br><br>def process_input_count(config_lines):<br>    global INPUT_TRACKER<br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source = parts[0].strip()<br>        if len(parts) &gt; 1:<br>            destinations = [dest.strip() for dest in parts[1].split(\",\")]<br><br>            for dest in destinations:<br>                # Remove any prefix from the destination name<br>                dest = dest.lstrip(\"%&amp;\")<br>                source = source.lstrip(\"%&amp;\")<br>                if dest not in INPUT_TRACKER:<br>                    INPUT_TRACKER[dest] = set()<br>                INPUT_TRACKER[dest].add(source)<br><br><br>def setup_modules(config_lines):<br>    modules = {}<br>    connections = {}<br><br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source_name = parts[0].strip()<br>        dest_names = parts[1].split(\",\") if len(parts) &gt; 1 else []<br>        clean_source_name = source_name.lstrip(\"%&amp; \")<br><br>        if clean_source_name not in modules:<br>            modules[clean_source_name] = ModuleFactory.create_module(source_name)<br><br>        for dest_name in dest_names:<br>            if clean_source_name not in connections:<br>                connections[clean_source_name] = []<br>            connections[clean_source_name].append(dest_name)<br><br>    # Set up connections<br>    for source_name, dest_names in connections.items():<br>        for dest_name in dest_names:<br>            dest_name = dest_name.strip()<br>            if dest_name not in modules:<br>                # Create module if it doesn't exist for destination<br>                modules[dest_name] = ModuleFactory.create_module(dest_name)<br>            modules[source_name].add_destination(modules[dest_name])<br><br>    return modules<br><br># Tests<br><br>def test_count_pulses_in_the_circuit_a():<br>    input_str = \"\"\"broadcaster -&gt; a, b, c<br>%a -&gt; b<br>%b -&gt; c<br>%c -&gt; inv<br>&amp;inv -&gt; a\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 32000000, f\"Expected 32000000, got {num_pulses}\"<br>    print(\"\u2705 test_count_pulses_in_the_circuit_a() passed\")<br><br><br>def test_count_pulses_in_the_circuit_b():<br>    input_str = \"\"\"broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 11687500, f\"Expected 11687500, got {num_pulses}\"<br>    print(\"\u2705 test_count_pulses_in_the_circuit_b() passed\")<br><br># Main<br><br>def part_one():<br>    with open(\"day_20/input.txt\") as f:<br>        config_lines = f.readlines()<br>    process_input_count(config_lines)<br>    modules = setup_modules(config_lines)<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    print(<br>        f\"\u2757\ufe0f Product of total number of low pulses sent by the \\<br>total number of high pulses sent: {num_pulses}\"<br>    )<br><br><br><br>if __name__ == \"__main__\":<br>    # test_count_pulses_in_the_circuit_a()<br>    # test_count_pulses_in_the_circuit_b()<br>    part_one()</pre>\n<blockquote>\u2757\ufe0fThe one limitation of our code here is that, we can only run 1 simulation at a time as we are using global variables to keep pulse count and queue. We shall address this in part\u00a02.</blockquote>\n<h3>Part Two</h3>\n<blockquote>The final machine responsible for moving the sand down to Island Island has a module attached named rx. The machine turns on when a single low pulse is sent to\u00a0rx.</blockquote>\n<blockquote>Reset all modules to their default states. Waiting for all pulses to be fully handled after each button press, what is the fewest number of button presses required to deliver a single low pulse to the module named\u00a0rx?</blockquote>\n<p>Well, this seems simple?! All we need to do is track the <strong>min_num_of_button_press</strong> to send a <strong>Pulse.LOW</strong> to <strong>rx</strong>\u00a0module!</p>\n<p>We can define a new function <strong>run_simulation_until_rx</strong>() that will basically keep pressing the button to go through the circuit till we recieve a <strong>Pulse.LOW</strong> headed towards <strong>rx</strong>\u00a0module:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*cf_sJv7kTPgj_HYq4tuPkA.png\"></figure><p>.</p>\n<p>.</p>\n<p>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e0DWVRgnAIaEdnyiKrwc4g.png\"></figure><p>.</p>\n<p>.</p>\n<p>Well, it may not be as simple as we thought first! ~6 mins later, we are at <strong>521553 button presses</strong> with no sight of <strong>Pulse.LOW</strong> to\u00a0<strong>rx</strong>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*9vzN6PdVdi0UQD-J2r6tIg.png\"></figure><p>I knew it was too good to be this simple! First things first, let\u2019s add a __repr__ method to our base Module class so we don\u2019t have to deal with this in our debugger:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/689/1*5WYArCFYmp5oTXaeRr1-Sg.png\"></figure><p>Let\u2019s make it human readable without having to click through each object to see it\u2019s properties:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/831/1*lAsyzzp01PExQ5Br2sx4tw.png\"><figcaption>Much better!</figcaption></figure><p>Now, looking at our puzzle input, the only module that has rx as a destination is &amp;dn (<em>ConjunctionModule</em>).</p>\n<pre>&amp;dn -&gt; rx</pre>\n<p>Let\u2019s add that to our watch list to see how it changes the input_states as it can\u2019t send a Pulse.LOW to rx until all its input_states are set to Pulse.HIGH!</p>\n<p>We can see that &amp;dn has 4 callers -&gt; xp, fh, dd, fc and they all are initiated as Pulse.LOW\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/965/1*PyvjzT0ylkr0_stFW2zIDQ.png\"><figcaption>`dn` state as of initialization!</figcaption></figure><p>After 1 cycle complete (i.e. button_presses == 1), here\u2019s how&amp;dn looks\u00a0like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/953/1*Sy-valqJbyw2o9VD_P4stQ.png\"><figcaption>We got 4 pulses to `rx` but all of them were\u00a0HIGH.</figcaption></figure><p>We basically need to find a case where all 4 of xp, fh, dd, fc become Pulse.HIGH\u00a0. I am inclined to think that all 4 of these states may have some cycles and we might need to find a common point where these cycles will co-incide?</p>\n<p>Let\u2019s create a breakpoint to see if we ever get a Pulse.HIGH for either of these\u00a04?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*dIRug3xC7pgkv4sLPy2kKA.png\"><figcaption>conditional breakpoint</figcaption></figure><p>So, at <strong>3917</strong> we found our first call to fc with Pulse.HIGH\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/935/1*7GaNuBsjjfTcCchRib16Fw.png\"></figure><p>which will then modify our dn <strong><em>input_states</em></strong> to:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/941/1*gFecxOnyS1VMSgyeOqoGaw.png\"></figure><p>And similarly, on <strong>3919</strong> button press, we get Pulse.HIGH for\u00a0xp</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/941/1*OCZiRwypqnfCOMLWcWQ_lA.png\"></figure><p>changing our dn input_states to:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/969/1*xDDWxfqkikoYpVEzIGHmJQ.png\"></figure><p>Then for <strong>4003</strong> time, we get one for\u00a0dd</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/949/1*0zttMxeT1CgVMs4Y38WqHw.png\"></figure><p>making our dn input_states:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/947/1*cJI65wFsXn3b3NxRLstwIw.png\"></figure><p>Lastly, we get Pulse.HIGH for fh at <strong>4027</strong> button\u00a0press:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/897/1*lMbzrDmOwMUwe2pL0KhQhw.png\"></figure><p>making our dn to\u00a0be:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/977/1*oe5AHnPrFKqAEvCTMFPgXg.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/930/1*cKbg0KwNmUnUexBhC5-VTQ.png\"></figure><blockquote>\u2757\ufe0fNow! Moving on! We can see that the next event comes at <strong>7834th time </strong>for fc and if you scroll up, the last event came at <strong>3917 </strong>i.e:\u00a0<strong>7834/2</strong>\n</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/930/1*cKbg0KwNmUnUexBhC5-VTQ.png\"></figure><p>This helps us establish that each of these input modules has its own cycle! And now this helps us deduce this down an <a href=\"https://en.wikipedia.org/wiki/Least_common_multiple\">LCM (Lowest common multiple)</a> problem, where all we need to find is what will be the first time in our button press cycle when all 4 xp, fh, dd, fc will receive Pulse.HIGH that will emit a Pulse.LOW to rx\u00a0!</p>\n<p>This is now a simple mathematical problem!</p>\n<p>We can find the LCM for 3917, 3919, 4003 and 4027\u00a0i.e:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/156/0*-P0cFbDuOcFe89ES\"></figure><p>We can whip up a quick python script to find\u00a0that:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/489/1*bL5iyR6GjNY6YnnIIfTwkQ.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>XXXXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.218 seconds</pre>\n<p>Let\u2019s put this in our answer box and\u2026.yes! Our hunch was absolutely correct.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YBMYkpHVMeQoSp9dzh-dWQ.png\"><figcaption>YESSS!!</figcaption></figure><p>Well, since it is not physically possible for us to keep running our code for 200 Trillions+ (answer in some ballpark) times, we need to just update our code to find the first occurence for each xp, fh, dd, fc and then just find the LCM and\u00a0exit:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*foKEVUYnle6qfKqKKICyEQ.png\"><figcaption>Some debugging steps\u00a0later</figcaption></figure><p>Here\u2019s our updated run_simulation_until_rx() that will iterate\u00a0till:</p>\n<pre>all(idx &gt; 0 for idx in rx_callers_high_pulse_idx.values())</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wbwgKvxtCDalX9lonbfBmQ.png\"></figure><p>Let\u2019s run it and see if we are getting the correct answer as we calculated mathematically before?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>\u2757\ufe0f\u2757\ufe0f Number of button presses required to activate the Rx: XXXXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.412 seconds</pre>\n<p>Yep! XXXXXXXXXXXXXXX == XXXXXXXXXXXXXXX \ud83e\udd13</p>\n<p>Here\u2019s our full code for both Part 1 and\u00a02:</p>\n<pre># Day 20 - Pulse Propagation<br><br>from enum import Enum<br>from collections import deque<br>from math import gcd<br>from functools import reduce<br><br># Constants<br><br># dict to hold the count of inputs for each module<br>INPUT_TRACKER = {}<br># global queue to hold pulses<br>PULSE_QUEUE = deque()<br># to hold the count of low and high pulses<br>LOW_PULSE_COUNT, HIGH_PULSE_COUNT = 0, 0<br><br># Enums<br><br>class State(Enum):<br>    ON = 1<br>    OFF = 0<br><br><br>class Pulse(Enum):<br>    HIGH = 1<br>    LOW = 0<br><br><br>class ModuleType(Enum):<br>    FLIP_FLOP = \"%\"<br>    CONJUNCTION = \"&amp;\"<br>    BROADCASTER = \"broadcaster\"<br><br># Classes<br><br>class Module:<br>    def __init__(self, name):<br>        self.name = name<br>        self.destinations = []<br><br>    def add_destination(self, module):<br>        self.destinations.append(module)<br><br>    def send_pulse(self, pulse):<br>        for dest_module in self.destinations:<br>            PULSE_QUEUE.append((pulse, dest_module.name, self.name))<br>            update_pulse_count(pulse)<br><br>    def receive_pulse(self, pulse, input_name):<br>        raise NotImplementedError(\"Subclass must implement receive_pulse method\")<br><br><br>class FlipFlopModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.state = State.OFF<br><br>    def __repr__(self) -&gt; str:<br>        return f\"Module({self.name} - {self.state})\"<br><br>    def receive_pulse(self, pulse, src_module):<br>        if pulse == Pulse.LOW:<br>            self.state = State.ON if self.state == State.OFF else State.OFF<br>            self.send_pulse(Pulse.HIGH if self.state == State.ON else Pulse.LOW)<br><br><br>class ConjunctionModule(Module):<br>    def __init__(self, name, inputs):<br>        super().__init__(name)<br>        self.inputs = inputs  # List of input module names<br>        self.input_states = {input_name: Pulse.LOW for input_name in inputs}<br><br>    def __repr__(self) -&gt; str:<br>        return f\"Module({self.name} - {self.input_states})\"<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.input_states[src_module] = pulse<br><br>        if all(state == Pulse.HIGH for state in self.input_states.values()):<br>            self.send_pulse(Pulse.LOW)<br>        else:<br>            self.send_pulse(Pulse.HIGH)<br><br><br>class BroadcasterModule(Module):<br>    def receive_pulse(self, pulse, src_module):<br>        self.send_pulse(pulse)<br><br><br>class UntypedModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.received_pulses = {Pulse.LOW: 0, Pulse.HIGH: 0}<br><br>    def __repr__(self) -&gt; str:<br>        return f\"Module({self.name} - {self.received_pulses})\"<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.received_pulses[pulse] += 1<br><br><br>class ModuleFactory:<br>    @staticmethod<br>    def create_module(module_identifier):<br>        if module_identifier.startswith(ModuleType.FLIP_FLOP.value):<br>            return FlipFlopModule(module_identifier[1:])<br>        elif module_identifier.startswith(ModuleType.CONJUNCTION.value):<br>            # Determine the number of inputs for the conjunction module<br>            name = module_identifier[1:]<br>            module_inputs = INPUT_TRACKER[name]<br>            return ConjunctionModule(name, module_inputs)<br>        elif module_identifier == ModuleType.BROADCASTER.value:<br>            return BroadcasterModule(module_identifier)<br>        else:<br>            return UntypedModule(module_identifier)<br><br><br>class Simulation:<br>    def __init__(self, modules):<br>        self.modules = modules<br><br>    def run_simulation(self, button_presses):<br>        for _ in range(button_presses):<br>            # Simulate button press - send a low pulse to broadcaster<br>            update_pulse_count(Pulse.LOW)<br>            self.modules[\"broadcaster\"].receive_pulse(Pulse.LOW, \"button\")<br><br>            # Process pulses in the queue<br>            while PULSE_QUEUE:<br>                pulse, dest_module, src_module = PULSE_QUEUE.popleft()<br>                self.modules[dest_module].receive_pulse(pulse, src_module)<br><br>    def run_simulation_until_rx(self):<br>        button_presses = 0<br><br>         # rx_source is the only input for rx i.e. &amp;dn<br>        rx_source = list(INPUT_TRACKER['rx'])[0]<br><br>        # dict to hold the index of the rx caller that received a Pulse.HIGH for the first time<br>        rx_callers_high_pulse_idx = {caller: 0 for caller in INPUT_TRACKER[rx_source]}<br><br>        # break when all the rx callers have received a high pulse for the first time<br>        while not all(idx &gt; 0 for idx in rx_callers_high_pulse_idx.values()):<br>            button_presses += 1<br>            self.modules['broadcaster'].receive_pulse(Pulse.LOW, \"button\")<br>            update_pulse_count(Pulse.LOW)<br><br>            while PULSE_QUEUE:<br>                pulse, dest_module, src_module = PULSE_QUEUE.popleft()<br>                self.modules[dest_module].receive_pulse(pulse, src_module)<br><br>                # update the index of the rx caller that received a high pulse for the first time<br>                if src_module in rx_callers_high_pulse_idx.keys() and  pulse == Pulse.HIGH:<br>                    rx_callers_high_pulse_idx[src_module] = button_presses<br><br>        # lcm formula<br>        lcm = lambda x, y: x * y // gcd(x, y)<br><br>        # find LCM for all the values in rx_callers_high_pulse_idx<br>        return reduce(lcm, list(rx_callers_high_pulse_idx.values()))<br><br><br># Util functions<br><br>def update_pulse_count(pulse):<br>    global LOW_PULSE_COUNT, HIGH_PULSE_COUNT<br>    if pulse == Pulse.LOW:<br>        LOW_PULSE_COUNT += 1<br>    elif pulse == Pulse.HIGH:<br>        HIGH_PULSE_COUNT += 1<br><br><br>def process_input_count(config_lines):<br>    global INPUT_TRACKER<br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source = parts[0].strip()<br>        if len(parts) &gt; 1:<br>            destinations = [dest.strip() for dest in parts[1].split(\",\")]<br><br>            for dest in destinations:<br>                # Remove any prefix from the destination name<br>                dest = dest.lstrip(\"%&amp;\")<br>                source = source.lstrip(\"%&amp;\")<br>                if dest not in INPUT_TRACKER:<br>                    INPUT_TRACKER[dest] = set()<br>                INPUT_TRACKER[dest].add(source)<br><br><br>def setup_modules(config_lines):<br>    modules = {}<br>    connections = {}<br><br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source_name = parts[0].strip()<br>        dest_names = parts[1].split(\",\") if len(parts) &gt; 1 else []<br>        clean_source_name = source_name.lstrip(\"%&amp; \")<br><br>        if clean_source_name not in modules:<br>            modules[clean_source_name] = ModuleFactory.create_module(source_name)<br><br>        for dest_name in dest_names:<br>            if clean_source_name not in connections:<br>                connections[clean_source_name] = []<br>            connections[clean_source_name].append(dest_name)<br><br>    # Set up connections<br>    for source_name, dest_names in connections.items():<br>        for dest_name in dest_names:<br>            dest_name = dest_name.strip()<br>            if dest_name not in modules:<br>                # Create module if it doesn't exist for destination<br>                modules[dest_name] = ModuleFactory.create_module(dest_name)<br>            modules[source_name].add_destination(modules[dest_name])<br><br>    return modules<br><br># Tests<br><br>def test_count_pulses_in_the_circuit_a():<br>    input_str = \"\"\"broadcaster -&gt; a, b, c<br>%a -&gt; b<br>%b -&gt; c<br>%c -&gt; inv<br>&amp;inv -&gt; a\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 32000000, f\"Expected 32000000, got {num_pulses}\"<br>    print(\"\u2705 test_count_pulses_in_the_circuit_a() passed\")<br><br><br>def test_count_pulses_in_the_circuit_b():<br>    input_str = \"\"\"broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 11687500, f\"Expected 11687500, got {num_pulses}\"<br>    print(\"\u2705 test_count_pulses_in_the_circuit_b() passed\")<br><br># Main<br><br>def part_one():<br>    with open(\"day_20/input.txt\") as f:<br>        config_lines = f.readlines()<br>    process_input_count(config_lines)<br>    modules = setup_modules(config_lines)<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    print(<br>        f\"\u2757\ufe0f Product of total number of low pulses sent by the \\<br>total number of high pulses sent: {num_pulses}\"<br>    )<br><br>def part_two():<br>    with open(\"day_20/input.txt\") as f:<br>        config_lines = f.readlines()<br>    process_input_count(config_lines)<br>    modules = setup_modules(config_lines)<br>    simulation = Simulation(modules)<br>    button_presses = simulation.run_simulation_until_rx()<br>    print(f\"\u2757\ufe0f\u2757\ufe0f Number of button presses required to activate the Rx: {button_presses}\")<br><br><br>if __name__ == \"__main__\":<br>    # test_count_pulses_in_the_circuit_a()<br>    # test_count_pulses_in_the_circuit_b()<br>    # part_one()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=844ad63b515a\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*pXNUwjPLdDqRpZmE\"><figcaption>Pulse Propagation (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/20\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>With your help, the Elves manage to find the right parts and fix all of the machines. Now, they just need to send the command to boot up the machines and get the sand flowing\u00a0again.</blockquote>\n<blockquote>The machines are far apart and wired together with long cables. The cables don\u2019t connect to the machines directly, but rather to communication modules attached to the machines that perform various initialization tasks and also act as communication relays.</blockquote>\n<blockquote>Modules communicate using pulses. Each pulse is either a high pulse or a low pulse. When a module sends a pulse, it sends that type of pulse to each module in its list of destination modules.</blockquote>\n<blockquote>There are several different types of\u00a0modules:</blockquote>\n<blockquote>Flip-flop modules (prefix %) are either on or off; they are initially off. If a flip-flop module receives a high pulse, it is ignored and nothing happens. However, if a flip-flop module receives a low pulse, it flips between on and off. If it was off, it turns on and sends a high pulse. If it was on, it turns off and sends a low\u00a0pulse.</blockquote>\n<blockquote>Conjunction modules (prefix &amp;) remember the type of the most recent pulse received from each of their connected input modules; they initially default to remembering a low pulse for each input. When a pulse is received, the conjunction module first updates its memory for that input. Then, if it remembers high pulses for all inputs, it sends a low pulse; otherwise, it sends a high\u00a0pulse.</blockquote>\n<blockquote>There is a single broadcast module (named broadcaster). When it receives a pulse, it sends the same pulse to all of its destination modules.</blockquote>\n<blockquote>Here at Desert Machine Headquarters, there is a module with a single button on it called, aptly, the button module. When you push the button, a single low pulse is sent directly to the broadcaster module.</blockquote>\n<blockquote>After pushing the button, you must wait until all pulses have been delivered and fully handled before pushing it again. Never push the button if modules are still processing pulses.</blockquote>\n<blockquote>Pulses are always processed in the order they are sent. So, if a pulse is sent to modules a, b, and c, and then module a processes its pulse and sends more pulses, the pulses sent to modules b and c would have to be handled\u00a0first.</blockquote>\n<blockquote>The module configuration (your puzzle input) lists each module. The name of the module is preceded by a symbol identifying its type, if any. The name is then followed by an arrow and a list of its destination modules. For\u00a0example:</blockquote>\n<blockquote>broadcaster -&gt; a, b, c<br>%a -&gt; b<br>%b -&gt; c<br>%c -&gt; inv<br>&amp;inv -&gt;\u00a0a</blockquote>\n<blockquote>In this module configuration, the broadcaster has three destination modules named a, b, and c. Each of these modules is a flip-flop module (as indicated by the % prefix). a outputs to b which outputs to c which outputs to another module named inv. inv is a conjunction module (as indicated by the &amp; prefix) which, because it has only one input, acts like an inverter(it sends the opposite of the pulse type it receives); it outputs to\u00a0a.</blockquote>\n<blockquote>By pushing the button once, the following pulses are\u00a0sent:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>broadcaster -low-&gt; b<br>broadcaster -low-&gt; c<br>a -high-&gt; b<br>b -high-&gt; c<br>c -high-&gt; inv<br>inv -low-&gt; a<br>a -low-&gt; b<br>b -low-&gt; c<br>c -low-&gt; inv<br>inv -high-&gt;\u00a0a</blockquote>\n<blockquote>After this sequence, the flip-flop modules all end up off, so pushing the button again repeats the same sequence.</blockquote>\n<blockquote>Here\u2019s a more interesting example:</blockquote>\n<blockquote>broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt;\u00a0output</blockquote>\n<blockquote>This module configuration includes the broadcaster, two flip-flops (named aand b), a single-input conjunction module (inv), a multi-input conjunction module (con), and an untyped module named output (for testing purposes). The multi-input conjunction module con watches the two flip-flop modules and, if they're both on, sends a low pulse to the output\u00a0module.</blockquote>\n<blockquote>Here\u2019s what happens if you push the button\u00a0once:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -high-&gt; output<br>b -high-&gt; con<br>con -low-&gt;\u00a0output</blockquote>\n<blockquote>Both flip-flops turn on and a low pulse is sent to output! However, now that both flip-flops are on and con remembers a high pulse from each of its two inputs, pushing the button a second time does something different:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt;\u00a0output</blockquote>\n<blockquote>Flip-flop a turns off! Now, con remembers a low pulse from module a, and so it sends only a high pulse to\u00a0output.</blockquote>\n<blockquote>Push the button a third\u00a0time:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -low-&gt; output<br>b -low-&gt; con<br>con -high-&gt;\u00a0output</blockquote>\n<blockquote>This time, flip-flop a turns on, then flip-flop b turns off. However, before b can turn off, the pulse sent to con is handled first, so it briefly remembers all high pulses for its inputs and sends a low pulse to output. After that, flip-flop b turns off, which causes con to update its state and send a high pulse to\u00a0output.</blockquote>\n<blockquote>Finally, with a on and b off, push the button a fourth\u00a0time:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt;\u00a0output</blockquote>\n<blockquote>This completes the cycle: a turns off, causing con to remember only low pulses and restoring all modules to their original\u00a0states.</blockquote>\n<blockquote>To get the cables warmed up, the Elves have pushed the button 1000 times. How many pulses got sent as a result (including the pulses sent by the button\u00a0itself)?</blockquote>\n<blockquote>In the first example, the same thing happens every time the button is pushed: 8 low pulses and 4 high pulses are sent. So, after pushing the button 1000 times, 8000 low pulses and 4000 high pulses are sent. Multiplying these together gives 32000000.</blockquote>\n<blockquote>In the second example, after pushing the button 1000 times, 4250 low pulses and 2750 high pulses are sent. Multiplying these together gives 11687500.</blockquote>\n<blockquote>Consult your module configuration; determine the number of low pulses and high pulses that would be sent after pushing the button 1000 times, waiting for all pulses to be fully handled after each push of the button. What do you get if you multiply the total number of low pulses sent by the total number of high pulses\u00a0sent?</blockquote>\n<p>So, let\u2019s begin with a simple visualization of a case with just 2 machines connected:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Y70DVIH19S3lfweAYNLiAw.png\"></figure><p>CM aka Communication modules are attached to machines that perform various initialization tasks and also act as communication relays.</p>\n<p><strong>Types:</strong></p>\n<ul>\n<li>\n<strong>Flip-flop</strong> (%)\u200a\u2014\u200aON | <em>OFF (Default)<br></em> * High Pulse: Ignore<br> * Low Pulse: Flips state<br>\u200a\u2014\u200aif Off: flips to ON + returns High Pulse<br>\u200a\u2014\u200aif ON: flips to OFF + returns Low\u00a0Pulse</li>\n<li>\n<strong>Conjunction</strong> (&amp;)\u200a\u2014\u200a<em>Low pulse (Default)<br></em> * Remembers the most recent pulse for each input module<br> * for input pulse: updates memory, return High or\u00a0Low</li>\n<li>\n<strong>Broadcast</strong> (broadcaster)<br> * input pulse -&gt; sends the same pulse to all destination modules</li>\n</ul>\n<blockquote>Now, at Desert Machine Headquarters, there is a module with a single button on it called, <strong>aptly</strong>, the button module. <strong>When you push the button</strong>, a single <strong>low pulse</strong> is sent directly to the broadcaster module.</blockquote>\n<p>Once we push aptly we must wait until all pulses have been processed for all modules in our\u00a0network.</p>\n<blockquote>Pulses are <strong>always processed in the order</strong> they are\u00a0sent.</blockquote>\n<blockquote>So, if a pulse is sent to modules a, b, and c, and then module a processes its pulse and sends more pulses, the pulses sent to modules b and c would have to be handled\u00a0first.</blockquote>\n<p>So, we can see that the system in a way is \u201c<strong><em>queueing</em></strong>\u201d the requests!</p>\n<p>Now, we are given a <strong><em>module configuration</em></strong> (input)<strong><em> </em></strong>which is something like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/661/1*1ONY5Hc4KshvHMd3nfVXmg.png\"></figure><blockquote>where, the <strong>broadcaster</strong> has <strong>three destination modules</strong> named a, b, and c. Each of these modules is a <strong>flip-flop module</strong> (as indicated by the %\u00a0prefix).</blockquote>\n<blockquote>- a outputs to b which outputs to c which outputs to another module named\u00a0inv.</blockquote>\n<blockquote>- inv is a <strong>conjunction</strong> module (as indicated by the &amp; prefix) which, because it has only one input, acts like an <strong>inverter</strong>(it sends the opposite of the pulse type it receives); it outputs to\u00a0a.</blockquote>\n<p>By pushing the aptly button once, the following pulses are\u00a0sent:</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>broadcaster -low-&gt; b<br>broadcaster -low-&gt; c<br>a -high-&gt; b<br>b -high-&gt; c<br>c -high-&gt; inv<br>inv -low-&gt; a<br>a -low-&gt; b<br>b -low-&gt; c<br>c -low-&gt; inv<br>inv -high-&gt; a</pre>\n<p>Let\u2019s understand this with a visualization:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*_6D9nF-fllU8iipiJcCUGQ.png\"><figcaption>Starting from 1 \u2192\u00a012</figcaption></figure><p>After this sequence, the flip-flop modules all end up <strong>OFF</strong>, so pushing the button again <strong>repeats the same sequence</strong>.</p>\n<p>We are given another\u00a0example:</p>\n<pre>broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output</pre>\n<p>Here\u2019s what happens if you push the button\u00a0<strong>once</strong>:</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -high-&gt; output<br>b -high-&gt; con<br>con -low-&gt; output</pre>\n<blockquote>Both flip-flops turn on and a low pulse is sent to output! However, now that both flip-flops are on and con remembers a high pulse from each of its two\u00a0inputs</blockquote>\n<p>Pushing the button <strong>second</strong>\u00a0time?</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt; output</pre>\n<blockquote>Flip-flop a turns off! Now, con remembers a low pulse from module a, and so it sends only a high pulse to\u00a0output.</blockquote>\n<p>And <strong>third</strong>\u00a0time?</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -low-&gt; output<br>b -low-&gt; con<br>con -high-&gt; output</pre>\n<blockquote>This time, flip-flop a turns on, then flip-flop b turns off. However, before b can turn off, the pulse sent to con is handled first, so it briefly remembers all high pulses for its inputs and sends a low pulse to output. After that, flip-flop b turns off, which causes con to update its state and send a high pulse to\u00a0output.</blockquote>\n<p>Finally, with a on and b off, push the button a <strong>fourth</strong>\u00a0time:</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt; output</pre>\n<blockquote>This completes the cycle: a turns off, causing con to remember only low pulses and restoring all modules to their original\u00a0states.</blockquote>\n<p>Now, the problem states\u00a0that:</p>\n<blockquote>To get the cables warmed up, the Elves have pushed the button <strong>1000</strong> times. <strong>How many pulses got sent as a result (including the pulses sent by the button\u00a0itself)?</strong>\n</blockquote>\n<p>\u2014\u200a\u2014\u200a\u2014</p>\n<p>Phew! This one is going to be intense! I can feel it. We need to simulate the circuit and remember the states. Seems like OOP might be the perfect way to solve this one!\u00a0;)</p>\n<p>Let\u2019s first write our base\u00a0case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/990/1*HlVJcsTXqVz26jf_ZTL1Tw.png\"><figcaption>Skelton code, a good point to\u00a0start!</figcaption></figure><p>As mentioned, I am heavily leaning towards an object-oriented approach here as it will allow us to simulate the behavior of the different types of modules and their interactions when the button is\u00a0pressed!</p>\n<p>The key components on top of my mind\u00a0are:</p>\n<ol>\n<li>\n<strong>Module Classes</strong>: Representing different types of modules (Flip-flop, Conjunction, Broadcaster and\u00a0Untyped</li>\n<li>\n<strong>Pulse Management</strong>: Handling the sending and processing of\u00a0pulses.</li>\n<li>\n<strong>Simulation Logic</strong>: To simulate the process of pushing the button and propagating the\u00a0pulses.</li>\n</ol>\n<p>Let\u2019s start by defining the classes and their\u00a0methods:</p>\n<p><strong>Module Classes</strong></p>\n<ul>\n<li>BaseModule: An abstract class for common module functionality.</li>\n<li>FlipFlopModule: Represents a flip-flop module.</li>\n<li>ConjunctionModule: Represents a conjunction module.</li>\n<li>BroadcasterModule: Represents the broadcaster module.</li>\n<li>Untyped: Represents the untyped\u00a0module.</li>\n</ul>\n<p>Also, to keep track of Pulse Type and Module State, we can just define enum classes to make the code\u00a0cleaner?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/255/1*I1c-BOKWFnoccuWn6NbX3w.png\"></figure><p>Let\u2019s see our base class for Module\u00a0?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/886/1*ofTrW1MllkJJg9fGL2VyYg.png\"><figcaption>We are leaving receive_pulse to be implemented by it\u2019s derived\u00a0classes</figcaption></figure><p>Now let\u2019s implement:</p>\n<h4><strong>FlipFlopModule</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/880/1*Cn5YlWI4wpCzvgEkW0INrg.png\"></figure><p>The FlipFlopModule class initialises the object with State.OFF. We implement the receive_pulse method that changes the state of the module based on the received\u00a0pulse.</p>\n<ul>\n<li>If the received pulse is LOW, the state of the module is\u00a0toggled.</li>\n<li>If the current state is OFF, it is changed to ON, and vice\u00a0versa.</li>\n</ul>\n<p>After changing the state, the module sends a\u00a0pulse.</p>\n<ul><li>If the new state is ON, it sends a HIGH pulse, otherwise it sends a LOW\u00a0pulse.</li></ul>\n<h4><strong>ConjunctionModule</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/912/1*VfOa_n3I5GJbnitIfEuiPw.png\"></figure><p>The ConjunctionModule class has a __init__ method that sets the name of the module and initializes a list of input states. The number of input states is determined by the inputs parameter, which is a list of input module names. Initially, all input states are set to\u00a0LOW.</p>\n<p>The receive_pulse method is used to receive a pulse at a specific input. The pulse can be either HIGH or LOW, and the corresponding input state is updated accordingly. After updating the input state, the method checks if all input states are HIGH. If they are, it sends a LOW pulse; otherwise, it sends a HIGH pulse. This behavior is the opposite of a typical AND gate, which would output HIGH when all inputs are\u00a0HIGH.</p>\n<h4>BroadcasterModule</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/391/1*3EtOqzJ_62qm0hIiS8KtLQ.png\"></figure><p>This represents a broadcaster module, which is a type of digital circuit that broadcasts the same pulse to all of its destination modules.</p>\n<p>The BroadcasterModule class has a receive_pulse method that immediately sends the received pulse to all destination modules. The pulse can be either HIGH or LOW. This behavior is implemented by calling the send_pulse method with the received pulse as the argument.</p>\n<h4>UntypedModule</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/520/1*RVfi_3TB_awl3Kb7j1cmCg.png\"></figure><p>It represents a module that can receive pulses but does not have a specific\u00a0type.</p>\n<p>The receive_pulse method is used to receive a pulse and the name of the input module. The pulse can be either HIGH or LOW. The method appends the received pulse to the list of received pulses and then do\u00a0nothing!</p>\n<h4>ModuleFactory</h4>\n<blockquote>\ud83d\udcad I think this is a cookie-cutter case for <a href=\"https://refactoring.guru/design-patterns/factory-method\">Factory Pattern</a> as we can create module instances based on their types as indicated by their names or prefixes.</blockquote>\n<p>We can define a<strong>ModuleFactory</strong> class responsible for creating module instances based on the input\u00a0string.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/780/1*UGX9EiIMNauksqNmN5npMA.png\"></figure><p>This is pretty much self explanatory!</p>\n<h3>Simulation</h3>\n<p>Once all our pieces are set up! We are good to go to implement our simulation class that will orchestrate a pulse run for each button press and track everything we\u00a0need!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/784/1*2IqQGmpd_CmjD7yWctpobw.png\"></figure><p>Now to orchestrate all of this, one of the most important parts is to parse the config_lines and set up our modules correctly with the type, state and destination so when they receive a Pulse, they can send it forward correctly!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VMVnpRAsA7fWBIccMghhng.png\"><figcaption>Here, we are setting up both modules and their respective connections in the destinations.</figcaption></figure><p>Let\u2019s now run our first base test\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/804/1*1zKsJ-qF1GJEwNP9-phpIg.png\"></figure><p>And it failed! Let\u2019s\u00a0debug?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*hIXwdJ3DA1z9hz4mrFqyNw.png\"></figure><p>And after some debugging and back and forth, we can see it is counting <strong>LOW_PULSE_COUNT</strong> and <strong>HIGH_PULSE_COUNT</strong> correctly for the first run, now we just need to let it run <strong>1000</strong> times and return the product of both\u00a0counts!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>\u2705 test_count_pulses_in_the_circuit() passed<br><br>[Done] exited with code=0 in 0.237 seconds</pre>\n<p>Perfect! Now, let\u2019s test our code for thesecond example in the problem? This way we will be able to ensure we are covering all the edge\u00a0cases!</p>\n<pre>broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/799/1*UOljqE7Ol8Pi9zI7TrJzdQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>\u2705 test_count_pulses_in_the_circuit() passed<br>Traceback (most recent call last):<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\", line 195, in &lt;module&gt;<br>    test_count_pulses_in_the_circuit_b()<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\", line 185, in test_count_pulses_in_the_circuit_b<br>    modules = setup_modules(input_str.splitlines())<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\", line 158, in setup_modules<br>    modules[source_name].add_destination(modules[dest_name])<br>KeyError: 'output'<br><br>[Done] exited with code=1 in 0.244 seconds</pre>\n<p>Whoops! We got stuck in an error as we are not initiating Modules for destinations, which is leading to an error for Output which should be an UntypedModule.</p>\n<p>We can update our setup_modules() code to handle that once we create all modules for the source part of the\u00a0config:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/879/1*VXdtM5pVeItvdWbDGgdY-g.png\"></figure><p>Let\u2019s run the test case again? And\u00a0voila!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>\u2705 test_count_pulses_in_the_circuit_b() passed<br><br>[Done] exited with code=0 in 0.231 seconds</pre>\n<p>I feel pretty good about this code as it has a good runtime and has quite a clean code making it easy to\u00a0debug.</p>\n<p>Let\u2019s load up our puzzle input and see if we get an\u00a0answer?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*q3AM8ioIDVERo9qxGvIlkw.png\"></figure><p>And\u2026executing the\u00a0code\u2026</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>\u2757\ufe0f Product of total number of low pulses sent by the total number of high pulses sent: XXXXXXXXX<br><br>[Done] exited with code=0 in 0.248 seconds</pre>\n<p>We get an answer! Let\u2019s input this in our answer\u00a0box?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Vwpxsur1qGWQ8e3b8g6ErQ.png\"><figcaption>\u2b50\ufe0f</figcaption></figure><p>Boom! Let me paste our well-structured object-oriented code till\u00a0now:</p>\n<pre># Day 20 - Pulse Propagation<br><br>from enum import Enum<br>from collections import deque<br><br># Constants<br><br># dict to hold the count of inputs for each module<br>INPUT_TRACKER = {}<br># global queue to hold pulses<br>PULSE_QUEUE = deque()<br># to hold the count of low and high pulses<br>LOW_PULSE_COUNT, HIGH_PULSE_COUNT = 0, 0<br><br># Enums<br><br>class State(Enum):<br>    ON = 1<br>    OFF = 0<br><br><br>class Pulse(Enum):<br>    HIGH = 1<br>    LOW = 0<br><br><br>class ModuleType(Enum):<br>    FLIP_FLOP = \"%\"<br>    CONJUNCTION = \"&amp;\"<br>    BROADCASTER = \"broadcaster\"<br><br># Classes<br><br>class Module:<br>    def __init__(self, name):<br>        self.name = name<br>        self.destinations = []<br><br>    def add_destination(self, module):<br>        self.destinations.append(module)<br><br>    def send_pulse(self, pulse):<br>        for dest_module in self.destinations:<br>            PULSE_QUEUE.append((pulse, dest_module.name, self.name))<br>            update_pulse_count(pulse)<br><br>    def receive_pulse(self, pulse, input_name):<br>        raise NotImplementedError(\"Subclass must implement receive_pulse method\")<br><br><br>class FlipFlopModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.state = State.OFF<br><br>    def receive_pulse(self, pulse, src_module):<br>        if pulse == Pulse.LOW:<br>            self.state = State.ON if self.state == State.OFF else State.OFF<br>            self.send_pulse(Pulse.HIGH if self.state == State.ON else Pulse.LOW)<br><br><br>class ConjunctionModule(Module):<br>    def __init__(self, name, inputs):<br>        super().__init__(name)<br>        self.inputs = inputs  # List of input module names<br>        self.input_states = {input_name: Pulse.LOW for input_name in inputs}<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.input_states[src_module] = pulse<br><br>        if all(state == Pulse.HIGH for state in self.input_states.values()):<br>            self.send_pulse(Pulse.LOW)<br>        else:<br>            self.send_pulse(Pulse.HIGH)<br><br><br>class BroadcasterModule(Module):<br>    def receive_pulse(self, pulse, src_module):<br>        self.send_pulse(pulse)<br><br><br>class UntypedModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.received_pulses = []<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.received_pulses.append(pulse)<br><br><br>class ModuleFactory:<br>    @staticmethod<br>    def create_module(module_identifier):<br>        if module_identifier.startswith(ModuleType.FLIP_FLOP.value):<br>            return FlipFlopModule(module_identifier[1:])<br>        elif module_identifier.startswith(ModuleType.CONJUNCTION.value):<br>            # Determine the number of inputs for the conjunction module<br>            name = module_identifier[1:]<br>            module_inputs = INPUT_TRACKER[name]<br>            return ConjunctionModule(name, module_inputs)<br>        elif module_identifier == ModuleType.BROADCASTER.value:<br>            return BroadcasterModule(module_identifier)<br>        else:<br>            return UntypedModule(module_identifier)<br><br><br>class Simulation:<br>    def __init__(self, modules):<br>        self.modules = modules<br><br>    def run_simulation(self, button_presses):<br>        for _ in range(button_presses):<br>            # Simulate button press - send a low pulse to broadcaster<br>            update_pulse_count(Pulse.LOW)<br>            self.modules[\"broadcaster\"].receive_pulse(Pulse.LOW, \"button\")<br><br>            # Process pulses in the queue<br>            while PULSE_QUEUE:<br>                pulse, dest_module, src_module = PULSE_QUEUE.popleft()<br>                self.modules[dest_module].receive_pulse(pulse, src_module)<br><br># Util functions<br><br>def update_pulse_count(pulse):<br>    global LOW_PULSE_COUNT, HIGH_PULSE_COUNT<br>    if pulse == Pulse.LOW:<br>        LOW_PULSE_COUNT += 1<br>    elif pulse == Pulse.HIGH:<br>        HIGH_PULSE_COUNT += 1<br><br><br>def process_input_count(config_lines):<br>    global INPUT_TRACKER<br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source = parts[0].strip()<br>        if len(parts) &gt; 1:<br>            destinations = [dest.strip() for dest in parts[1].split(\",\")]<br><br>            for dest in destinations:<br>                # Remove any prefix from the destination name<br>                dest = dest.lstrip(\"%&amp;\")<br>                source = source.lstrip(\"%&amp;\")<br>                if dest not in INPUT_TRACKER:<br>                    INPUT_TRACKER[dest] = set()<br>                INPUT_TRACKER[dest].add(source)<br><br><br>def setup_modules(config_lines):<br>    modules = {}<br>    connections = {}<br><br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source_name = parts[0].strip()<br>        dest_names = parts[1].split(\",\") if len(parts) &gt; 1 else []<br>        clean_source_name = source_name.lstrip(\"%&amp; \")<br><br>        if clean_source_name not in modules:<br>            modules[clean_source_name] = ModuleFactory.create_module(source_name)<br><br>        for dest_name in dest_names:<br>            if clean_source_name not in connections:<br>                connections[clean_source_name] = []<br>            connections[clean_source_name].append(dest_name)<br><br>    # Set up connections<br>    for source_name, dest_names in connections.items():<br>        for dest_name in dest_names:<br>            dest_name = dest_name.strip()<br>            if dest_name not in modules:<br>                # Create module if it doesn't exist for destination<br>                modules[dest_name] = ModuleFactory.create_module(dest_name)<br>            modules[source_name].add_destination(modules[dest_name])<br><br>    return modules<br><br># Tests<br><br>def test_count_pulses_in_the_circuit_a():<br>    input_str = \"\"\"broadcaster -&gt; a, b, c<br>%a -&gt; b<br>%b -&gt; c<br>%c -&gt; inv<br>&amp;inv -&gt; a\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 32000000, f\"Expected 32000000, got {num_pulses}\"<br>    print(\"\u2705 test_count_pulses_in_the_circuit_a() passed\")<br><br><br>def test_count_pulses_in_the_circuit_b():<br>    input_str = \"\"\"broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 11687500, f\"Expected 11687500, got {num_pulses}\"<br>    print(\"\u2705 test_count_pulses_in_the_circuit_b() passed\")<br><br># Main<br><br>def part_one():<br>    with open(\"day_20/input.txt\") as f:<br>        config_lines = f.readlines()<br>    process_input_count(config_lines)<br>    modules = setup_modules(config_lines)<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    print(<br>        f\"\u2757\ufe0f Product of total number of low pulses sent by the \\<br>total number of high pulses sent: {num_pulses}\"<br>    )<br><br><br><br>if __name__ == \"__main__\":<br>    # test_count_pulses_in_the_circuit_a()<br>    # test_count_pulses_in_the_circuit_b()<br>    part_one()</pre>\n<blockquote>\u2757\ufe0fThe one limitation of our code here is that, we can only run 1 simulation at a time as we are using global variables to keep pulse count and queue. We shall address this in part\u00a02.</blockquote>\n<h3>Part Two</h3>\n<blockquote>The final machine responsible for moving the sand down to Island Island has a module attached named rx. The machine turns on when a single low pulse is sent to\u00a0rx.</blockquote>\n<blockquote>Reset all modules to their default states. Waiting for all pulses to be fully handled after each button press, what is the fewest number of button presses required to deliver a single low pulse to the module named\u00a0rx?</blockquote>\n<p>Well, this seems simple?! All we need to do is track the <strong>min_num_of_button_press</strong> to send a <strong>Pulse.LOW</strong> to <strong>rx</strong>\u00a0module!</p>\n<p>We can define a new function <strong>run_simulation_until_rx</strong>() that will basically keep pressing the button to go through the circuit till we recieve a <strong>Pulse.LOW</strong> headed towards <strong>rx</strong>\u00a0module:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*cf_sJv7kTPgj_HYq4tuPkA.png\"></figure><p>.</p>\n<p>.</p>\n<p>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e0DWVRgnAIaEdnyiKrwc4g.png\"></figure><p>.</p>\n<p>.</p>\n<p>Well, it may not be as simple as we thought first! ~6 mins later, we are at <strong>521553 button presses</strong> with no sight of <strong>Pulse.LOW</strong> to\u00a0<strong>rx</strong>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*9vzN6PdVdi0UQD-J2r6tIg.png\"></figure><p>I knew it was too good to be this simple! First things first, let\u2019s add a __repr__ method to our base Module class so we don\u2019t have to deal with this in our debugger:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/689/1*5WYArCFYmp5oTXaeRr1-Sg.png\"></figure><p>Let\u2019s make it human readable without having to click through each object to see it\u2019s properties:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/831/1*lAsyzzp01PExQ5Br2sx4tw.png\"><figcaption>Much better!</figcaption></figure><p>Now, looking at our puzzle input, the only module that has rx as a destination is &amp;dn (<em>ConjunctionModule</em>).</p>\n<pre>&amp;dn -&gt; rx</pre>\n<p>Let\u2019s add that to our watch list to see how it changes the input_states as it can\u2019t send a Pulse.LOW to rx until all its input_states are set to Pulse.HIGH!</p>\n<p>We can see that &amp;dn has 4 callers -&gt; xp, fh, dd, fc and they all are initiated as Pulse.LOW\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/965/1*PyvjzT0ylkr0_stFW2zIDQ.png\"><figcaption>`dn` state as of initialization!</figcaption></figure><p>After 1 cycle complete (i.e. button_presses == 1), here\u2019s how&amp;dn looks\u00a0like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/953/1*Sy-valqJbyw2o9VD_P4stQ.png\"><figcaption>We got 4 pulses to `rx` but all of them were\u00a0HIGH.</figcaption></figure><p>We basically need to find a case where all 4 of xp, fh, dd, fc become Pulse.HIGH\u00a0. I am inclined to think that all 4 of these states may have some cycles and we might need to find a common point where these cycles will co-incide?</p>\n<p>Let\u2019s create a breakpoint to see if we ever get a Pulse.HIGH for either of these\u00a04?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*dIRug3xC7pgkv4sLPy2kKA.png\"><figcaption>conditional breakpoint</figcaption></figure><p>So, at <strong>3917</strong> we found our first call to fc with Pulse.HIGH\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/935/1*7GaNuBsjjfTcCchRib16Fw.png\"></figure><p>which will then modify our dn <strong><em>input_states</em></strong> to:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/941/1*gFecxOnyS1VMSgyeOqoGaw.png\"></figure><p>And similarly, on <strong>3919</strong> button press, we get Pulse.HIGH for\u00a0xp</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/941/1*OCZiRwypqnfCOMLWcWQ_lA.png\"></figure><p>changing our dn input_states to:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/969/1*xDDWxfqkikoYpVEzIGHmJQ.png\"></figure><p>Then for <strong>4003</strong> time, we get one for\u00a0dd</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/949/1*0zttMxeT1CgVMs4Y38WqHw.png\"></figure><p>making our dn input_states:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/947/1*cJI65wFsXn3b3NxRLstwIw.png\"></figure><p>Lastly, we get Pulse.HIGH for fh at <strong>4027</strong> button\u00a0press:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/897/1*lMbzrDmOwMUwe2pL0KhQhw.png\"></figure><p>making our dn to\u00a0be:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/977/1*oe5AHnPrFKqAEvCTMFPgXg.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/930/1*cKbg0KwNmUnUexBhC5-VTQ.png\"></figure><blockquote>\u2757\ufe0fNow! Moving on! We can see that the next event comes at <strong>7834th time </strong>for fc and if you scroll up, the last event came at <strong>3917 </strong>i.e:\u00a0<strong>7834/2</strong>\n</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/930/1*cKbg0KwNmUnUexBhC5-VTQ.png\"></figure><p>This helps us establish that each of these input modules has its own cycle! And now this helps us deduce this down an <a href=\"https://en.wikipedia.org/wiki/Least_common_multiple\">LCM (Lowest common multiple)</a> problem, where all we need to find is what will be the first time in our button press cycle when all 4 xp, fh, dd, fc will receive Pulse.HIGH that will emit a Pulse.LOW to rx\u00a0!</p>\n<p>This is now a simple mathematical problem!</p>\n<p>We can find the LCM for 3917, 3919, 4003 and 4027\u00a0i.e:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/156/0*-P0cFbDuOcFe89ES\"></figure><p>We can whip up a quick python script to find\u00a0that:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/489/1*bL5iyR6GjNY6YnnIIfTwkQ.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>XXXXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.218 seconds</pre>\n<p>Let\u2019s put this in our answer box and\u2026.yes! Our hunch was absolutely correct.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YBMYkpHVMeQoSp9dzh-dWQ.png\"><figcaption>YESSS!!</figcaption></figure><p>Well, since it is not physically possible for us to keep running our code for 200 Trillions+ (answer in some ballpark) times, we need to just update our code to find the first occurence for each xp, fh, dd, fc and then just find the LCM and\u00a0exit:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*foKEVUYnle6qfKqKKICyEQ.png\"><figcaption>Some debugging steps\u00a0later</figcaption></figure><p>Here\u2019s our updated run_simulation_until_rx() that will iterate\u00a0till:</p>\n<pre>all(idx &gt; 0 for idx in rx_callers_high_pulse_idx.values())</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wbwgKvxtCDalX9lonbfBmQ.png\"></figure><p>Let\u2019s run it and see if we are getting the correct answer as we calculated mathematically before?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>\u2757\ufe0f\u2757\ufe0f Number of button presses required to activate the Rx: XXXXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.412 seconds</pre>\n<p>Yep! XXXXXXXXXXXXXXX == XXXXXXXXXXXXXXX \ud83e\udd13</p>\n<p>Here\u2019s our full code for both Part 1 and\u00a02:</p>\n<pre># Day 20 - Pulse Propagation<br><br>from enum import Enum<br>from collections import deque<br>from math import gcd<br>from functools import reduce<br><br># Constants<br><br># dict to hold the count of inputs for each module<br>INPUT_TRACKER = {}<br># global queue to hold pulses<br>PULSE_QUEUE = deque()<br># to hold the count of low and high pulses<br>LOW_PULSE_COUNT, HIGH_PULSE_COUNT = 0, 0<br><br># Enums<br><br>class State(Enum):<br>    ON = 1<br>    OFF = 0<br><br><br>class Pulse(Enum):<br>    HIGH = 1<br>    LOW = 0<br><br><br>class ModuleType(Enum):<br>    FLIP_FLOP = \"%\"<br>    CONJUNCTION = \"&amp;\"<br>    BROADCASTER = \"broadcaster\"<br><br># Classes<br><br>class Module:<br>    def __init__(self, name):<br>        self.name = name<br>        self.destinations = []<br><br>    def add_destination(self, module):<br>        self.destinations.append(module)<br><br>    def send_pulse(self, pulse):<br>        for dest_module in self.destinations:<br>            PULSE_QUEUE.append((pulse, dest_module.name, self.name))<br>            update_pulse_count(pulse)<br><br>    def receive_pulse(self, pulse, input_name):<br>        raise NotImplementedError(\"Subclass must implement receive_pulse method\")<br><br><br>class FlipFlopModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.state = State.OFF<br><br>    def __repr__(self) -&gt; str:<br>        return f\"Module({self.name} - {self.state})\"<br><br>    def receive_pulse(self, pulse, src_module):<br>        if pulse == Pulse.LOW:<br>            self.state = State.ON if self.state == State.OFF else State.OFF<br>            self.send_pulse(Pulse.HIGH if self.state == State.ON else Pulse.LOW)<br><br><br>class ConjunctionModule(Module):<br>    def __init__(self, name, inputs):<br>        super().__init__(name)<br>        self.inputs = inputs  # List of input module names<br>        self.input_states = {input_name: Pulse.LOW for input_name in inputs}<br><br>    def __repr__(self) -&gt; str:<br>        return f\"Module({self.name} - {self.input_states})\"<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.input_states[src_module] = pulse<br><br>        if all(state == Pulse.HIGH for state in self.input_states.values()):<br>            self.send_pulse(Pulse.LOW)<br>        else:<br>            self.send_pulse(Pulse.HIGH)<br><br><br>class BroadcasterModule(Module):<br>    def receive_pulse(self, pulse, src_module):<br>        self.send_pulse(pulse)<br><br><br>class UntypedModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.received_pulses = {Pulse.LOW: 0, Pulse.HIGH: 0}<br><br>    def __repr__(self) -&gt; str:<br>        return f\"Module({self.name} - {self.received_pulses})\"<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.received_pulses[pulse] += 1<br><br><br>class ModuleFactory:<br>    @staticmethod<br>    def create_module(module_identifier):<br>        if module_identifier.startswith(ModuleType.FLIP_FLOP.value):<br>            return FlipFlopModule(module_identifier[1:])<br>        elif module_identifier.startswith(ModuleType.CONJUNCTION.value):<br>            # Determine the number of inputs for the conjunction module<br>            name = module_identifier[1:]<br>            module_inputs = INPUT_TRACKER[name]<br>            return ConjunctionModule(name, module_inputs)<br>        elif module_identifier == ModuleType.BROADCASTER.value:<br>            return BroadcasterModule(module_identifier)<br>        else:<br>            return UntypedModule(module_identifier)<br><br><br>class Simulation:<br>    def __init__(self, modules):<br>        self.modules = modules<br><br>    def run_simulation(self, button_presses):<br>        for _ in range(button_presses):<br>            # Simulate button press - send a low pulse to broadcaster<br>            update_pulse_count(Pulse.LOW)<br>            self.modules[\"broadcaster\"].receive_pulse(Pulse.LOW, \"button\")<br><br>            # Process pulses in the queue<br>            while PULSE_QUEUE:<br>                pulse, dest_module, src_module = PULSE_QUEUE.popleft()<br>                self.modules[dest_module].receive_pulse(pulse, src_module)<br><br>    def run_simulation_until_rx(self):<br>        button_presses = 0<br><br>         # rx_source is the only input for rx i.e. &amp;dn<br>        rx_source = list(INPUT_TRACKER['rx'])[0]<br><br>        # dict to hold the index of the rx caller that received a Pulse.HIGH for the first time<br>        rx_callers_high_pulse_idx = {caller: 0 for caller in INPUT_TRACKER[rx_source]}<br><br>        # break when all the rx callers have received a high pulse for the first time<br>        while not all(idx &gt; 0 for idx in rx_callers_high_pulse_idx.values()):<br>            button_presses += 1<br>            self.modules['broadcaster'].receive_pulse(Pulse.LOW, \"button\")<br>            update_pulse_count(Pulse.LOW)<br><br>            while PULSE_QUEUE:<br>                pulse, dest_module, src_module = PULSE_QUEUE.popleft()<br>                self.modules[dest_module].receive_pulse(pulse, src_module)<br><br>                # update the index of the rx caller that received a high pulse for the first time<br>                if src_module in rx_callers_high_pulse_idx.keys() and  pulse == Pulse.HIGH:<br>                    rx_callers_high_pulse_idx[src_module] = button_presses<br><br>        # lcm formula<br>        lcm = lambda x, y: x * y // gcd(x, y)<br><br>        # find LCM for all the values in rx_callers_high_pulse_idx<br>        return reduce(lcm, list(rx_callers_high_pulse_idx.values()))<br><br><br># Util functions<br><br>def update_pulse_count(pulse):<br>    global LOW_PULSE_COUNT, HIGH_PULSE_COUNT<br>    if pulse == Pulse.LOW:<br>        LOW_PULSE_COUNT += 1<br>    elif pulse == Pulse.HIGH:<br>        HIGH_PULSE_COUNT += 1<br><br><br>def process_input_count(config_lines):<br>    global INPUT_TRACKER<br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source = parts[0].strip()<br>        if len(parts) &gt; 1:<br>            destinations = [dest.strip() for dest in parts[1].split(\",\")]<br><br>            for dest in destinations:<br>                # Remove any prefix from the destination name<br>                dest = dest.lstrip(\"%&amp;\")<br>                source = source.lstrip(\"%&amp;\")<br>                if dest not in INPUT_TRACKER:<br>                    INPUT_TRACKER[dest] = set()<br>                INPUT_TRACKER[dest].add(source)<br><br><br>def setup_modules(config_lines):<br>    modules = {}<br>    connections = {}<br><br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source_name = parts[0].strip()<br>        dest_names = parts[1].split(\",\") if len(parts) &gt; 1 else []<br>        clean_source_name = source_name.lstrip(\"%&amp; \")<br><br>        if clean_source_name not in modules:<br>            modules[clean_source_name] = ModuleFactory.create_module(source_name)<br><br>        for dest_name in dest_names:<br>            if clean_source_name not in connections:<br>                connections[clean_source_name] = []<br>            connections[clean_source_name].append(dest_name)<br><br>    # Set up connections<br>    for source_name, dest_names in connections.items():<br>        for dest_name in dest_names:<br>            dest_name = dest_name.strip()<br>            if dest_name not in modules:<br>                # Create module if it doesn't exist for destination<br>                modules[dest_name] = ModuleFactory.create_module(dest_name)<br>            modules[source_name].add_destination(modules[dest_name])<br><br>    return modules<br><br># Tests<br><br>def test_count_pulses_in_the_circuit_a():<br>    input_str = \"\"\"broadcaster -&gt; a, b, c<br>%a -&gt; b<br>%b -&gt; c<br>%c -&gt; inv<br>&amp;inv -&gt; a\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 32000000, f\"Expected 32000000, got {num_pulses}\"<br>    print(\"\u2705 test_count_pulses_in_the_circuit_a() passed\")<br><br><br>def test_count_pulses_in_the_circuit_b():<br>    input_str = \"\"\"broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 11687500, f\"Expected 11687500, got {num_pulses}\"<br>    print(\"\u2705 test_count_pulses_in_the_circuit_b() passed\")<br><br># Main<br><br>def part_one():<br>    with open(\"day_20/input.txt\") as f:<br>        config_lines = f.readlines()<br>    process_input_count(config_lines)<br>    modules = setup_modules(config_lines)<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    print(<br>        f\"\u2757\ufe0f Product of total number of low pulses sent by the \\<br>total number of high pulses sent: {num_pulses}\"<br>    )<br><br>def part_two():<br>    with open(\"day_20/input.txt\") as f:<br>        config_lines = f.readlines()<br>    process_input_count(config_lines)<br>    modules = setup_modules(config_lines)<br>    simulation = Simulation(modules)<br>    button_presses = simulation.run_simulation_until_rx()<br>    print(f\"\u2757\ufe0f\u2757\ufe0f Number of button presses required to activate the Rx: {button_presses}\")<br><br><br>if __name__ == \"__main__\":<br>    # test_count_pulses_in_the_circuit_a()<br>    # test_count_pulses_in_the_circuit_b()<br>    # part_one()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=844ad63b515a\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["coding","advent-of-code","programming","advent-of-code-2023","python"]},{"title":"[Day 19] Aplenty // Advent of Code 2023 (Python)","pubDate":"2023-12-27 20:33:00","link":"https://medium.com/@jatinkrmalik/day-19-aplenty-advent-of-code-2023-python-522ba14b1444?source=rss-ec576e4b06b0------2","guid":"https://medium.com/p/522ba14b1444","author":"Jatin K Malik","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*jciy1cL5lsSK0f7R\"><figcaption>Aplenty (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/19\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>The Elves of Gear Island are thankful for your help and send you on your way. They even have a hang glider that someone <a href=\"https://adventofcode.com/2023/day/9\">stole</a> from Desert Island; since you\u2019re already going that direction, it would help them a lot if you would use it to get down there and return it to\u00a0them.</blockquote>\n<blockquote>As you reach the bottom of the relentless avalanche of machine parts, you discover that they\u2019re already forming a formidable heap. Don\u2019t worry, though\u200a\u2014\u200aa group of Elves is already here organizing the parts, and they have a\u00a0system.</blockquote>\n<blockquote>To start, each part is rated in each of four categories:</blockquote>\n<blockquote>x: Extremely cool\u00a0looking</blockquote>\n<blockquote>m: Musical (it makes a noise when you hit\u00a0it)</blockquote>\n<blockquote>a: Aerodynamic</blockquote>\n<blockquote>s: Shiny</blockquote>\n<blockquote>Then, each part is sent through a series of workflows that will ultimately accept or reject the part. Each workflow has a name and contains a list of rules; each rule specifies a condition and where to send the part if the condition is true. The first rule that matches the part being considered is applied immediately, and the part moves on to the destination described by the rule. (The last rule in each workflow has no condition and always applies if reached.)</blockquote>\n<blockquote>Consider the workflow ex{x&gt;10:one,m&lt;20:two,a&gt;30:R,A}. This workflow is named ex and contains four rules. If workflow ex were considering a specific part, it would perform the following steps in\u00a0order:</blockquote>\n<blockquote>Rule \u201cx&gt;10:one\": If the part's x is more than 10, send the part to the workflow named\u00a0one.</blockquote>\n<blockquote>Rule \u201cm&lt;20:two\": Otherwise, if the part's m is less than 20, send the part to the workflow named\u00a0two.</blockquote>\n<blockquote>Rule \u201ca&gt;30:R\": Otherwise, if the part's a is more than 30, the part is immediately rejected\u00a0(R).</blockquote>\n<blockquote>Rule \u201cA\": Otherwise, because no other rules matched the part, the part is immediately accepted\u00a0(A).</blockquote>\n<blockquote>If a part is sent to another workflow, it immediately switches to the start of that workflow instead and never returns. If a part is accepted (sent to A) or rejected (sent to R), the part immediately stops any further processing.</blockquote>\n<blockquote>The system works, but it\u2019s not keeping up with the torrent of weird metal shapes. The Elves ask if you can help sort a few parts and give you the list of workflows and some part ratings (your puzzle input). For\u00a0example:</blockquote>\n<blockquote>px{a&lt;2006:qkq,m&gt;2090:A,rfg}<br>pv{a&gt;1716:R,A}<br>lnx{m&gt;1548:A,A}<br>rfg{s&lt;537:gd,x&gt;2440:R,A}<br>qs{s&gt;3448:A,lnx}<br>qkq{x&lt;1416:A,crn}<br>crn{x&gt;2662:A,R}<br>in{s&lt;1351:px,qqz}<br>qqz{s&gt;2770:qs,m&lt;1801:hdj,R}<br>gd{a&gt;3333:R,R}<br>hdj{m&gt;838:A,pv}</blockquote>\n<blockquote>{x=787,m=2655,a=1222,s=2876}<br>{x=1679,m=44,a=2067,s=496}<br>{x=2036,m=264,a=79,s=2244}<br>{x=2461,m=1339,a=466,s=291}<br>{x=2127,m=1623,a=2188,s=1013}</blockquote>\n<blockquote>The workflows are listed first, followed by a blank line, then the ratings of the parts the Elves would like you to sort. All parts begin in the workflow named in. In this example, the five listed parts go through the following workflows:</blockquote>\n<blockquote>{x=787,m=2655,a=1222,s=2876}: in -&gt; qqz -&gt; qs -&gt; lnx -&gt;\u00a0A</blockquote>\n<blockquote>{x=1679,m=44,a=2067,s=496}: in -&gt; px -&gt; rfg -&gt; gd -&gt;\u00a0R</blockquote>\n<blockquote>{x=2036,m=264,a=79,s=2244}: in -&gt; qqz -&gt; hdj -&gt; pv -&gt;\u00a0A</blockquote>\n<blockquote>{x=2461,m=1339,a=466,s=291}: in -&gt; px -&gt; qkq -&gt; crn -&gt;\u00a0R</blockquote>\n<blockquote>{x=2127,m=1623,a=2188,s=1013}: in -&gt; px -&gt; rfg -&gt;\u00a0A</blockquote>\n<blockquote>Ultimately, three parts are accepted. Adding up the x, m, a, and s rating for each of the accepted parts gives 7540 for the part with x=787, 4623 for the part with x=2036, and 6951 for the part with x=2127. Adding all of the ratings for all of the accepted parts gives the sum total of\u00a019114.</blockquote>\n<blockquote>Sort through all of the parts you\u2019ve been given; what do you get if you add together all of the rating numbers for all of the parts that ultimately get accepted?</blockquote>\n<blockquote>They even have a hang glider that someone <a href=\"https://adventofcode.com/2023/day/9\">stole</a> from Desert\u00a0Island.</blockquote>\n<p>Ah, well!\u00a0\ud83d\udc40</p>\n<p>So, seems like now we have a <em>relentless avalanche of machine parts</em> that has formed a giant heap. But some elves are trying to organize them based of a system that rates each part in following 4 categories:</p>\n<ul>\n<li>x: Extremely cool\u00a0looking</li>\n<li>m: Musical (it makes a noise when you hit\u00a0it)</li>\n<li>a: Aerodynamic</li>\n<li>s: Shiny</li>\n</ul>\n<blockquote>Not very scientific, is\u00a0it?!</blockquote>\n<blockquote>Then, each part is sent through a series of workflows that will ultimately accept or reject the part. Each workflow has a name and contains a list of rules; each rule specifies a condition and where to send the part if the condition is true. The first rule that matches the part being considered is applied immediately, and the part moves on to the destination described by the rule. (The last rule in each workflow has no condition and always applies if reached.)</blockquote>\n<p>So, seems like each workflow has a series of qualification checks and as soon as a condition is met, we send the part to subsequent workflow.</p>\n<p>We are given an example workflow: ex{x&gt;10:one,m&lt;20:two,a&gt;30:R,A} which is named ex and has 4\u00a0rules:</p>\n<ul>\n<li>Rule \u201cx&gt;10:one\": If the part's x is more than 10, send the part to the workflow named\u00a0one.</li>\n<li>Rule \u201cm&lt;20:two\": Otherwise, if the part's m is less than 20, send the part to the workflow named\u00a0two.</li>\n<li>Rule \u201ca&gt;30:R\": Otherwise, if the part's a is more than 30, the part is immediately rejected\u00a0(R).</li>\n<li>Rule \u201cA\": Otherwise, because no other rules matched the part, the part is immediately accepted\u00a0(A).</li>\n</ul>\n<blockquote>If a part is sent to another workflow, it immediately switches to the start of that workflow instead and never returns. If a part is accepted (sent to A) or rejected (sent to R), the part immediately stops any further processing.</blockquote>\n<p>Got it! So, we can clearly see that each <strong>part</strong> seems to be an <strong>object</strong> with 4 properties and then we have a <strong>rule engine </strong>which is navigating through a series of <strong>workflows</strong> to finally reach either: <strong>A Accepted </strong>or<strong> </strong><strong>R Rejected.</strong></p>\n<p>We then go on to calculate the <strong>sum of all rating numbers</strong> for all the <strong>accepted parts</strong> and that\u2019s our\u00a0answer!</p>\n<blockquote>\u2757\ufe0f All parts begin in the workflow named\u00a0in.</blockquote>\n<p>We are given a base case, that looks something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*rtukACmiEyk92cD1Sh14KQ.png\"><figcaption>Base case walkthrough</figcaption></figure><p>So, let\u2019s write some code for our base test\u00a0case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/717/1*oXOjyikvG6FcHZHAb4ZBkQ.png\"><figcaption>Skelton code to get\u00a0started</figcaption></figure><p>So, as per the visualization above, I am structuring my code to first process workflows and parts and then using the accepted_parts_list\u00a0, calculate the sum\u00a0.</p>\n<p>Let\u2019s play around with our input_str to parse our workflows and part_list in a quick\u00a0REPL:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zlnwDdt7uNqrPWVv3YtNAA.png\"></figure><p>I think we can encapsulate part data nicely by creating a class MachinePart like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/675/1*xtv6-LtP3ue2acH9MK42GA.png\"><figcaption>Might be overkill, but what\u00a0YOLO</figcaption></figure><p>And our parse_input() looks something like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/867/1*itPSPmNlXBlM_vJNSjrJkg.png\"></figure><p>Our workflows are still stored as a list of string rules, as I will be dealing with them during our process() flow, let\u2019s do that! As always, we will start from a spagheti code to just build the logic and then refactor for brownee\u00a0points:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yqwoIdT4NeytTzAO3L6Qkw.png\"><figcaption>Debugging is\u00a0fun!</figcaption></figure><p>And our sum function can be as simple\u00a0as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/643/1*gP7EjAquB36lWhzuNKiCFg.png\"></figure><p>Everthing looks good! Let\u2019s run\u00a0it?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty.py\"<br>\u2705 sum_of_rating_of_accepted_parts() tests passed<br>\ud83c\udf89 All tests passed<br><br>[Done] exited with code=0 in 0.248 seconds</pre>\n<p>I think we can do away with the ENUM, just makes the code little bloated, I will move the state into our MachinePart class and simplify some of the nesting as\u00a0well:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/746/1*OuUARm0mFj5J5uW5hvwLiw.png\"><figcaption>MachinePart</figcaption></figure><p>And hence, our process() gets broken into 2 classes, where we can take out common condition logic into evaluate_condition()\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/870/1*hPn1RfSlCsWCtItWo25Bpg.png\"><figcaption>process -&gt; evaluate_condition for each valid condition!</figcaption></figure><blockquote>I still see <strong>a lot of nesting</strong> we can simplify and we can <strong>save an iteration</strong> we are doing in sum_of_rating_of_accepted_parts, by directly doing that in process() but will leave that for part\u00a02!</blockquote>\n<p>Let\u2019s load up our puzzle input and run this\u00a0one?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/607/1*xCt5ONdgUvxxJZW76DqKzg.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty.py\"<br>\u2757\ufe0f Sum of ratings of accepted parts: XXXXXX<br><br>[Done] exited with code=0 in 0.207 seconds</pre>\n<p>And we have an answer in just<strong> </strong><strong>0.207 seconds\u00a0</strong>! Pretty good, considering we had <strong>593 workflows</strong> and <strong>200 parts</strong> in our puzzle\u00a0input.</p>\n<p>Let\u2019s see if this is the correct answer? And yes it is!\u00a0\ud83d\ude4c</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qtFO_nNmiEbi4A9x5kHiBQ.png\"><figcaption>\u2b50\ufe0f</figcaption></figure><p>Here\u2019s our code till\u00a0now:</p>\n<pre># Day 19 - Aplenty<br><br>class MachinePart:<br>    ACCEPTED = \"A\"<br>    REJECTED = \"R\"<br><br>    VALID_STATES = [ACCEPTED, REJECTED]<br><br>    def __init__(self, x: int, m: int, a: int, s: int):<br>        self.ratings = {\"x\": x, \"m\": m, \"a\": a, \"s\": s}<br>        self.state = None<br><br>    def set_state(self, state: str) -&gt; None:<br>        if state in [self.ACCEPTED, self.REJECTED]:<br>            self.state = state<br>        else:<br>            raise ValueError(f\"Invalid state: {state}\")<br><br>    def is_unprocessed(self) -&gt; bool:<br>        return self.state is None<br><br>    def __str__(self) -&gt; str:<br>        ratings_str = \",\".join(<br>            [f\"{key}={value}\" for key, value in self.ratings.items()]<br>        )<br>        return ratings_str<br><br><br>def evaluate_condition(part, condition):<br>    if \"&lt;\" in condition:<br>        variable, value = condition.split(\"&lt;\")<br>        return part.ratings[variable] &lt; int(value)<br>    elif \"&gt;\" in condition:<br>        variable, value = condition.split(\"&gt;\")<br>        return part.ratings[variable] &gt; int(value)<br>    else:<br>        raise ValueError(f\"Invalid condition: {condition}\")<br><br><br>def process(workflows: dict, parts_list: list) -&gt; list:<br>    INITIAL_WORKFLOW_ID = \"in\"<br>    CONDITION_SEPARATOR = \":\"<br><br>    for i, part in enumerate(parts_list):<br>        # print(f\"{i+1}/{len(parts_list)}\\n Processing part {part}\\n\\n\")<br>        worflow_id = INITIAL_WORKFLOW_ID<br>        while part.is_unprocessed():<br>            for rule in workflows[worflow_id]:<br>                if CONDITION_SEPARATOR in rule:<br>                    condition, worflow_id = rule.split(CONDITION_SEPARATOR)<br>                    if evaluate_condition(part, condition):<br>                        if worflow_id in MachinePart.VALID_STATES:<br>                            part.set_state(worflow_id)<br>                        break # Break out of for loop and move to new workflow<br>                elif rule in MachinePart.VALID_STATES:<br>                    part.set_state(rule)<br>                else:<br>                    worflow_id = rule<br>    return parts_list<br><br><br>def sum_of_rating_of_accepted_parts(parts_list: list) -&gt; int:<br>    sum = 0<br>    for part in parts_list:<br>        if part.state == MachinePart.ACCEPTED:<br>            sum += (<br>                part.ratings[\"x\"]<br>                + part.ratings[\"m\"]<br>                + part.ratings[\"a\"]<br>                + part.ratings[\"s\"]<br>            )<br>    return sum<br><br><br>def parse_input(input_str: str) -&gt; tuple:<br>    workflow_str, parts_str = input_str.split(\"\\n\\n\")<br>    workflows = {}<br>    for workflow in workflow_str.split(\"\\n\"):<br>        workflow_name, workflow_rules = workflow.split(\"{\")  # Split on first '{'<br>        workflow_rules = workflow_rules[:-1]  # Remove trailing '}'<br>        workflows[workflow_name] = workflow_rules.split(\",\")<br><br>    parts_list = []<br>    for part in parts_str.split(\"\\n\"):<br>        x, m, a, s = part[1:-1].split(\",\")<br>        x = int(x.split(\"=\")[1])<br>        m = int(m.split(\"=\")[1])<br>        a = int(a.split(\"=\")[1])<br>        s = int(s.split(\"=\")[1])<br>        parts_list.append(MachinePart(x, m, a, s))<br><br>    return workflows, parts_list<br><br>def part_one():<br>    with open(\"day_19/input.txt\") as f:<br>        input_str = f.read()<br>    workflows, parts_list = parse_input(input_str)<br>    parts_list = process(workflows, parts_list)<br>    sum = sum_of_rating_of_accepted_parts(parts_list)<br>    print(f\"\u2757\ufe0f Sum of ratings of accepted parts: {sum}\")<br><br>def test_sum_of_rating_of_accepted_parts():<br>    input_str = \"\"\"px{a&lt;2006:qkq,m&gt;2090:A,rfg}<br>pv{a&gt;1716:R,A}<br>lnx{m&gt;1548:A,A}<br>rfg{s&lt;537:gd,x&gt;2440:R,A}<br>qs{s&gt;3448:A,lnx}<br>qkq{x&lt;1416:A,crn}<br>crn{x&gt;2662:A,R}<br>in{s&lt;1351:px,qqz}<br>qqz{s&gt;2770:qs,m&lt;1801:hdj,R}<br>gd{a&gt;3333:R,R}<br>hdj{m&gt;838:A,pv}<br><br>{x=787,m=2655,a=1222,s=2876}<br>{x=1679,m=44,a=2067,s=496}<br>{x=2036,m=264,a=79,s=2244}<br>{x=2461,m=1339,a=466,s=291}<br>{x=2127,m=1623,a=2188,s=1013}\"\"\"<br><br>    workflows, parts_list = parse_input(input_str)<br>    parts_list = process(workflows, parts_list)<br>    sum = sum_of_rating_of_accepted_parts(parts_list)<br>    assert sum == 19114, f\"Expected 19114, got {sum}\"<br>    print(\"\u2705 sum_of_rating_of_accepted_parts() tests passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_sum_of_rating_of_accepted_parts()<br>    print(\"\ud83c\udf89 All tests passed\")<br><br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>Even with your help, the sorting process still isn\u2019t fast\u00a0enough.</blockquote>\n<blockquote>One of the Elves comes up with a new plan: rather than sort parts individually through all of these workflows, maybe you can figure out in advance which combinations of ratings will be accepted or rejected.</blockquote>\n<blockquote>Each of the four ratings (x, m, a, s) can have an integer value ranging from a minimum of 1 to a maximum of 4000. Of all possible distinct combinations of ratings, your job is to figure out which ones will be accepted.</blockquote>\n<blockquote>In the above example, there are 167409079868000 distinct combinations of ratings that will be accepted.</blockquote>\n<blockquote>Consider only your list of workflows; the list of part ratings that the Elves wanted you to sort is no longer relevant. How many distinct combinations of ratings will be accepted by the Elves\u2019 workflows?</blockquote>\n<blockquote>Even with your help, the sorting process still <strong>isn\u2019t fast\u00a0enough</strong>.</blockquote>\n<p>Well, excuse\u00a0me?!</p>\n<p>So, one of the Elves comes up with a new plan: <strong>rather than sort parts individually</strong> through all of these workflows, maybe we can figure out in advance <strong>which combinations of ratings</strong> will be <strong>accepted</strong> or <strong>rejected</strong>. \ud83e\udd14</p>\n<p>Interesting! We are given\u00a0that:</p>\n<ul>\n<li>Each of the four ratings (x, m, a, s) can have an integer value ranging from a minimum of 1 to a maximum of\u00a04000.</li>\n<li>Of all possible distinct combinations of ratings, your job is to figure out which ones will be accepted.</li>\n</ul>\n<p>Well, now we can ignore parts in our puzzle input and we have to share that <strong>how many distinct combinations of ratings will be accepted by the Elves\u2019 workflows?</strong></p>\n<p>\ud83d\udcad Now, looking at the question, it may seem pretty easy as we are scoping our rating values between 1 to 4000, but let me blow up your\u00a0brain:</p>\n<blockquote>For each of the four ratings (X, M, A, S), which can each take on values from 1 to 4000, there are a total of 256 trillion (256,000,000,000,000) possible combinations! \ud83e\udd2f</blockquote>\n<p><strong>\u2757\ufe0f So, brute force approach is out of question\u00a0here!</strong></p>\n<p>Now, we need to basically find the upper bound and lower bound of values for each X, M, A, S that will lead us to A\u200a\u2014\u200aAccepted state for our\u00a0rules!</p>\n<p>So, let\u2019s visualize our base test case workflow rules? We can basically simplify\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/778/1*FsSQLaFfKQzScrjKVhv83Q.png\"></figure><p>into this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wlxavObXLncEEhyEOVyhMw.png\"></figure><p>where, starting from in we have all these conditional paths to reach A or R\u00a0. Let\u2019s take the <strong>top left </strong><strong>A in above visualization</strong>, now to reach there, we need to have a Part with value for each rating between the following inclusive ranges:</p>\n<p><strong>x: (1, 4000), m: (1, 2090), a: (2006, 4000), s: (1,\u00a01350)</strong></p>\n<p>so that we can go from in[0] --&gt; px[0] --&gt; px[1] --&gt;\u00a0A</p>\n<p>Now similarly, to reach the <strong>mid top </strong><strong>A in above visualiation, </strong>the following ranges will fulfill the criteria:</p>\n<p><strong>x: (1, 1415), m: (1, 4000), a: (1, 2005), s: (1,\u00a01350)</strong></p>\n<blockquote>\u2b06\ufe0f This is important, if you didn\u2019t understand how we reached these values, please read\u00a0again!</blockquote>\n<p>Once we can calculate these ranges for each entry of A in our rules, we just need to do a sum of all possible combinations per range criteria!</p>\n<p>First things first, let\u2019s create a new function find_acceptable_range() which will iterate through our workflow and its\u2019 rules to find a list of ranges as we disucssed above:</p>\n<blockquote>I can\u2019t help but think that this is a backtracking problem, where we will iterate through the <strong>workflows</strong> dict of rules and will push each path to a stack and then we encounter <strong>A </strong>we save that state of ranges and if we encounter <strong>R </strong>we just ignore that and backtrack else we keep\u00a0going!</blockquote>\n<p>This is just a hunch, but let\u2019s explore\u00a0that!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6_aJxlS5W4Rg94ai2du2iw.png\"><figcaption>Ah! Let\u2019s see how to fix\u00a0this!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/672/1*Dt6j4KnrM6rh0SRfjjQAew.png\"><figcaption>Ok!</figcaption></figure><p>So, we are able to get all the valid ranges that will get us to A\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/845/1*F2Lo3lKo3W5xnVjPsvogsg.png\"></figure><p>But the problem is, they all don\u2019t seem distinct and our test case only has 9 A nodes but our range_list has 14 combinations! \ud83e\udd14</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*apY1M5d_EpBoxcRaZ6xiLQ.png\"><figcaption>It seems like we have a lot of overlapping ranges!</figcaption></figure><p>.</p>\n<p>.</p>\n<blockquote>back to drawing\u00a0board</blockquote>\n<p>.</p>\n<p>.</p>\n<p>After couple of hours of debugging! I was able to simplify our code a\u00a0lot!</p>\n<p><strong><em>\ud83d\udcad The key caveat was that everytime we evaluate a condition </em></strong><strong><em>&lt; </em></strong><strong><em>&gt; for a </em></strong><strong><em>range, for\u00a0example:</em></strong></p>\n<p><strong>range = {\"x\": (1, 4000), \"m\": (1, 4000), \"a\": (1, 4000), \"s\": (1,\u00a04000)}</strong></p>\n<p>and given condition is a&lt;2006\u00a0, our range will split into 2\u00a0parts:</p>\n<p><strong>true_range = {.........., \"a\": (1, 2005),.......}</strong></p>\n<p><strong>false_range = {.........., \"a\": (2006, 4000),.......}</strong></p>\n<p>wheretrue_range will go on to evaluate the next_workflow_id and the false_range will move on to the next rule in\u00a0list!</p>\n<p>Here\u2019s what we had to change in\u00a0code:</p>\n<p>Introduced a new class MachinePartRanges to store range for each rating! I also had to implement a copy() function for deep copy of our object while spliting into true_range and false_range</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/661/1*QYtDV5jDm2rYwXHzYKEZRg.png\"></figure><p>Here\u2019s our modified evaluate_condition method:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Zi_akXHU4uNa35euIlNAuA.png\"></figure><p>And here\u2019s our <em>creme la de creme</em> methodnum_of_combinations_possible that calculate the distinct combinations of ratings will be accepted by the workflows!</p>\n<blockquote>\u201cThis function \ud83d\udc47<strong> broke my\u00a0brain!</strong>\n</blockquote>\n<blockquote>I spent over 2 hours debugging this as it started with a full on spagetti code with a lot of nesting! Only when I was able to clean it with early returns in my code was when I was able to make some progress!\u201d</blockquote>\n<blockquote><strong><em>Moral of story: Always write clean code so you can debug it\u00a0later!</em></strong></blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OroyF6H1W7uDVmns6SP9fw.png\"><figcaption>We use the same DFS with Backtracking approach to find all accepted_ranges</figcaption></figure><p>Let\u2019s test our code for the base test\u00a0case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/805/1*fnxjlpg_a5I7xWMdT9EVYQ.png\"><figcaption>We are still using the same input_str as part_one, but we will discard parts info while parse_input()</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty_2.py\"<br>\u2705 sum_of_rating_of_accepted_parts() tests passed<br><br>[Done] exited with code=0 in 0.317 seconds</pre>\n<p>Perfect! Let\u2019s load up our puzzle input and check if we can get the\u00a0answer?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/629/1*DyA0J7_RLH5KBIN0G7rpWw.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty_2.py\"<br>\u2757\ufe0f\u2757\ufe0f Number of combinations possible: XXXXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.345 seconds</pre>\n<p>Let\u2019s see if this is the correct answer?\u00a0\ud83e\udd1e</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8e4LpyIEOcXkq2uAMu5gMA.png\"><figcaption>\ud83c\udf1f</figcaption></figure><p>Here\u2019s our code for Part 2, I am very proud of this code!\u00a0\ud83e\udd72</p>\n<pre># Day 19 - Aplenty<br># Part Two<br><br>class MachinePartRanges:<br>    ACCEPTED = \"A\"<br>    REJECTED = \"R\"<br><br>    def __init__(self):<br>        self.rating_ranges = {<br>            \"x\": (1, 4000),<br>            \"m\": (1, 4000),<br>            \"a\": (1, 4000),<br>            \"s\": (1, 4000),<br>        }<br>        self.state = None<br><br>    def __repr__(self) -&gt; str:<br>        return str(self.rating_ranges)<br><br>    def copy(self):<br>        # deep copy<br>        new_mpr = MachinePartRanges()<br>        new_mpr.rating_ranges = self.rating_ranges.copy()<br>        return new_mpr<br><br><br>def evaluate_condition(ranges: MachinePartRanges, condition: str) -&gt; (MachinePartRanges, MachinePartRanges):<br>    true_range, false_range = ranges.copy(), ranges.copy()<br><br>    variable, value = condition.split(\"&lt;\" if \"&lt;\" in condition else \"&gt;\")<br><br>    if \"&lt;\" in condition:<br>        true_range.rating_ranges[variable] = (true_range.rating_ranges[variable][0], int(value) - 1)<br>        false_range.rating_ranges[variable] = (int(value), false_range.rating_ranges[variable][1])<br>    elif \"&gt;\" in condition:<br>        true_range.rating_ranges[variable] = (int(value) + 1, true_range.rating_ranges[variable][1])<br>        false_range.rating_ranges[variable] = (false_range.rating_ranges[variable][0], int(value))<br><br>    return true_range, false_range<br><br><br>def num_of_combinations_possible(workflows) -&gt; int:<br>    INITIAL_WORKFLOW_ID = \"in\"<br>    accepted_ranges_list = []<br><br>    stack = [(MachinePartRanges(), INITIAL_WORKFLOW_ID)]<br><br>    while stack:<br>        ranges, workflow_id = stack.pop()<br><br>        if workflow_id == MachinePartRanges.ACCEPTED: <br>            accepted_ranges_list.append(ranges)<br>            continue<br><br>        if workflow_id == MachinePartRanges.REJECTED:<br>            continue<br><br>        for rule in workflows[workflow_id]:<br>            if rule == MachinePartRanges.ACCEPTED:<br>                accepted_ranges_list.append(ranges)<br>                break<br><br>            if rule == MachinePartRanges.REJECTED:<br>                break<br><br>            if \":\" not in rule:<br>                workflow_id = rule<br>                stack.append((ranges, workflow_id))<br>                continue<br><br>            # rule must be a condition<br>            condition, new_worflow_id = rule.split(\":\")<br>            true_range, false_range = evaluate_condition(ranges, condition) <br>            stack.append((true_range, new_worflow_id)) # Add true range to stack to explore new_workflow_id<br>            ranges = false_range # Update ranges for next iteration in rules loop<br><br>    # now we have a list of accepted ranges, we can calculate the number of combinations possible<br>    num_of_combinations = 0<br>    for ranges in accepted_ranges_list:<br>        num_of_combinations += (<br>            (ranges.rating_ranges[\"x\"][1] - ranges.rating_ranges[\"x\"][0] + 1)<br>            * (ranges.rating_ranges[\"m\"][1] - ranges.rating_ranges[\"m\"][0] + 1)<br>            * (ranges.rating_ranges[\"a\"][1] - ranges.rating_ranges[\"a\"][0] + 1)<br>            * (ranges.rating_ranges[\"s\"][1] - ranges.rating_ranges[\"s\"][0] + 1)<br>        )<br><br>    return num_of_combinations<br><br><br>def parse_input(input_str: str) -&gt; tuple:<br>    workflow_str, _ = input_str.split(\"\\n\\n\")<br>    workflows = {}<br>    for workflow in workflow_str.split(\"\\n\"):<br>        workflow_name, workflow_rules = workflow.split(\"{\")  # Split on first '{'<br>        workflow_rules = workflow_rules[:-1]  # Remove trailing '}'<br>        workflows[workflow_name] = workflow_rules.split(\",\")<br><br>    return workflows<br><br>def part_two():<br>    with open(\"day_19/input.txt\") as f:<br>        input_str = f.read()<br>    workflows = parse_input(input_str)<br>    num = num_of_combinations_possible(workflows)<br>    print(f\"\u2757\ufe0f\u2757\ufe0f Number of combinations possible: {num}\")<br><br>def test_num_of_combinations_possible():<br>    input_str = \"\"\"px{a&lt;2006:qkq,m&gt;2090:A,rfg}<br>pv{a&gt;1716:R,A}<br>lnx{m&gt;1548:A,A}<br>rfg{s&lt;537:gd,x&gt;2440:R,A}<br>qs{s&gt;3448:A,lnx}<br>qkq{x&lt;1416:A,crn}<br>crn{x&gt;2662:A,R}<br>in{s&lt;1351:px,qqz}<br>qqz{s&gt;2770:qs,m&lt;1801:hdj,R}<br>gd{a&gt;3333:R,R}<br>hdj{m&gt;838:A,pv}<br><br>{x=787,m=2655,a=1222,s=2876}<br>{x=1679,m=44,a=2067,s=496}<br>{x=2036,m=264,a=79,s=2244}<br>{x=2461,m=1339,a=466,s=291}<br>{x=2127,m=1623,a=2188,s=1013}\"\"\"<br><br>    workflows = parse_input(input_str)<br>    num = num_of_combinations_possible(workflows)<br>    assert num == 167409079868000, f\"Expected 167409079868000, got {num}\"<br>    print(\"\u2705 sum_of_rating_of_accepted_parts() tests passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_num_of_combinations_possible()<br>    part_two()</pre>\n<p>I am keeping Part 1 and Part 2 seperate in our code base as both parts are actually pretty different in terms of processing, might come back to merge them later. Too tired for\u00a0now!</p>\n<p>Feel free to raise a\u00a0PR?!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=522ba14b1444\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*jciy1cL5lsSK0f7R\"><figcaption>Aplenty (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/19\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>The Elves of Gear Island are thankful for your help and send you on your way. They even have a hang glider that someone <a href=\"https://adventofcode.com/2023/day/9\">stole</a> from Desert Island; since you\u2019re already going that direction, it would help them a lot if you would use it to get down there and return it to\u00a0them.</blockquote>\n<blockquote>As you reach the bottom of the relentless avalanche of machine parts, you discover that they\u2019re already forming a formidable heap. Don\u2019t worry, though\u200a\u2014\u200aa group of Elves is already here organizing the parts, and they have a\u00a0system.</blockquote>\n<blockquote>To start, each part is rated in each of four categories:</blockquote>\n<blockquote>x: Extremely cool\u00a0looking</blockquote>\n<blockquote>m: Musical (it makes a noise when you hit\u00a0it)</blockquote>\n<blockquote>a: Aerodynamic</blockquote>\n<blockquote>s: Shiny</blockquote>\n<blockquote>Then, each part is sent through a series of workflows that will ultimately accept or reject the part. Each workflow has a name and contains a list of rules; each rule specifies a condition and where to send the part if the condition is true. The first rule that matches the part being considered is applied immediately, and the part moves on to the destination described by the rule. (The last rule in each workflow has no condition and always applies if reached.)</blockquote>\n<blockquote>Consider the workflow ex{x&gt;10:one,m&lt;20:two,a&gt;30:R,A}. This workflow is named ex and contains four rules. If workflow ex were considering a specific part, it would perform the following steps in\u00a0order:</blockquote>\n<blockquote>Rule \u201cx&gt;10:one\": If the part's x is more than 10, send the part to the workflow named\u00a0one.</blockquote>\n<blockquote>Rule \u201cm&lt;20:two\": Otherwise, if the part's m is less than 20, send the part to the workflow named\u00a0two.</blockquote>\n<blockquote>Rule \u201ca&gt;30:R\": Otherwise, if the part's a is more than 30, the part is immediately rejected\u00a0(R).</blockquote>\n<blockquote>Rule \u201cA\": Otherwise, because no other rules matched the part, the part is immediately accepted\u00a0(A).</blockquote>\n<blockquote>If a part is sent to another workflow, it immediately switches to the start of that workflow instead and never returns. If a part is accepted (sent to A) or rejected (sent to R), the part immediately stops any further processing.</blockquote>\n<blockquote>The system works, but it\u2019s not keeping up with the torrent of weird metal shapes. The Elves ask if you can help sort a few parts and give you the list of workflows and some part ratings (your puzzle input). For\u00a0example:</blockquote>\n<blockquote>px{a&lt;2006:qkq,m&gt;2090:A,rfg}<br>pv{a&gt;1716:R,A}<br>lnx{m&gt;1548:A,A}<br>rfg{s&lt;537:gd,x&gt;2440:R,A}<br>qs{s&gt;3448:A,lnx}<br>qkq{x&lt;1416:A,crn}<br>crn{x&gt;2662:A,R}<br>in{s&lt;1351:px,qqz}<br>qqz{s&gt;2770:qs,m&lt;1801:hdj,R}<br>gd{a&gt;3333:R,R}<br>hdj{m&gt;838:A,pv}</blockquote>\n<blockquote>{x=787,m=2655,a=1222,s=2876}<br>{x=1679,m=44,a=2067,s=496}<br>{x=2036,m=264,a=79,s=2244}<br>{x=2461,m=1339,a=466,s=291}<br>{x=2127,m=1623,a=2188,s=1013}</blockquote>\n<blockquote>The workflows are listed first, followed by a blank line, then the ratings of the parts the Elves would like you to sort. All parts begin in the workflow named in. In this example, the five listed parts go through the following workflows:</blockquote>\n<blockquote>{x=787,m=2655,a=1222,s=2876}: in -&gt; qqz -&gt; qs -&gt; lnx -&gt;\u00a0A</blockquote>\n<blockquote>{x=1679,m=44,a=2067,s=496}: in -&gt; px -&gt; rfg -&gt; gd -&gt;\u00a0R</blockquote>\n<blockquote>{x=2036,m=264,a=79,s=2244}: in -&gt; qqz -&gt; hdj -&gt; pv -&gt;\u00a0A</blockquote>\n<blockquote>{x=2461,m=1339,a=466,s=291}: in -&gt; px -&gt; qkq -&gt; crn -&gt;\u00a0R</blockquote>\n<blockquote>{x=2127,m=1623,a=2188,s=1013}: in -&gt; px -&gt; rfg -&gt;\u00a0A</blockquote>\n<blockquote>Ultimately, three parts are accepted. Adding up the x, m, a, and s rating for each of the accepted parts gives 7540 for the part with x=787, 4623 for the part with x=2036, and 6951 for the part with x=2127. Adding all of the ratings for all of the accepted parts gives the sum total of\u00a019114.</blockquote>\n<blockquote>Sort through all of the parts you\u2019ve been given; what do you get if you add together all of the rating numbers for all of the parts that ultimately get accepted?</blockquote>\n<blockquote>They even have a hang glider that someone <a href=\"https://adventofcode.com/2023/day/9\">stole</a> from Desert\u00a0Island.</blockquote>\n<p>Ah, well!\u00a0\ud83d\udc40</p>\n<p>So, seems like now we have a <em>relentless avalanche of machine parts</em> that has formed a giant heap. But some elves are trying to organize them based of a system that rates each part in following 4 categories:</p>\n<ul>\n<li>x: Extremely cool\u00a0looking</li>\n<li>m: Musical (it makes a noise when you hit\u00a0it)</li>\n<li>a: Aerodynamic</li>\n<li>s: Shiny</li>\n</ul>\n<blockquote>Not very scientific, is\u00a0it?!</blockquote>\n<blockquote>Then, each part is sent through a series of workflows that will ultimately accept or reject the part. Each workflow has a name and contains a list of rules; each rule specifies a condition and where to send the part if the condition is true. The first rule that matches the part being considered is applied immediately, and the part moves on to the destination described by the rule. (The last rule in each workflow has no condition and always applies if reached.)</blockquote>\n<p>So, seems like each workflow has a series of qualification checks and as soon as a condition is met, we send the part to subsequent workflow.</p>\n<p>We are given an example workflow: ex{x&gt;10:one,m&lt;20:two,a&gt;30:R,A} which is named ex and has 4\u00a0rules:</p>\n<ul>\n<li>Rule \u201cx&gt;10:one\": If the part's x is more than 10, send the part to the workflow named\u00a0one.</li>\n<li>Rule \u201cm&lt;20:two\": Otherwise, if the part's m is less than 20, send the part to the workflow named\u00a0two.</li>\n<li>Rule \u201ca&gt;30:R\": Otherwise, if the part's a is more than 30, the part is immediately rejected\u00a0(R).</li>\n<li>Rule \u201cA\": Otherwise, because no other rules matched the part, the part is immediately accepted\u00a0(A).</li>\n</ul>\n<blockquote>If a part is sent to another workflow, it immediately switches to the start of that workflow instead and never returns. If a part is accepted (sent to A) or rejected (sent to R), the part immediately stops any further processing.</blockquote>\n<p>Got it! So, we can clearly see that each <strong>part</strong> seems to be an <strong>object</strong> with 4 properties and then we have a <strong>rule engine </strong>which is navigating through a series of <strong>workflows</strong> to finally reach either: <strong>A Accepted </strong>or<strong> </strong><strong>R Rejected.</strong></p>\n<p>We then go on to calculate the <strong>sum of all rating numbers</strong> for all the <strong>accepted parts</strong> and that\u2019s our\u00a0answer!</p>\n<blockquote>\u2757\ufe0f All parts begin in the workflow named\u00a0in.</blockquote>\n<p>We are given a base case, that looks something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*rtukACmiEyk92cD1Sh14KQ.png\"><figcaption>Base case walkthrough</figcaption></figure><p>So, let\u2019s write some code for our base test\u00a0case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/717/1*oXOjyikvG6FcHZHAb4ZBkQ.png\"><figcaption>Skelton code to get\u00a0started</figcaption></figure><p>So, as per the visualization above, I am structuring my code to first process workflows and parts and then using the accepted_parts_list\u00a0, calculate the sum\u00a0.</p>\n<p>Let\u2019s play around with our input_str to parse our workflows and part_list in a quick\u00a0REPL:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zlnwDdt7uNqrPWVv3YtNAA.png\"></figure><p>I think we can encapsulate part data nicely by creating a class MachinePart like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/675/1*xtv6-LtP3ue2acH9MK42GA.png\"><figcaption>Might be overkill, but what\u00a0YOLO</figcaption></figure><p>And our parse_input() looks something like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/867/1*itPSPmNlXBlM_vJNSjrJkg.png\"></figure><p>Our workflows are still stored as a list of string rules, as I will be dealing with them during our process() flow, let\u2019s do that! As always, we will start from a spagheti code to just build the logic and then refactor for brownee\u00a0points:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yqwoIdT4NeytTzAO3L6Qkw.png\"><figcaption>Debugging is\u00a0fun!</figcaption></figure><p>And our sum function can be as simple\u00a0as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/643/1*gP7EjAquB36lWhzuNKiCFg.png\"></figure><p>Everthing looks good! Let\u2019s run\u00a0it?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty.py\"<br>\u2705 sum_of_rating_of_accepted_parts() tests passed<br>\ud83c\udf89 All tests passed<br><br>[Done] exited with code=0 in 0.248 seconds</pre>\n<p>I think we can do away with the ENUM, just makes the code little bloated, I will move the state into our MachinePart class and simplify some of the nesting as\u00a0well:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/746/1*OuUARm0mFj5J5uW5hvwLiw.png\"><figcaption>MachinePart</figcaption></figure><p>And hence, our process() gets broken into 2 classes, where we can take out common condition logic into evaluate_condition()\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/870/1*hPn1RfSlCsWCtItWo25Bpg.png\"><figcaption>process -&gt; evaluate_condition for each valid condition!</figcaption></figure><blockquote>I still see <strong>a lot of nesting</strong> we can simplify and we can <strong>save an iteration</strong> we are doing in sum_of_rating_of_accepted_parts, by directly doing that in process() but will leave that for part\u00a02!</blockquote>\n<p>Let\u2019s load up our puzzle input and run this\u00a0one?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/607/1*xCt5ONdgUvxxJZW76DqKzg.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty.py\"<br>\u2757\ufe0f Sum of ratings of accepted parts: XXXXXX<br><br>[Done] exited with code=0 in 0.207 seconds</pre>\n<p>And we have an answer in just<strong> </strong><strong>0.207 seconds\u00a0</strong>! Pretty good, considering we had <strong>593 workflows</strong> and <strong>200 parts</strong> in our puzzle\u00a0input.</p>\n<p>Let\u2019s see if this is the correct answer? And yes it is!\u00a0\ud83d\ude4c</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qtFO_nNmiEbi4A9x5kHiBQ.png\"><figcaption>\u2b50\ufe0f</figcaption></figure><p>Here\u2019s our code till\u00a0now:</p>\n<pre># Day 19 - Aplenty<br><br>class MachinePart:<br>    ACCEPTED = \"A\"<br>    REJECTED = \"R\"<br><br>    VALID_STATES = [ACCEPTED, REJECTED]<br><br>    def __init__(self, x: int, m: int, a: int, s: int):<br>        self.ratings = {\"x\": x, \"m\": m, \"a\": a, \"s\": s}<br>        self.state = None<br><br>    def set_state(self, state: str) -&gt; None:<br>        if state in [self.ACCEPTED, self.REJECTED]:<br>            self.state = state<br>        else:<br>            raise ValueError(f\"Invalid state: {state}\")<br><br>    def is_unprocessed(self) -&gt; bool:<br>        return self.state is None<br><br>    def __str__(self) -&gt; str:<br>        ratings_str = \",\".join(<br>            [f\"{key}={value}\" for key, value in self.ratings.items()]<br>        )<br>        return ratings_str<br><br><br>def evaluate_condition(part, condition):<br>    if \"&lt;\" in condition:<br>        variable, value = condition.split(\"&lt;\")<br>        return part.ratings[variable] &lt; int(value)<br>    elif \"&gt;\" in condition:<br>        variable, value = condition.split(\"&gt;\")<br>        return part.ratings[variable] &gt; int(value)<br>    else:<br>        raise ValueError(f\"Invalid condition: {condition}\")<br><br><br>def process(workflows: dict, parts_list: list) -&gt; list:<br>    INITIAL_WORKFLOW_ID = \"in\"<br>    CONDITION_SEPARATOR = \":\"<br><br>    for i, part in enumerate(parts_list):<br>        # print(f\"{i+1}/{len(parts_list)}\\n Processing part {part}\\n\\n\")<br>        worflow_id = INITIAL_WORKFLOW_ID<br>        while part.is_unprocessed():<br>            for rule in workflows[worflow_id]:<br>                if CONDITION_SEPARATOR in rule:<br>                    condition, worflow_id = rule.split(CONDITION_SEPARATOR)<br>                    if evaluate_condition(part, condition):<br>                        if worflow_id in MachinePart.VALID_STATES:<br>                            part.set_state(worflow_id)<br>                        break # Break out of for loop and move to new workflow<br>                elif rule in MachinePart.VALID_STATES:<br>                    part.set_state(rule)<br>                else:<br>                    worflow_id = rule<br>    return parts_list<br><br><br>def sum_of_rating_of_accepted_parts(parts_list: list) -&gt; int:<br>    sum = 0<br>    for part in parts_list:<br>        if part.state == MachinePart.ACCEPTED:<br>            sum += (<br>                part.ratings[\"x\"]<br>                + part.ratings[\"m\"]<br>                + part.ratings[\"a\"]<br>                + part.ratings[\"s\"]<br>            )<br>    return sum<br><br><br>def parse_input(input_str: str) -&gt; tuple:<br>    workflow_str, parts_str = input_str.split(\"\\n\\n\")<br>    workflows = {}<br>    for workflow in workflow_str.split(\"\\n\"):<br>        workflow_name, workflow_rules = workflow.split(\"{\")  # Split on first '{'<br>        workflow_rules = workflow_rules[:-1]  # Remove trailing '}'<br>        workflows[workflow_name] = workflow_rules.split(\",\")<br><br>    parts_list = []<br>    for part in parts_str.split(\"\\n\"):<br>        x, m, a, s = part[1:-1].split(\",\")<br>        x = int(x.split(\"=\")[1])<br>        m = int(m.split(\"=\")[1])<br>        a = int(a.split(\"=\")[1])<br>        s = int(s.split(\"=\")[1])<br>        parts_list.append(MachinePart(x, m, a, s))<br><br>    return workflows, parts_list<br><br>def part_one():<br>    with open(\"day_19/input.txt\") as f:<br>        input_str = f.read()<br>    workflows, parts_list = parse_input(input_str)<br>    parts_list = process(workflows, parts_list)<br>    sum = sum_of_rating_of_accepted_parts(parts_list)<br>    print(f\"\u2757\ufe0f Sum of ratings of accepted parts: {sum}\")<br><br>def test_sum_of_rating_of_accepted_parts():<br>    input_str = \"\"\"px{a&lt;2006:qkq,m&gt;2090:A,rfg}<br>pv{a&gt;1716:R,A}<br>lnx{m&gt;1548:A,A}<br>rfg{s&lt;537:gd,x&gt;2440:R,A}<br>qs{s&gt;3448:A,lnx}<br>qkq{x&lt;1416:A,crn}<br>crn{x&gt;2662:A,R}<br>in{s&lt;1351:px,qqz}<br>qqz{s&gt;2770:qs,m&lt;1801:hdj,R}<br>gd{a&gt;3333:R,R}<br>hdj{m&gt;838:A,pv}<br><br>{x=787,m=2655,a=1222,s=2876}<br>{x=1679,m=44,a=2067,s=496}<br>{x=2036,m=264,a=79,s=2244}<br>{x=2461,m=1339,a=466,s=291}<br>{x=2127,m=1623,a=2188,s=1013}\"\"\"<br><br>    workflows, parts_list = parse_input(input_str)<br>    parts_list = process(workflows, parts_list)<br>    sum = sum_of_rating_of_accepted_parts(parts_list)<br>    assert sum == 19114, f\"Expected 19114, got {sum}\"<br>    print(\"\u2705 sum_of_rating_of_accepted_parts() tests passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_sum_of_rating_of_accepted_parts()<br>    print(\"\ud83c\udf89 All tests passed\")<br><br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>Even with your help, the sorting process still isn\u2019t fast\u00a0enough.</blockquote>\n<blockquote>One of the Elves comes up with a new plan: rather than sort parts individually through all of these workflows, maybe you can figure out in advance which combinations of ratings will be accepted or rejected.</blockquote>\n<blockquote>Each of the four ratings (x, m, a, s) can have an integer value ranging from a minimum of 1 to a maximum of 4000. Of all possible distinct combinations of ratings, your job is to figure out which ones will be accepted.</blockquote>\n<blockquote>In the above example, there are 167409079868000 distinct combinations of ratings that will be accepted.</blockquote>\n<blockquote>Consider only your list of workflows; the list of part ratings that the Elves wanted you to sort is no longer relevant. How many distinct combinations of ratings will be accepted by the Elves\u2019 workflows?</blockquote>\n<blockquote>Even with your help, the sorting process still <strong>isn\u2019t fast\u00a0enough</strong>.</blockquote>\n<p>Well, excuse\u00a0me?!</p>\n<p>So, one of the Elves comes up with a new plan: <strong>rather than sort parts individually</strong> through all of these workflows, maybe we can figure out in advance <strong>which combinations of ratings</strong> will be <strong>accepted</strong> or <strong>rejected</strong>. \ud83e\udd14</p>\n<p>Interesting! We are given\u00a0that:</p>\n<ul>\n<li>Each of the four ratings (x, m, a, s) can have an integer value ranging from a minimum of 1 to a maximum of\u00a04000.</li>\n<li>Of all possible distinct combinations of ratings, your job is to figure out which ones will be accepted.</li>\n</ul>\n<p>Well, now we can ignore parts in our puzzle input and we have to share that <strong>how many distinct combinations of ratings will be accepted by the Elves\u2019 workflows?</strong></p>\n<p>\ud83d\udcad Now, looking at the question, it may seem pretty easy as we are scoping our rating values between 1 to 4000, but let me blow up your\u00a0brain:</p>\n<blockquote>For each of the four ratings (X, M, A, S), which can each take on values from 1 to 4000, there are a total of 256 trillion (256,000,000,000,000) possible combinations! \ud83e\udd2f</blockquote>\n<p><strong>\u2757\ufe0f So, brute force approach is out of question\u00a0here!</strong></p>\n<p>Now, we need to basically find the upper bound and lower bound of values for each X, M, A, S that will lead us to A\u200a\u2014\u200aAccepted state for our\u00a0rules!</p>\n<p>So, let\u2019s visualize our base test case workflow rules? We can basically simplify\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/778/1*FsSQLaFfKQzScrjKVhv83Q.png\"></figure><p>into this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wlxavObXLncEEhyEOVyhMw.png\"></figure><p>where, starting from in we have all these conditional paths to reach A or R\u00a0. Let\u2019s take the <strong>top left </strong><strong>A in above visualization</strong>, now to reach there, we need to have a Part with value for each rating between the following inclusive ranges:</p>\n<p><strong>x: (1, 4000), m: (1, 2090), a: (2006, 4000), s: (1,\u00a01350)</strong></p>\n<p>so that we can go from in[0] --&gt; px[0] --&gt; px[1] --&gt;\u00a0A</p>\n<p>Now similarly, to reach the <strong>mid top </strong><strong>A in above visualiation, </strong>the following ranges will fulfill the criteria:</p>\n<p><strong>x: (1, 1415), m: (1, 4000), a: (1, 2005), s: (1,\u00a01350)</strong></p>\n<blockquote>\u2b06\ufe0f This is important, if you didn\u2019t understand how we reached these values, please read\u00a0again!</blockquote>\n<p>Once we can calculate these ranges for each entry of A in our rules, we just need to do a sum of all possible combinations per range criteria!</p>\n<p>First things first, let\u2019s create a new function find_acceptable_range() which will iterate through our workflow and its\u2019 rules to find a list of ranges as we disucssed above:</p>\n<blockquote>I can\u2019t help but think that this is a backtracking problem, where we will iterate through the <strong>workflows</strong> dict of rules and will push each path to a stack and then we encounter <strong>A </strong>we save that state of ranges and if we encounter <strong>R </strong>we just ignore that and backtrack else we keep\u00a0going!</blockquote>\n<p>This is just a hunch, but let\u2019s explore\u00a0that!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6_aJxlS5W4Rg94ai2du2iw.png\"><figcaption>Ah! Let\u2019s see how to fix\u00a0this!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/672/1*Dt6j4KnrM6rh0SRfjjQAew.png\"><figcaption>Ok!</figcaption></figure><p>So, we are able to get all the valid ranges that will get us to A\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/845/1*F2Lo3lKo3W5xnVjPsvogsg.png\"></figure><p>But the problem is, they all don\u2019t seem distinct and our test case only has 9 A nodes but our range_list has 14 combinations! \ud83e\udd14</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*apY1M5d_EpBoxcRaZ6xiLQ.png\"><figcaption>It seems like we have a lot of overlapping ranges!</figcaption></figure><p>.</p>\n<p>.</p>\n<blockquote>back to drawing\u00a0board</blockquote>\n<p>.</p>\n<p>.</p>\n<p>After couple of hours of debugging! I was able to simplify our code a\u00a0lot!</p>\n<p><strong><em>\ud83d\udcad The key caveat was that everytime we evaluate a condition </em></strong><strong><em>&lt; </em></strong><strong><em>&gt; for a </em></strong><strong><em>range, for\u00a0example:</em></strong></p>\n<p><strong>range = {\"x\": (1, 4000), \"m\": (1, 4000), \"a\": (1, 4000), \"s\": (1,\u00a04000)}</strong></p>\n<p>and given condition is a&lt;2006\u00a0, our range will split into 2\u00a0parts:</p>\n<p><strong>true_range = {.........., \"a\": (1, 2005),.......}</strong></p>\n<p><strong>false_range = {.........., \"a\": (2006, 4000),.......}</strong></p>\n<p>wheretrue_range will go on to evaluate the next_workflow_id and the false_range will move on to the next rule in\u00a0list!</p>\n<p>Here\u2019s what we had to change in\u00a0code:</p>\n<p>Introduced a new class MachinePartRanges to store range for each rating! I also had to implement a copy() function for deep copy of our object while spliting into true_range and false_range</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/661/1*QYtDV5jDm2rYwXHzYKEZRg.png\"></figure><p>Here\u2019s our modified evaluate_condition method:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Zi_akXHU4uNa35euIlNAuA.png\"></figure><p>And here\u2019s our <em>creme la de creme</em> methodnum_of_combinations_possible that calculate the distinct combinations of ratings will be accepted by the workflows!</p>\n<blockquote>\u201cThis function \ud83d\udc47<strong> broke my\u00a0brain!</strong>\n</blockquote>\n<blockquote>I spent over 2 hours debugging this as it started with a full on spagetti code with a lot of nesting! Only when I was able to clean it with early returns in my code was when I was able to make some progress!\u201d</blockquote>\n<blockquote><strong><em>Moral of story: Always write clean code so you can debug it\u00a0later!</em></strong></blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OroyF6H1W7uDVmns6SP9fw.png\"><figcaption>We use the same DFS with Backtracking approach to find all accepted_ranges</figcaption></figure><p>Let\u2019s test our code for the base test\u00a0case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/805/1*fnxjlpg_a5I7xWMdT9EVYQ.png\"><figcaption>We are still using the same input_str as part_one, but we will discard parts info while parse_input()</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty_2.py\"<br>\u2705 sum_of_rating_of_accepted_parts() tests passed<br><br>[Done] exited with code=0 in 0.317 seconds</pre>\n<p>Perfect! Let\u2019s load up our puzzle input and check if we can get the\u00a0answer?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/629/1*DyA0J7_RLH5KBIN0G7rpWw.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty_2.py\"<br>\u2757\ufe0f\u2757\ufe0f Number of combinations possible: XXXXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.345 seconds</pre>\n<p>Let\u2019s see if this is the correct answer?\u00a0\ud83e\udd1e</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8e4LpyIEOcXkq2uAMu5gMA.png\"><figcaption>\ud83c\udf1f</figcaption></figure><p>Here\u2019s our code for Part 2, I am very proud of this code!\u00a0\ud83e\udd72</p>\n<pre># Day 19 - Aplenty<br># Part Two<br><br>class MachinePartRanges:<br>    ACCEPTED = \"A\"<br>    REJECTED = \"R\"<br><br>    def __init__(self):<br>        self.rating_ranges = {<br>            \"x\": (1, 4000),<br>            \"m\": (1, 4000),<br>            \"a\": (1, 4000),<br>            \"s\": (1, 4000),<br>        }<br>        self.state = None<br><br>    def __repr__(self) -&gt; str:<br>        return str(self.rating_ranges)<br><br>    def copy(self):<br>        # deep copy<br>        new_mpr = MachinePartRanges()<br>        new_mpr.rating_ranges = self.rating_ranges.copy()<br>        return new_mpr<br><br><br>def evaluate_condition(ranges: MachinePartRanges, condition: str) -&gt; (MachinePartRanges, MachinePartRanges):<br>    true_range, false_range = ranges.copy(), ranges.copy()<br><br>    variable, value = condition.split(\"&lt;\" if \"&lt;\" in condition else \"&gt;\")<br><br>    if \"&lt;\" in condition:<br>        true_range.rating_ranges[variable] = (true_range.rating_ranges[variable][0], int(value) - 1)<br>        false_range.rating_ranges[variable] = (int(value), false_range.rating_ranges[variable][1])<br>    elif \"&gt;\" in condition:<br>        true_range.rating_ranges[variable] = (int(value) + 1, true_range.rating_ranges[variable][1])<br>        false_range.rating_ranges[variable] = (false_range.rating_ranges[variable][0], int(value))<br><br>    return true_range, false_range<br><br><br>def num_of_combinations_possible(workflows) -&gt; int:<br>    INITIAL_WORKFLOW_ID = \"in\"<br>    accepted_ranges_list = []<br><br>    stack = [(MachinePartRanges(), INITIAL_WORKFLOW_ID)]<br><br>    while stack:<br>        ranges, workflow_id = stack.pop()<br><br>        if workflow_id == MachinePartRanges.ACCEPTED: <br>            accepted_ranges_list.append(ranges)<br>            continue<br><br>        if workflow_id == MachinePartRanges.REJECTED:<br>            continue<br><br>        for rule in workflows[workflow_id]:<br>            if rule == MachinePartRanges.ACCEPTED:<br>                accepted_ranges_list.append(ranges)<br>                break<br><br>            if rule == MachinePartRanges.REJECTED:<br>                break<br><br>            if \":\" not in rule:<br>                workflow_id = rule<br>                stack.append((ranges, workflow_id))<br>                continue<br><br>            # rule must be a condition<br>            condition, new_worflow_id = rule.split(\":\")<br>            true_range, false_range = evaluate_condition(ranges, condition) <br>            stack.append((true_range, new_worflow_id)) # Add true range to stack to explore new_workflow_id<br>            ranges = false_range # Update ranges for next iteration in rules loop<br><br>    # now we have a list of accepted ranges, we can calculate the number of combinations possible<br>    num_of_combinations = 0<br>    for ranges in accepted_ranges_list:<br>        num_of_combinations += (<br>            (ranges.rating_ranges[\"x\"][1] - ranges.rating_ranges[\"x\"][0] + 1)<br>            * (ranges.rating_ranges[\"m\"][1] - ranges.rating_ranges[\"m\"][0] + 1)<br>            * (ranges.rating_ranges[\"a\"][1] - ranges.rating_ranges[\"a\"][0] + 1)<br>            * (ranges.rating_ranges[\"s\"][1] - ranges.rating_ranges[\"s\"][0] + 1)<br>        )<br><br>    return num_of_combinations<br><br><br>def parse_input(input_str: str) -&gt; tuple:<br>    workflow_str, _ = input_str.split(\"\\n\\n\")<br>    workflows = {}<br>    for workflow in workflow_str.split(\"\\n\"):<br>        workflow_name, workflow_rules = workflow.split(\"{\")  # Split on first '{'<br>        workflow_rules = workflow_rules[:-1]  # Remove trailing '}'<br>        workflows[workflow_name] = workflow_rules.split(\",\")<br><br>    return workflows<br><br>def part_two():<br>    with open(\"day_19/input.txt\") as f:<br>        input_str = f.read()<br>    workflows = parse_input(input_str)<br>    num = num_of_combinations_possible(workflows)<br>    print(f\"\u2757\ufe0f\u2757\ufe0f Number of combinations possible: {num}\")<br><br>def test_num_of_combinations_possible():<br>    input_str = \"\"\"px{a&lt;2006:qkq,m&gt;2090:A,rfg}<br>pv{a&gt;1716:R,A}<br>lnx{m&gt;1548:A,A}<br>rfg{s&lt;537:gd,x&gt;2440:R,A}<br>qs{s&gt;3448:A,lnx}<br>qkq{x&lt;1416:A,crn}<br>crn{x&gt;2662:A,R}<br>in{s&lt;1351:px,qqz}<br>qqz{s&gt;2770:qs,m&lt;1801:hdj,R}<br>gd{a&gt;3333:R,R}<br>hdj{m&gt;838:A,pv}<br><br>{x=787,m=2655,a=1222,s=2876}<br>{x=1679,m=44,a=2067,s=496}<br>{x=2036,m=264,a=79,s=2244}<br>{x=2461,m=1339,a=466,s=291}<br>{x=2127,m=1623,a=2188,s=1013}\"\"\"<br><br>    workflows = parse_input(input_str)<br>    num = num_of_combinations_possible(workflows)<br>    assert num == 167409079868000, f\"Expected 167409079868000, got {num}\"<br>    print(\"\u2705 sum_of_rating_of_accepted_parts() tests passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_num_of_combinations_possible()<br>    part_two()</pre>\n<p>I am keeping Part 1 and Part 2 seperate in our code base as both parts are actually pretty different in terms of processing, might come back to merge them later. Too tired for\u00a0now!</p>\n<p>Feel free to raise a\u00a0PR?!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=522ba14b1444\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["programming","advent-of-code","advent-of-code-2023","python","coding"]},{"title":"[Day 18] Lavaduct Lagoon // Advent of Code 2023 (Python)","pubDate":"2023-12-26 16:09:49","link":"https://medium.com/@jatinkrmalik/day-18-lavaduct-lagoon-advent-of-code-2023-python-f9413538d1d1?source=rss-ec576e4b06b0------2","guid":"https://medium.com/p/f9413538d1d1","author":"Jatin K Malik","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*lYtv2QgDM5vbpmoV\"><figcaption>Lavaduct Lagoon (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/18\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>Thanks to your efforts, the machine parts factory is one of the first factories up and running since the lavafall came back. However, to catch up with the large backlog of parts requests, the factory will also need a large supply of lava for a while; the Elves have already started creating a large lagoon nearby for this\u00a0purpose.</blockquote>\n<blockquote>However, they aren\u2019t sure the lagoon will be big enough; they\u2019ve asked you to take a look at the dig plan (your puzzle input). For\u00a0example:</blockquote>\n<blockquote>R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)</blockquote>\n<blockquote>The digger starts in a 1 meter cube hole in the ground. They then dig the specified number of meters up (U), down (D), left (L), or right (R), clearing full 1 meter cubes as they go. The directions are given as seen from above, so if \"up\" were north, then \"right\" would be east, and so on. Each trench is also listed with the color that the edge of the trench should be painted as an <a href=\"https://en.wikipedia.org/wiki/RGB_color_model#Numeric_representations\">RGB hexadecimal color\u00a0code</a>.</blockquote>\n<blockquote>When viewed from above, the above example dig plan would result in the following loop of trench (#) having been dug out from otherwise ground-level terrain\u00a0(.):</blockquote>\n<blockquote>#######<br>#.....#<br>###...#<br>..#...#<br>..#...#<br>###.###<br>#...#..<br>##..###<br>.#....#<br>.######</blockquote>\n<blockquote>At this point, the trench could contain 38 cubic meters of lava. However, this is just the edge of the lagoon; the next step is to dig out the interior so that it is one meter deep as\u00a0well:</blockquote>\n<blockquote>#######<br>#######<br>#######<br>..#####<br>..#####<br>#######<br>#####..<br>#######<br>.######<br>.######</blockquote>\n<blockquote>Now, the lagoon can contain a much more respectable 62 cubic meters of lava. While the interior is dug out, the edges are also painted according to the color codes in the dig\u00a0plan.</blockquote>\n<blockquote>The Elves are concerned the lagoon won\u2019t be large enough; if they follow their dig plan, how many cubic meters of lava could it\u00a0hold?</blockquote>\n<p>So, we are given a dig plan for the lagoon, which looks like\u00a0this:</p>\n<pre>R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)</pre>\n<p>So, this basically works in 3\u00a0steps:</p>\n<ol>\n<li>\n<strong>Dig</strong> the trenches as per each row of dig\u00a0plan</li>\n<li>\n<strong>Paint</strong> the edges of trenches as per the dig\u00a0plan</li>\n<li>\n<strong>Dig</strong> enclosed area by trench loop to form a\u00a0lagoon</li>\n</ol>\n<p>We can understand this better with the following visualization I created for my own understanding:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*i0i1AiTNlNCOPpdzXIQR2g.png\"><figcaption>Visualizations make everything simple!</figcaption></figure><blockquote>The Elves are concerned the lagoon won\u2019t be large enough; if they follow their dig plan, how many cubic meters of lava could it\u00a0hold?</blockquote>\n<p>Got it! So, let\u2019s follow our visualization and write some code with the base test\u00a0case!</p>\n<blockquote>\ud83d\udca1I don\u2019t see any use of RGB hexcodes for now, so we will park that. We may need it in part\u00a02.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/785/1*AVtJDen82jr1JNBixsd3uA.png\"></figure><p>Let\u2019s start one by one! First step is to implement dig_trench()</p>\n<blockquote>\u2757\ufe0fA caveat I can observe is that we don\u2019t really know the size of the site! All we know is that digger starts in a 1 meter cube hole in the\u00a0ground.</blockquote>\n<p>Assuming we start from (0, 0) our size will depend on how much further RIGHT and DOWN we go! Something like row, col = max(DOWN), max(RIGHT)\u00a0, we will figure out\u00a0that.</p>\n<p>Now, to parse dig_plan, we can just\u00a0define:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/354/1*Jps0cV06YMfgT5Tqz9QQnw.png\"></figure><p>And then, we can just iterate over the dig_plan and store the path in trench_path as a list of cordinates:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/627/1*wmxMcP44a-2UAdzWBa4sCQ.png\"></figure><p>Our trench_path may have duplicate nodes based on our dig plan, so since each node is just 1 m\u00b3 deep, we can calculate it\u2019s volume by just returning len(set(trench_path))\u00a0!</p>\n<p>Let\u2019s verify if this is correct, modifying our base test\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/761/1*eL1jyYxJczzbJPmcvMd75g.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>\u2705 get_trench_volume passed<br><br>[Done] exited with code=0 in 0.236 seconds</pre>\n<p>Perfect, now let\u2019s implement dig_lagoon to convert our trench_path loop into a lagoon_area\u00a0!</p>\n<p>\ud83d\udcad So, whenver we have to find tiles enclosed within a loop, the best way I know to do so is to do the<strong> Flood Fill</strong> algorithm! It works something like:</p>\n<ul>\n<li>start from 1 point inside the\u00a0loop</li>\n<li>use flood fill algorithm from this starting point to fill all reachable tiles</li>\n<li>it starts at a tile, then recursively fills adjacent tiles until it hits the boundary (the trench_path in this\u00a0case).</li>\n<li>as the flood fill algorithm visits each tile, store these tiles in a set\u200a\u2014\u200alagoon_area</li>\n</ul>\n<p>Here\u2019s a quick visualization for this\u00a0example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*bnnAGlPqXtpppKsPzmvURA.gif\"><figcaption>Flood fill for the base\u00a0case</figcaption></figure><p>But wait! We have seen this before! Remember Day\u00a010?</p>\n<p><a href=\"https://medium.com/@jatinkrmalik/wip-day-10-pipe-maze-advent-of-code-2023-python-2a4c8622707f\">[WIP][Day 10] Pipe Maze // Advent of Code 2023 (Python)</a></p>\n<p>We had exactly the same problem, but here instead of area, we have to calculate the volume, but given the depth == 1 m\u00b3, the answer shall be equivalent to the area\u00a0itself!</p>\n<p>We can similarly use:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Shoelace_formula\">Shoelace formula - Wikipedia</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Pick%27s_theorem\">Pick's theorem - Wikipedia</a></li>\n</ul>\n<p>And get number of tiles enclosed within trench_loop and then calculate lagoon\u2019s\u00a0volume!</p>\n<p>Let\u2019s experiment with that one\u00a0first!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/723/1*0X6R6Zq9uPP_KEStV73VsA.png\"></figure><p>And\u2026running our test case\u00a0now:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/727/1*3v815OPcZBhBXIDl31G7sQ.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>\u2705 get_trench_volume passed<br>\u2705 get_lagoon_volume passed<br><br>[Done] exited with code=0 in 0.305 seconds</pre>\n<p>Boom! Our hypothesis was correct, as we didn\u2019t have to do the flood fill and Shoelace\u2019s formula came to the\u00a0rescue!</p>\n<p>Let\u2019s load up our puzzle input and see if it\u00a0works!</p>\n<blockquote>\u2757\ufe0fThe only caveat with Shoelace\u2019s formula is that it works for simple, non-intersecting polygon! <strong><em>That may cause a\u00a0problem!</em></strong>\n</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/706/1*ivfOVbq9KCimj91BwYCg2A.png\"></figure><p>Let\u2019s run\u00a0this!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>\u2757\ufe0f Our lagoon can hold XXXXX m^3 of lava!<br><br>[Done] exited with code=0 in 0.312 seconds</pre>\n<p>We got an answer!\u00a0\ud83d\udc4f</p>\n<p>Let\u2019s put this in puzzle box and see if it is\u00a0correct:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*xW2m6c1VBdlzp1w5z0rhWw.png\"><figcaption>\u2b50\ufe0f</figcaption></figure><p>Here\u2019s our code till now:\u00a0\ud83e\udd0c</p>\n<pre># Day 18: Lavaduct Lagoon<br><br>from enum import Enum<br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br>dig_plan_to_direction = {<br>    'U': Direction.UP,<br>    'D': Direction.DOWN,<br>    'L': Direction.LEFT,<br>    'R': Direction.RIGHT,<br>}<br><br>LAGOON_DEPTH = 1<br><br>def dig_trench(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_path = [(start_x, start_y)]<br><br>    for direction, distance, color in dig_plan:<br>        direction = dig_plan_to_direction[direction]<br>        for _ in range(int(distance)):<br>            dx, dy = direction.value<br>            start_x, start_y = start_x + dx, start_y + dy<br>            if (start_x, start_y) not in trench_path:<br>                trench_path.append((start_x, start_y))<br><br>    return trench_path<br><br><br>def get_trench_volume(trench_path):<br>    return len(trench_path) * LAGOON_DEPTH<br><br>def get_lagoon_volume(trench_path):<br>    lagoon_area = 0<br><br>    num_trench_tiles = len(trench_path)<br><br>    # Shoelace formula<br>    for i in range(num_trench_tiles):<br>        j = (i + 1) % num_trench_tiles<br><br>        lagoon_area += trench_path[i][0] * trench_path[j][1]<br>        lagoon_area -= trench_path[j][0] * trench_path[i][1]<br><br>    lagoon_area = abs(lagoon_area) / 2.0<br>    num_lagoon_tiles = lagoon_area - num_trench_tiles // 2 + 1<br><br>    return int((num_lagoon_tiles + num_trench_tiles) * LAGOON_DEPTH)<br><br>def test_lavaduct_lagoon():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split('\\n')]<br>    trench_path = dig_trench(dig_plan)<br>    trench_volume = get_trench_volume(trench_path)<br>    assert trench_volume == 38, f\"Expected 38, got {trench_volume}\"<br>    print(\"\u2705 get_trench_volume passed\")<br><br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    assert lagoon_volume == 62, f\"Expected 62, got {lagoon_volume}\"<br>    print(\"\u2705 get_lagoon_volume passed\")<br><br>def part_one():<br>    with open('day_18/input.txt', 'r') as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_path = dig_trench(dig_plan)<br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    print(f\"\u2757\ufe0f Our lagoon can hold {lagoon_volume} m^3 of lava!\")<br><br>if __name__ == \"__main__\":<br>    test_lavaduct_lagoon()<br>    part_one()</pre>\n<h4>Part Two</h4>\n<blockquote>The Elves were right to be concerned; the planned lagoon would be much too\u00a0small.</blockquote>\n<blockquote>After a few minutes, someone realizes what happened; someone swapped the color and instruction parameters when producing the dig plan. They don\u2019t have time to fix the bug; one of them asks if you can extract the correct instructions from the hexadecimal codes.</blockquote>\n<blockquote>Each hexadecimal code is six hexadecimal digits long. The first five hexadecimal digits encode the distance in meters as a five-digit hexadecimal number. The last hexadecimal digit encodes the direction to dig: 0 means R, 1 means D, 2 means L, and 3 means\u00a0U.</blockquote>\n<blockquote>So, in the above example, the hexadecimal codes can be converted into the true instructions:</blockquote>\n<blockquote>#70c710 = R\u00a0461937</blockquote>\n<blockquote>#0dc571 = D\u00a056407</blockquote>\n<blockquote>#5713f0 = R\u00a0356671</blockquote>\n<blockquote>#d2c081 = D\u00a0863240</blockquote>\n<blockquote>#59c680 = R\u00a0367720</blockquote>\n<blockquote>#411b91 = D\u00a0266681</blockquote>\n<blockquote>#8ceee2 = L\u00a0577262</blockquote>\n<blockquote>#caa173 = U\u00a0829975</blockquote>\n<blockquote>#1b58a2 = L\u00a0112010</blockquote>\n<blockquote>#caa171 = D\u00a0829975</blockquote>\n<blockquote>#7807d2 = L\u00a0491645</blockquote>\n<blockquote>#a77fa3 = U\u00a0686074</blockquote>\n<blockquote>#015232 = L\u00a05411</blockquote>\n<blockquote>#7a21e3 = U\u00a0500254</blockquote>\n<blockquote>Digging out this loop and its interior produces a lagoon that can hold an impressive 952408144115 cubic meters of\u00a0lava.</blockquote>\n<blockquote>Convert the hexadecimal color codes into the correct instructions; if the Elves follow this new dig plan, how many cubic meters of lava could the lagoon\u00a0hold?</blockquote>\n<p>Well, seems like the lagoon won\u2019t hold all the\u00a0lava!</p>\n<p>Ofcourse, <strong>someone swapped</strong> the color and instruction parameters when producing the dig plan.\u00a0\ud83d\ude2a</p>\n<p>Seems like we will need to extract instruction from what we thought to be hex codes for the colors first! Something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/676/1*VdFd0RBCbNemiI0tZwVnvA.png\"><figcaption>The new instruction set!</figcaption></figure><p>Well, looks like this might increase the scope of calculations, but good thing is that we were able to reduce this from a 2D Grid to a mathematical problem\u00a0only!</p>\n<p>I am pretty confident that our solution will scale, all we need to update is our parsing criteria!</p>\n<p>First things first, let\u2019s create another map to help us map the new dig directions:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/295/1*HB20p540oJVUmCx_MkTo5A.png\"></figure><p>We can now implement a new function\u200a\u2014\u200adig_trench_hex() which will parse the hexcode part of the input and then use it to create trench_path</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/739/1*cWSOsvUH0WgtAyYLoHJofw.png\"></figure><p>Rest of the methods should be same more or less! Now let\u2019s test our new code against the base test\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/983/1*Mci6SCz52FwV1jPY2M5Zdw.png\"></figure><p>While using the debugger, I can see the <a href=\"https://en.wikipedia.org/wiki/Achilles%27_heel\">achilles heel</a> of our\u00a0code:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Z1HTTDMj5XhTkjvBmy7jRA.png\"><figcaption>15 minutes\u00a0later</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*RAFgO9VU5MW-yimPlsNiMg.png\"><figcaption>We have still not completed the first hex code in the test input\u00a0\ud83d\ude05</figcaption></figure><p>We need to rethink our approach as clearly we can\u2019t have a trench path list with millions of enteries, it\u2019s just not efficient as the larger a list becomes, the slower list operations become!</p>\n<p>While we can have a band aid solution by trying numpy or pandas but I want to solve this using stdio\u00a0itself.</p>\n<p>Let\u2019s think again! The bottleneck here is trying to generate these insanely long dig paths, what if we could just store the (start_x, start_y), (end_x, end_y) and use that to calculate everything else arithematically?</p>\n<p>As anyway we just need the length of path to calculate the volume initially! The volume of lagoon might get tricky as we usually need vertex (cordinates) of the path, but we will figure that once we have the ranges for trench_path?!</p>\n<p>Intoducing TrenchLine which is a subset of trench_path which simply calculates the end_x, end_y based on the direction and distance!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/894/1*sgd0eW_K7pbY3rMhKvK_Sg.png\"></figure><p>So, by changing our code and running it again, we can observe that we have a trench_path_ranges list with TrenchLine objects storing the range and direction for each dig\u00a0line:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*H5dtVzMvL_a7cxqok62i6g.png\"><figcaption>13 opearions, 13 lines with trench starting from 0, 0 and ending on 0,\u00a00</figcaption></figure><p>So, now that we have this, we can easily calculate the volume of trench as\u00a0well:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/548/1*dshSaO-W2rADuFstcKxZhQ.png\"></figure><p>Now, coming to lagoon, this gets a little\u00a0tricky!</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<blockquote>OH! EUREKA!</blockquote>\n<p>See, for Shoelace\u2019s algorith we don\u2019t really need each and every point on the path of the polygon! All we care is about the vertex nodes which incidentally we have captured in our trench_path_ranges</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/569/1*0RrqGDMaA1wdU7qQJZQxmw.png\"></figure><p>We can simplify transform this into a list of vertexes for the polygon by\u00a0doing:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/887/1*3agE2DWTCw8KX3X7QMauew.png\"></figure><p>which gives\u00a0us:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/613/1*wlO3XeXUM0LBwF-QSBd2Bg.png\"><figcaption>A list of 15 points encolsing our huge\u00a0lagoon!</figcaption></figure><p>Now we can just use the same shoelace\u2019s formula to solve\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/807/1*jgSOTbBkPLb1j8K5GVVXiQ.png\"></figure><p>Let\u2019s run the base test\u00a0case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/915/1*K8GJ16K5-uXZlS7JPNHDNg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>\u2705 get_trench_volume passed<br>\u2705 get_lagoon_volume passed<br><br>[Done] exited with code=0 in 0.256 seconds</pre>\n<p>Woohoo! Let\u2019s load up our puzzle input and get the answer for part\u00a02:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>\u2757\ufe0f\u2757\ufe0f Our lagoon can actually hold XXXXXXXXXXXXXXX m^3 of lava!<br><br>[Done] exited with code=0 in 0.241 seconds</pre>\n<p>That is actually a longboi answer! But we were able to get it in just <strong>0.241</strong>\u00a0seconds!</p>\n<p>Let\u2019s put this in our answer box and check if this is\u00a0correct:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*vWoJSGWsHgvlMBkM2mZP7A.png\"><figcaption>\ud83c\udf1f</figcaption></figure><p>Here\u2019s my rough code till now with a lot of repeated\u00a0chunks:</p>\n<pre># Day 18: Lavaduct Lagoon<br><br>from enum import Enum<br><br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br>dig_plan_to_direction = {<br>    \"U\": Direction.UP,<br>    \"D\": Direction.DOWN,<br>    \"L\": Direction.LEFT,<br>    \"R\": Direction.RIGHT,<br>}<br><br>hex_to_directions = {<br>    \"0\": Direction.RIGHT,<br>    \"1\": Direction.DOWN,<br>    \"2\": Direction.LEFT,<br>    \"3\": Direction.UP,<br>}<br><br>LAGOON_DEPTH = 1<br><br><br>class TrenchLine:<br>    def __init__(self, start_x, start_y, direction, distance):<br>        self.start_x = start_x<br>        self.start_y = start_y<br>        self.direction = direction<br>        self.distance = distance<br><br>        self.end_x = self.start_x + self.direction.value[0] * self.distance<br>        self.end_y = self.start_y + self.direction.value[1] * self.distance<br><br>    def __repr__(self):<br>        return f\"({self.start_x}, {self.start_y}) -&gt; ({self.end_x}, {self.end_y})\"<br><br><br>def dig_trench_simple(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_path = [(start_x, start_y)]<br><br>    for direction, distance, hexcode in dig_plan:<br>        direction = dig_plan_to_direction[direction]<br>        for _ in range(int(distance)):<br>            dx, dy = direction.value<br>            start_x, start_y = start_x + dx, start_y + dy<br>            if (start_x, start_y) not in trench_path:<br>                trench_path.append((start_x, start_y))<br><br>    return trench_path<br><br><br>def parse_hex(hex_code):<br>    # remove parentheses<br>    hex_code = hex_code[1:-1]<br>    # remove hash<br>    hex_code = hex_code[1:]<br><br>    # split into dig_distance(5 chars), dig_direction(last char)<br>    dig_distance_hex, dig_direction_hex = hex_code[:-1], hex_code[-1]<br><br>    # convert dig_distance_hex to decimal<br>    dig_distance = int(dig_distance_hex, 16)<br>    # convert dig_direction_hex to direction<br>    dig_direction = hex_to_directions[dig_direction_hex]<br><br>    return dig_distance, dig_direction<br><br><br>def dig_trench_hex(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_path_ranges = []<br><br>    for _, _, hex_code in dig_plan:<br>        dig_distance, dig_direction = parse_hex(hex_code)<br>        trench_line = TrenchLine(start_x, start_y, dig_direction, dig_distance)<br>        trench_path_ranges.append(trench_line)<br>        start_x, start_y = trench_line.end_x, trench_line.end_y<br><br>    return trench_path_ranges<br><br><br>def get_trench_volume_hex(trench_path_ranges):<br>    trench_area = 0<br><br>    for trench_line in trench_path_ranges:<br>        trench_area += trench_line.distance<br><br>    return trench_area * LAGOON_DEPTH<br><br><br>def create_polygon_from_trench_lines(trench_path_ranges):<br>    # Assuming the trench path forms a simple, closed loop<br>    polygon_points = [(line.start_x, line.start_y) for line in trench_path_ranges]<br>    polygon_points.append(<br>        (trench_path_ranges[-1].end_x, trench_path_ranges[-1].end_y)<br>    )  # Closing the loop<br>    return polygon_points<br><br><br>def get_lagoon_volume_hex(trench_path_ranges):<br>    trench_volume = get_trench_volume_hex(trench_path_ranges)<br>    polygon_points = create_polygon_from_trench_lines(trench_path_ranges)<br><br>    num_of_vertex = len(polygon_points)<br>    lagoon_area = 0.0<br><br>    for i in range(num_of_vertex):<br>        j = (i + 1) % num_of_vertex<br>        lagoon_area += polygon_points[i][0] * polygon_points[j][1]<br>        lagoon_area -= polygon_points[j][0] * polygon_points[i][1]<br><br>    lagoon_area = abs(lagoon_area) / 2.0<br><br>    num_lagoon_tiles = lagoon_area - trench_volume // 2 + 1<br><br>    return int((num_lagoon_tiles + trench_volume) * LAGOON_DEPTH)<br><br><br>def get_trench_volume(trench_path):<br>    return len(trench_path) * LAGOON_DEPTH<br><br><br>def get_lagoon_volume(trench_path):<br>    lagoon_area = 0<br><br>    num_trench_tiles = len(trench_path)<br><br>    # Shoelace formula<br>    for i in range(num_trench_tiles):<br>        j = (i + 1) % num_trench_tiles<br><br>        lagoon_area += trench_path[i][0] * trench_path[j][1]<br>        lagoon_area -= trench_path[j][0] * trench_path[i][1]<br><br>    lagoon_area = abs(lagoon_area) / 2.0<br>    num_lagoon_tiles = lagoon_area - num_trench_tiles // 2 + 1<br><br>    return int((num_lagoon_tiles + num_trench_tiles) * LAGOON_DEPTH)<br><br><br>def test_lavaduct_lagoon():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_path = dig_trench_simple(dig_plan)<br>    trench_volume = get_trench_volume(trench_path)<br>    assert trench_volume == 38, f\"Expected 38, got {trench_volume}\"<br>    print(\"\u2705 get_trench_volume passed\")<br><br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    assert lagoon_volume == 62, f\"Expected 62, got {lagoon_volume}\"<br>    print(\"\u2705 get_lagoon_volume passed\")<br><br><br>def test_lavaduct_lagoon_hex():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_path_ranges = dig_trench_hex(dig_plan)<br>    trench_volume = get_trench_volume_hex(trench_path_ranges)<br>    assert trench_volume == 6405262, f\"Expected 6405262, got {trench_volume}\"<br>    print(\"\u2705 get_trench_volume passed\")<br><br>    lagoon_volume = get_lagoon_volume_hex(trench_path_ranges)<br>    assert lagoon_volume == 952408144115, f\"Expected 952408144115, got {lagoon_volume}\"<br>    print(\"\u2705 get_lagoon_volume passed\")<br><br><br>def part_one():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_path = dig_trench_simple(dig_plan)<br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    print(f\"\u2757\ufe0f Our lagoon can hold {lagoon_volume} m^3 of lava!\")<br><br>def part_two():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_path_ranges = dig_trench_hex(dig_plan)<br>    lagoon_volume = get_lagoon_volume_hex(trench_path_ranges)<br>    print(f\"\u2757\ufe0f\u2757\ufe0f Our lagoon can actually hold {lagoon_volume} m^3 of lava!\")<br><br><br>if __name__ == \"__main__\":<br>    # test_lavaduct_lagoon()<br>    # part_one()<br><br>    # test_lavaduct_lagoon_hex()<br>    part_two()</pre>\n<blockquote>Man! This felt really good. Time complexity optimizations are just black\u00a0magic!</blockquote>\n<p>I see a couple of improvements in my code to make it even faster, let me do that and then share the pythonic code with\u00a0you:</p>\n<pre># Day 18: Lavaduct Lagoon<br><br>from enum import Enum<br><br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br>dig_plan_to_direction = {<br>    \"U\": Direction.UP,<br>    \"D\": Direction.DOWN,<br>    \"L\": Direction.LEFT,<br>    \"R\": Direction.RIGHT,<br>}<br><br>class TrenchLine:<br>    hex_to_directions = {<br>        \"0\": Direction.RIGHT,<br>        \"1\": Direction.DOWN,<br>        \"2\": Direction.LEFT,<br>        \"3\": Direction.UP,<br>    }<br><br>    def __init__(self, start_x, start_y, direction, distance):<br>        self.start_x = start_x<br>        self.start_y = start_y<br>        self.direction = direction<br>        self.distance = distance<br>        self.end_x, self.end_y = self.calculate_end_coordinates()<br><br>    def calculate_end_coordinates(self):<br>        return (<br>            self.start_x + self.direction.value[0] * self.distance,<br>            self.start_y + self.direction.value[1] * self.distance,<br>        )<br><br>    def __repr__(self):<br>        return f\"({self.start_x}, {self.start_y}) -&gt; ({self.end_x}, {self.end_y})\"<br><br>    @staticmethod<br>    def from_hex_code(start_x, start_y, hex_code):<br>        hex_code = hex_code[1:-1][1:]<br>        dig_distance = int(hex_code[:-1], 16)<br>        dig_direction_hex = hex_code[-1]<br>        dig_direction = TrenchLine.hex_to_directions[<br>            dig_direction_hex<br>        ] <br>        return TrenchLine(start_x, start_y, dig_direction, dig_distance)<br><br><br>class Lagoon:<br>    DEPTH = 1<br><br>    @staticmethod<br>    def get_trench_volume(trench_lines):<br>        return sum(line.distance for line in trench_lines) * Lagoon.DEPTH<br><br>    @staticmethod<br>    def get_lagoon_volume(trench_lines):<br>        polygon_points = [(line.start_x, line.start_y) for line in trench_lines] + [<br>            (trench_lines[-1].end_x, trench_lines[-1].end_y)<br>        ]<br>        lagoon_area = abs(<br>            sum(<br>                polygon_points[i][0] * polygon_points[(i + 1) % len(polygon_points)][1]<br>                - polygon_points[(i + 1) % len(polygon_points)][0]<br>                * polygon_points[i][1]<br>                for i in range(len(polygon_points))<br>            )<br>            / 2.0<br>        )<br>        num_lagoon_tiles = lagoon_area - Lagoon.get_trench_volume(trench_lines) // 2 + 1<br>        return int(<br>            (num_lagoon_tiles + Lagoon.get_trench_volume(trench_lines)) * Lagoon.DEPTH<br>        )<br><br><br>def dig_trench_simple(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_lines = []<br><br>    for direction_key, distance, _ in dig_plan:<br>        direction = dig_plan_to_direction[<br>            direction_key<br>        ] <br>        trench_line = TrenchLine(start_x, start_y, direction, int(distance))<br>        trench_lines.append(trench_line)<br>        start_x, start_y = trench_line.end_x, trench_line.end_y<br><br>    return trench_lines<br><br><br>def dig_trench_hex(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_lines = []<br><br>    for _, _, hex_code in dig_plan:<br>        trench_line = TrenchLine.from_hex_code(start_x, start_y, hex_code)<br>        trench_lines.append(trench_line)<br>        start_x, start_y = trench_line.end_x, trench_line.end_y<br><br>    return trench_lines<br><br><br>def test_lavaduct_lagoon():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_lines = dig_trench_simple(dig_plan)<br>    trench_volume = Lagoon.get_trench_volume(trench_lines)<br>    assert trench_volume == 38, f\"Expected 38, got {trench_volume}\"<br>    print(\"\u2705 get_trench_volume passed\")<br><br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    assert lagoon_volume == 62, f\"Expected 62, got {lagoon_volume}\"<br>    print(\"\u2705 get_lagoon_volume passed\")<br><br><br>def test_lavaduct_lagoon_hex():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_lines = dig_trench_hex(dig_plan)<br>    trench_volume = Lagoon.get_trench_volume(trench_lines)<br>    assert trench_volume == 6405262, f\"Expected 6405262, got {trench_volume}\"<br>    print(\"\u2705 get_trench_volume passed\")<br><br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    assert lagoon_volume == 952408144115, f\"Expected 952408144115, got {lagoon_volume}\"<br>    print(\"\u2705 get_lagoon_volume passed\")<br><br><br>def part_one():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_lines = dig_trench_simple(dig_plan)<br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    print(f\"\u2757\ufe0f Our lagoon can hold {lagoon_volume} m^3 of lava!\")<br><br><br>def part_two():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_lines = dig_trench_hex(dig_plan)<br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    print(f\"\u2757\ufe0f\u2757\ufe0f Our lagoon can actually hold {lagoon_volume} m^3 of lava!\")<br><br><br>if __name__ == \"__main__\":<br>    test_lavaduct_lagoon()<br>    test_lavaduct_lagoon_hex()<br>    part_one()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f9413538d1d1\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*lYtv2QgDM5vbpmoV\"><figcaption>Lavaduct Lagoon (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/18\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>Thanks to your efforts, the machine parts factory is one of the first factories up and running since the lavafall came back. However, to catch up with the large backlog of parts requests, the factory will also need a large supply of lava for a while; the Elves have already started creating a large lagoon nearby for this\u00a0purpose.</blockquote>\n<blockquote>However, they aren\u2019t sure the lagoon will be big enough; they\u2019ve asked you to take a look at the dig plan (your puzzle input). For\u00a0example:</blockquote>\n<blockquote>R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)</blockquote>\n<blockquote>The digger starts in a 1 meter cube hole in the ground. They then dig the specified number of meters up (U), down (D), left (L), or right (R), clearing full 1 meter cubes as they go. The directions are given as seen from above, so if \"up\" were north, then \"right\" would be east, and so on. Each trench is also listed with the color that the edge of the trench should be painted as an <a href=\"https://en.wikipedia.org/wiki/RGB_color_model#Numeric_representations\">RGB hexadecimal color\u00a0code</a>.</blockquote>\n<blockquote>When viewed from above, the above example dig plan would result in the following loop of trench (#) having been dug out from otherwise ground-level terrain\u00a0(.):</blockquote>\n<blockquote>#######<br>#.....#<br>###...#<br>..#...#<br>..#...#<br>###.###<br>#...#..<br>##..###<br>.#....#<br>.######</blockquote>\n<blockquote>At this point, the trench could contain 38 cubic meters of lava. However, this is just the edge of the lagoon; the next step is to dig out the interior so that it is one meter deep as\u00a0well:</blockquote>\n<blockquote>#######<br>#######<br>#######<br>..#####<br>..#####<br>#######<br>#####..<br>#######<br>.######<br>.######</blockquote>\n<blockquote>Now, the lagoon can contain a much more respectable 62 cubic meters of lava. While the interior is dug out, the edges are also painted according to the color codes in the dig\u00a0plan.</blockquote>\n<blockquote>The Elves are concerned the lagoon won\u2019t be large enough; if they follow their dig plan, how many cubic meters of lava could it\u00a0hold?</blockquote>\n<p>So, we are given a dig plan for the lagoon, which looks like\u00a0this:</p>\n<pre>R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)</pre>\n<p>So, this basically works in 3\u00a0steps:</p>\n<ol>\n<li>\n<strong>Dig</strong> the trenches as per each row of dig\u00a0plan</li>\n<li>\n<strong>Paint</strong> the edges of trenches as per the dig\u00a0plan</li>\n<li>\n<strong>Dig</strong> enclosed area by trench loop to form a\u00a0lagoon</li>\n</ol>\n<p>We can understand this better with the following visualization I created for my own understanding:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*i0i1AiTNlNCOPpdzXIQR2g.png\"><figcaption>Visualizations make everything simple!</figcaption></figure><blockquote>The Elves are concerned the lagoon won\u2019t be large enough; if they follow their dig plan, how many cubic meters of lava could it\u00a0hold?</blockquote>\n<p>Got it! So, let\u2019s follow our visualization and write some code with the base test\u00a0case!</p>\n<blockquote>\ud83d\udca1I don\u2019t see any use of RGB hexcodes for now, so we will park that. We may need it in part\u00a02.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/785/1*AVtJDen82jr1JNBixsd3uA.png\"></figure><p>Let\u2019s start one by one! First step is to implement dig_trench()</p>\n<blockquote>\u2757\ufe0fA caveat I can observe is that we don\u2019t really know the size of the site! All we know is that digger starts in a 1 meter cube hole in the\u00a0ground.</blockquote>\n<p>Assuming we start from (0, 0) our size will depend on how much further RIGHT and DOWN we go! Something like row, col = max(DOWN), max(RIGHT)\u00a0, we will figure out\u00a0that.</p>\n<p>Now, to parse dig_plan, we can just\u00a0define:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/354/1*Jps0cV06YMfgT5Tqz9QQnw.png\"></figure><p>And then, we can just iterate over the dig_plan and store the path in trench_path as a list of cordinates:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/627/1*wmxMcP44a-2UAdzWBa4sCQ.png\"></figure><p>Our trench_path may have duplicate nodes based on our dig plan, so since each node is just 1 m\u00b3 deep, we can calculate it\u2019s volume by just returning len(set(trench_path))\u00a0!</p>\n<p>Let\u2019s verify if this is correct, modifying our base test\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/761/1*eL1jyYxJczzbJPmcvMd75g.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>\u2705 get_trench_volume passed<br><br>[Done] exited with code=0 in 0.236 seconds</pre>\n<p>Perfect, now let\u2019s implement dig_lagoon to convert our trench_path loop into a lagoon_area\u00a0!</p>\n<p>\ud83d\udcad So, whenver we have to find tiles enclosed within a loop, the best way I know to do so is to do the<strong> Flood Fill</strong> algorithm! It works something like:</p>\n<ul>\n<li>start from 1 point inside the\u00a0loop</li>\n<li>use flood fill algorithm from this starting point to fill all reachable tiles</li>\n<li>it starts at a tile, then recursively fills adjacent tiles until it hits the boundary (the trench_path in this\u00a0case).</li>\n<li>as the flood fill algorithm visits each tile, store these tiles in a set\u200a\u2014\u200alagoon_area</li>\n</ul>\n<p>Here\u2019s a quick visualization for this\u00a0example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*bnnAGlPqXtpppKsPzmvURA.gif\"><figcaption>Flood fill for the base\u00a0case</figcaption></figure><p>But wait! We have seen this before! Remember Day\u00a010?</p>\n<p><a href=\"https://medium.com/@jatinkrmalik/wip-day-10-pipe-maze-advent-of-code-2023-python-2a4c8622707f\">[WIP][Day 10] Pipe Maze // Advent of Code 2023 (Python)</a></p>\n<p>We had exactly the same problem, but here instead of area, we have to calculate the volume, but given the depth == 1 m\u00b3, the answer shall be equivalent to the area\u00a0itself!</p>\n<p>We can similarly use:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Shoelace_formula\">Shoelace formula - Wikipedia</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Pick%27s_theorem\">Pick's theorem - Wikipedia</a></li>\n</ul>\n<p>And get number of tiles enclosed within trench_loop and then calculate lagoon\u2019s\u00a0volume!</p>\n<p>Let\u2019s experiment with that one\u00a0first!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/723/1*0X6R6Zq9uPP_KEStV73VsA.png\"></figure><p>And\u2026running our test case\u00a0now:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/727/1*3v815OPcZBhBXIDl31G7sQ.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>\u2705 get_trench_volume passed<br>\u2705 get_lagoon_volume passed<br><br>[Done] exited with code=0 in 0.305 seconds</pre>\n<p>Boom! Our hypothesis was correct, as we didn\u2019t have to do the flood fill and Shoelace\u2019s formula came to the\u00a0rescue!</p>\n<p>Let\u2019s load up our puzzle input and see if it\u00a0works!</p>\n<blockquote>\u2757\ufe0fThe only caveat with Shoelace\u2019s formula is that it works for simple, non-intersecting polygon! <strong><em>That may cause a\u00a0problem!</em></strong>\n</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/706/1*ivfOVbq9KCimj91BwYCg2A.png\"></figure><p>Let\u2019s run\u00a0this!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>\u2757\ufe0f Our lagoon can hold XXXXX m^3 of lava!<br><br>[Done] exited with code=0 in 0.312 seconds</pre>\n<p>We got an answer!\u00a0\ud83d\udc4f</p>\n<p>Let\u2019s put this in puzzle box and see if it is\u00a0correct:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*xW2m6c1VBdlzp1w5z0rhWw.png\"><figcaption>\u2b50\ufe0f</figcaption></figure><p>Here\u2019s our code till now:\u00a0\ud83e\udd0c</p>\n<pre># Day 18: Lavaduct Lagoon<br><br>from enum import Enum<br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br>dig_plan_to_direction = {<br>    'U': Direction.UP,<br>    'D': Direction.DOWN,<br>    'L': Direction.LEFT,<br>    'R': Direction.RIGHT,<br>}<br><br>LAGOON_DEPTH = 1<br><br>def dig_trench(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_path = [(start_x, start_y)]<br><br>    for direction, distance, color in dig_plan:<br>        direction = dig_plan_to_direction[direction]<br>        for _ in range(int(distance)):<br>            dx, dy = direction.value<br>            start_x, start_y = start_x + dx, start_y + dy<br>            if (start_x, start_y) not in trench_path:<br>                trench_path.append((start_x, start_y))<br><br>    return trench_path<br><br><br>def get_trench_volume(trench_path):<br>    return len(trench_path) * LAGOON_DEPTH<br><br>def get_lagoon_volume(trench_path):<br>    lagoon_area = 0<br><br>    num_trench_tiles = len(trench_path)<br><br>    # Shoelace formula<br>    for i in range(num_trench_tiles):<br>        j = (i + 1) % num_trench_tiles<br><br>        lagoon_area += trench_path[i][0] * trench_path[j][1]<br>        lagoon_area -= trench_path[j][0] * trench_path[i][1]<br><br>    lagoon_area = abs(lagoon_area) / 2.0<br>    num_lagoon_tiles = lagoon_area - num_trench_tiles // 2 + 1<br><br>    return int((num_lagoon_tiles + num_trench_tiles) * LAGOON_DEPTH)<br><br>def test_lavaduct_lagoon():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split('\\n')]<br>    trench_path = dig_trench(dig_plan)<br>    trench_volume = get_trench_volume(trench_path)<br>    assert trench_volume == 38, f\"Expected 38, got {trench_volume}\"<br>    print(\"\u2705 get_trench_volume passed\")<br><br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    assert lagoon_volume == 62, f\"Expected 62, got {lagoon_volume}\"<br>    print(\"\u2705 get_lagoon_volume passed\")<br><br>def part_one():<br>    with open('day_18/input.txt', 'r') as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_path = dig_trench(dig_plan)<br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    print(f\"\u2757\ufe0f Our lagoon can hold {lagoon_volume} m^3 of lava!\")<br><br>if __name__ == \"__main__\":<br>    test_lavaduct_lagoon()<br>    part_one()</pre>\n<h4>Part Two</h4>\n<blockquote>The Elves were right to be concerned; the planned lagoon would be much too\u00a0small.</blockquote>\n<blockquote>After a few minutes, someone realizes what happened; someone swapped the color and instruction parameters when producing the dig plan. They don\u2019t have time to fix the bug; one of them asks if you can extract the correct instructions from the hexadecimal codes.</blockquote>\n<blockquote>Each hexadecimal code is six hexadecimal digits long. The first five hexadecimal digits encode the distance in meters as a five-digit hexadecimal number. The last hexadecimal digit encodes the direction to dig: 0 means R, 1 means D, 2 means L, and 3 means\u00a0U.</blockquote>\n<blockquote>So, in the above example, the hexadecimal codes can be converted into the true instructions:</blockquote>\n<blockquote>#70c710 = R\u00a0461937</blockquote>\n<blockquote>#0dc571 = D\u00a056407</blockquote>\n<blockquote>#5713f0 = R\u00a0356671</blockquote>\n<blockquote>#d2c081 = D\u00a0863240</blockquote>\n<blockquote>#59c680 = R\u00a0367720</blockquote>\n<blockquote>#411b91 = D\u00a0266681</blockquote>\n<blockquote>#8ceee2 = L\u00a0577262</blockquote>\n<blockquote>#caa173 = U\u00a0829975</blockquote>\n<blockquote>#1b58a2 = L\u00a0112010</blockquote>\n<blockquote>#caa171 = D\u00a0829975</blockquote>\n<blockquote>#7807d2 = L\u00a0491645</blockquote>\n<blockquote>#a77fa3 = U\u00a0686074</blockquote>\n<blockquote>#015232 = L\u00a05411</blockquote>\n<blockquote>#7a21e3 = U\u00a0500254</blockquote>\n<blockquote>Digging out this loop and its interior produces a lagoon that can hold an impressive 952408144115 cubic meters of\u00a0lava.</blockquote>\n<blockquote>Convert the hexadecimal color codes into the correct instructions; if the Elves follow this new dig plan, how many cubic meters of lava could the lagoon\u00a0hold?</blockquote>\n<p>Well, seems like the lagoon won\u2019t hold all the\u00a0lava!</p>\n<p>Ofcourse, <strong>someone swapped</strong> the color and instruction parameters when producing the dig plan.\u00a0\ud83d\ude2a</p>\n<p>Seems like we will need to extract instruction from what we thought to be hex codes for the colors first! Something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/676/1*VdFd0RBCbNemiI0tZwVnvA.png\"><figcaption>The new instruction set!</figcaption></figure><p>Well, looks like this might increase the scope of calculations, but good thing is that we were able to reduce this from a 2D Grid to a mathematical problem\u00a0only!</p>\n<p>I am pretty confident that our solution will scale, all we need to update is our parsing criteria!</p>\n<p>First things first, let\u2019s create another map to help us map the new dig directions:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/295/1*HB20p540oJVUmCx_MkTo5A.png\"></figure><p>We can now implement a new function\u200a\u2014\u200adig_trench_hex() which will parse the hexcode part of the input and then use it to create trench_path</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/739/1*cWSOsvUH0WgtAyYLoHJofw.png\"></figure><p>Rest of the methods should be same more or less! Now let\u2019s test our new code against the base test\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/983/1*Mci6SCz52FwV1jPY2M5Zdw.png\"></figure><p>While using the debugger, I can see the <a href=\"https://en.wikipedia.org/wiki/Achilles%27_heel\">achilles heel</a> of our\u00a0code:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Z1HTTDMj5XhTkjvBmy7jRA.png\"><figcaption>15 minutes\u00a0later</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*RAFgO9VU5MW-yimPlsNiMg.png\"><figcaption>We have still not completed the first hex code in the test input\u00a0\ud83d\ude05</figcaption></figure><p>We need to rethink our approach as clearly we can\u2019t have a trench path list with millions of enteries, it\u2019s just not efficient as the larger a list becomes, the slower list operations become!</p>\n<p>While we can have a band aid solution by trying numpy or pandas but I want to solve this using stdio\u00a0itself.</p>\n<p>Let\u2019s think again! The bottleneck here is trying to generate these insanely long dig paths, what if we could just store the (start_x, start_y), (end_x, end_y) and use that to calculate everything else arithematically?</p>\n<p>As anyway we just need the length of path to calculate the volume initially! The volume of lagoon might get tricky as we usually need vertex (cordinates) of the path, but we will figure that once we have the ranges for trench_path?!</p>\n<p>Intoducing TrenchLine which is a subset of trench_path which simply calculates the end_x, end_y based on the direction and distance!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/894/1*sgd0eW_K7pbY3rMhKvK_Sg.png\"></figure><p>So, by changing our code and running it again, we can observe that we have a trench_path_ranges list with TrenchLine objects storing the range and direction for each dig\u00a0line:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*H5dtVzMvL_a7cxqok62i6g.png\"><figcaption>13 opearions, 13 lines with trench starting from 0, 0 and ending on 0,\u00a00</figcaption></figure><p>So, now that we have this, we can easily calculate the volume of trench as\u00a0well:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/548/1*dshSaO-W2rADuFstcKxZhQ.png\"></figure><p>Now, coming to lagoon, this gets a little\u00a0tricky!</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<blockquote>OH! EUREKA!</blockquote>\n<p>See, for Shoelace\u2019s algorith we don\u2019t really need each and every point on the path of the polygon! All we care is about the vertex nodes which incidentally we have captured in our trench_path_ranges</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/569/1*0RrqGDMaA1wdU7qQJZQxmw.png\"></figure><p>We can simplify transform this into a list of vertexes for the polygon by\u00a0doing:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/887/1*3agE2DWTCw8KX3X7QMauew.png\"></figure><p>which gives\u00a0us:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/613/1*wlO3XeXUM0LBwF-QSBd2Bg.png\"><figcaption>A list of 15 points encolsing our huge\u00a0lagoon!</figcaption></figure><p>Now we can just use the same shoelace\u2019s formula to solve\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/807/1*jgSOTbBkPLb1j8K5GVVXiQ.png\"></figure><p>Let\u2019s run the base test\u00a0case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/915/1*K8GJ16K5-uXZlS7JPNHDNg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>\u2705 get_trench_volume passed<br>\u2705 get_lagoon_volume passed<br><br>[Done] exited with code=0 in 0.256 seconds</pre>\n<p>Woohoo! Let\u2019s load up our puzzle input and get the answer for part\u00a02:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>\u2757\ufe0f\u2757\ufe0f Our lagoon can actually hold XXXXXXXXXXXXXXX m^3 of lava!<br><br>[Done] exited with code=0 in 0.241 seconds</pre>\n<p>That is actually a longboi answer! But we were able to get it in just <strong>0.241</strong>\u00a0seconds!</p>\n<p>Let\u2019s put this in our answer box and check if this is\u00a0correct:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*vWoJSGWsHgvlMBkM2mZP7A.png\"><figcaption>\ud83c\udf1f</figcaption></figure><p>Here\u2019s my rough code till now with a lot of repeated\u00a0chunks:</p>\n<pre># Day 18: Lavaduct Lagoon<br><br>from enum import Enum<br><br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br>dig_plan_to_direction = {<br>    \"U\": Direction.UP,<br>    \"D\": Direction.DOWN,<br>    \"L\": Direction.LEFT,<br>    \"R\": Direction.RIGHT,<br>}<br><br>hex_to_directions = {<br>    \"0\": Direction.RIGHT,<br>    \"1\": Direction.DOWN,<br>    \"2\": Direction.LEFT,<br>    \"3\": Direction.UP,<br>}<br><br>LAGOON_DEPTH = 1<br><br><br>class TrenchLine:<br>    def __init__(self, start_x, start_y, direction, distance):<br>        self.start_x = start_x<br>        self.start_y = start_y<br>        self.direction = direction<br>        self.distance = distance<br><br>        self.end_x = self.start_x + self.direction.value[0] * self.distance<br>        self.end_y = self.start_y + self.direction.value[1] * self.distance<br><br>    def __repr__(self):<br>        return f\"({self.start_x}, {self.start_y}) -&gt; ({self.end_x}, {self.end_y})\"<br><br><br>def dig_trench_simple(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_path = [(start_x, start_y)]<br><br>    for direction, distance, hexcode in dig_plan:<br>        direction = dig_plan_to_direction[direction]<br>        for _ in range(int(distance)):<br>            dx, dy = direction.value<br>            start_x, start_y = start_x + dx, start_y + dy<br>            if (start_x, start_y) not in trench_path:<br>                trench_path.append((start_x, start_y))<br><br>    return trench_path<br><br><br>def parse_hex(hex_code):<br>    # remove parentheses<br>    hex_code = hex_code[1:-1]<br>    # remove hash<br>    hex_code = hex_code[1:]<br><br>    # split into dig_distance(5 chars), dig_direction(last char)<br>    dig_distance_hex, dig_direction_hex = hex_code[:-1], hex_code[-1]<br><br>    # convert dig_distance_hex to decimal<br>    dig_distance = int(dig_distance_hex, 16)<br>    # convert dig_direction_hex to direction<br>    dig_direction = hex_to_directions[dig_direction_hex]<br><br>    return dig_distance, dig_direction<br><br><br>def dig_trench_hex(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_path_ranges = []<br><br>    for _, _, hex_code in dig_plan:<br>        dig_distance, dig_direction = parse_hex(hex_code)<br>        trench_line = TrenchLine(start_x, start_y, dig_direction, dig_distance)<br>        trench_path_ranges.append(trench_line)<br>        start_x, start_y = trench_line.end_x, trench_line.end_y<br><br>    return trench_path_ranges<br><br><br>def get_trench_volume_hex(trench_path_ranges):<br>    trench_area = 0<br><br>    for trench_line in trench_path_ranges:<br>        trench_area += trench_line.distance<br><br>    return trench_area * LAGOON_DEPTH<br><br><br>def create_polygon_from_trench_lines(trench_path_ranges):<br>    # Assuming the trench path forms a simple, closed loop<br>    polygon_points = [(line.start_x, line.start_y) for line in trench_path_ranges]<br>    polygon_points.append(<br>        (trench_path_ranges[-1].end_x, trench_path_ranges[-1].end_y)<br>    )  # Closing the loop<br>    return polygon_points<br><br><br>def get_lagoon_volume_hex(trench_path_ranges):<br>    trench_volume = get_trench_volume_hex(trench_path_ranges)<br>    polygon_points = create_polygon_from_trench_lines(trench_path_ranges)<br><br>    num_of_vertex = len(polygon_points)<br>    lagoon_area = 0.0<br><br>    for i in range(num_of_vertex):<br>        j = (i + 1) % num_of_vertex<br>        lagoon_area += polygon_points[i][0] * polygon_points[j][1]<br>        lagoon_area -= polygon_points[j][0] * polygon_points[i][1]<br><br>    lagoon_area = abs(lagoon_area) / 2.0<br><br>    num_lagoon_tiles = lagoon_area - trench_volume // 2 + 1<br><br>    return int((num_lagoon_tiles + trench_volume) * LAGOON_DEPTH)<br><br><br>def get_trench_volume(trench_path):<br>    return len(trench_path) * LAGOON_DEPTH<br><br><br>def get_lagoon_volume(trench_path):<br>    lagoon_area = 0<br><br>    num_trench_tiles = len(trench_path)<br><br>    # Shoelace formula<br>    for i in range(num_trench_tiles):<br>        j = (i + 1) % num_trench_tiles<br><br>        lagoon_area += trench_path[i][0] * trench_path[j][1]<br>        lagoon_area -= trench_path[j][0] * trench_path[i][1]<br><br>    lagoon_area = abs(lagoon_area) / 2.0<br>    num_lagoon_tiles = lagoon_area - num_trench_tiles // 2 + 1<br><br>    return int((num_lagoon_tiles + num_trench_tiles) * LAGOON_DEPTH)<br><br><br>def test_lavaduct_lagoon():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_path = dig_trench_simple(dig_plan)<br>    trench_volume = get_trench_volume(trench_path)<br>    assert trench_volume == 38, f\"Expected 38, got {trench_volume}\"<br>    print(\"\u2705 get_trench_volume passed\")<br><br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    assert lagoon_volume == 62, f\"Expected 62, got {lagoon_volume}\"<br>    print(\"\u2705 get_lagoon_volume passed\")<br><br><br>def test_lavaduct_lagoon_hex():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_path_ranges = dig_trench_hex(dig_plan)<br>    trench_volume = get_trench_volume_hex(trench_path_ranges)<br>    assert trench_volume == 6405262, f\"Expected 6405262, got {trench_volume}\"<br>    print(\"\u2705 get_trench_volume passed\")<br><br>    lagoon_volume = get_lagoon_volume_hex(trench_path_ranges)<br>    assert lagoon_volume == 952408144115, f\"Expected 952408144115, got {lagoon_volume}\"<br>    print(\"\u2705 get_lagoon_volume passed\")<br><br><br>def part_one():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_path = dig_trench_simple(dig_plan)<br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    print(f\"\u2757\ufe0f Our lagoon can hold {lagoon_volume} m^3 of lava!\")<br><br>def part_two():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_path_ranges = dig_trench_hex(dig_plan)<br>    lagoon_volume = get_lagoon_volume_hex(trench_path_ranges)<br>    print(f\"\u2757\ufe0f\u2757\ufe0f Our lagoon can actually hold {lagoon_volume} m^3 of lava!\")<br><br><br>if __name__ == \"__main__\":<br>    # test_lavaduct_lagoon()<br>    # part_one()<br><br>    # test_lavaduct_lagoon_hex()<br>    part_two()</pre>\n<blockquote>Man! This felt really good. Time complexity optimizations are just black\u00a0magic!</blockquote>\n<p>I see a couple of improvements in my code to make it even faster, let me do that and then share the pythonic code with\u00a0you:</p>\n<pre># Day 18: Lavaduct Lagoon<br><br>from enum import Enum<br><br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br>dig_plan_to_direction = {<br>    \"U\": Direction.UP,<br>    \"D\": Direction.DOWN,<br>    \"L\": Direction.LEFT,<br>    \"R\": Direction.RIGHT,<br>}<br><br>class TrenchLine:<br>    hex_to_directions = {<br>        \"0\": Direction.RIGHT,<br>        \"1\": Direction.DOWN,<br>        \"2\": Direction.LEFT,<br>        \"3\": Direction.UP,<br>    }<br><br>    def __init__(self, start_x, start_y, direction, distance):<br>        self.start_x = start_x<br>        self.start_y = start_y<br>        self.direction = direction<br>        self.distance = distance<br>        self.end_x, self.end_y = self.calculate_end_coordinates()<br><br>    def calculate_end_coordinates(self):<br>        return (<br>            self.start_x + self.direction.value[0] * self.distance,<br>            self.start_y + self.direction.value[1] * self.distance,<br>        )<br><br>    def __repr__(self):<br>        return f\"({self.start_x}, {self.start_y}) -&gt; ({self.end_x}, {self.end_y})\"<br><br>    @staticmethod<br>    def from_hex_code(start_x, start_y, hex_code):<br>        hex_code = hex_code[1:-1][1:]<br>        dig_distance = int(hex_code[:-1], 16)<br>        dig_direction_hex = hex_code[-1]<br>        dig_direction = TrenchLine.hex_to_directions[<br>            dig_direction_hex<br>        ] <br>        return TrenchLine(start_x, start_y, dig_direction, dig_distance)<br><br><br>class Lagoon:<br>    DEPTH = 1<br><br>    @staticmethod<br>    def get_trench_volume(trench_lines):<br>        return sum(line.distance for line in trench_lines) * Lagoon.DEPTH<br><br>    @staticmethod<br>    def get_lagoon_volume(trench_lines):<br>        polygon_points = [(line.start_x, line.start_y) for line in trench_lines] + [<br>            (trench_lines[-1].end_x, trench_lines[-1].end_y)<br>        ]<br>        lagoon_area = abs(<br>            sum(<br>                polygon_points[i][0] * polygon_points[(i + 1) % len(polygon_points)][1]<br>                - polygon_points[(i + 1) % len(polygon_points)][0]<br>                * polygon_points[i][1]<br>                for i in range(len(polygon_points))<br>            )<br>            / 2.0<br>        )<br>        num_lagoon_tiles = lagoon_area - Lagoon.get_trench_volume(trench_lines) // 2 + 1<br>        return int(<br>            (num_lagoon_tiles + Lagoon.get_trench_volume(trench_lines)) * Lagoon.DEPTH<br>        )<br><br><br>def dig_trench_simple(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_lines = []<br><br>    for direction_key, distance, _ in dig_plan:<br>        direction = dig_plan_to_direction[<br>            direction_key<br>        ] <br>        trench_line = TrenchLine(start_x, start_y, direction, int(distance))<br>        trench_lines.append(trench_line)<br>        start_x, start_y = trench_line.end_x, trench_line.end_y<br><br>    return trench_lines<br><br><br>def dig_trench_hex(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_lines = []<br><br>    for _, _, hex_code in dig_plan:<br>        trench_line = TrenchLine.from_hex_code(start_x, start_y, hex_code)<br>        trench_lines.append(trench_line)<br>        start_x, start_y = trench_line.end_x, trench_line.end_y<br><br>    return trench_lines<br><br><br>def test_lavaduct_lagoon():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_lines = dig_trench_simple(dig_plan)<br>    trench_volume = Lagoon.get_trench_volume(trench_lines)<br>    assert trench_volume == 38, f\"Expected 38, got {trench_volume}\"<br>    print(\"\u2705 get_trench_volume passed\")<br><br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    assert lagoon_volume == 62, f\"Expected 62, got {lagoon_volume}\"<br>    print(\"\u2705 get_lagoon_volume passed\")<br><br><br>def test_lavaduct_lagoon_hex():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_lines = dig_trench_hex(dig_plan)<br>    trench_volume = Lagoon.get_trench_volume(trench_lines)<br>    assert trench_volume == 6405262, f\"Expected 6405262, got {trench_volume}\"<br>    print(\"\u2705 get_trench_volume passed\")<br><br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    assert lagoon_volume == 952408144115, f\"Expected 952408144115, got {lagoon_volume}\"<br>    print(\"\u2705 get_lagoon_volume passed\")<br><br><br>def part_one():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_lines = dig_trench_simple(dig_plan)<br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    print(f\"\u2757\ufe0f Our lagoon can hold {lagoon_volume} m^3 of lava!\")<br><br><br>def part_two():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_lines = dig_trench_hex(dig_plan)<br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    print(f\"\u2757\ufe0f\u2757\ufe0f Our lagoon can actually hold {lagoon_volume} m^3 of lava!\")<br><br><br>if __name__ == \"__main__\":<br>    test_lavaduct_lagoon()<br>    test_lavaduct_lagoon_hex()<br>    part_one()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f9413538d1d1\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["advent-of-code-2023","python","programming","advent-of-code","coding"]},{"title":"[Day 17] Clumsy Crucible // Advent of Code 2023 (Python)","pubDate":"2023-12-26 13:04:20","link":"https://medium.com/@jatinkrmalik/day-17-clumsy-crucible-advent-of-code-2023-python-2aade00ab25e?source=rss-ec576e4b06b0------2","guid":"https://medium.com/p/2aade00ab25e","author":"Jatin K Malik","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*yySJqIpnZupAF8I0\"><figcaption>Clumsy Crucible (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/17\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>The lava starts flowing rapidly once the Lava Production Facility is operational. As you leave, the reindeer offers you a parachute, allowing you to quickly reach Gear\u00a0Island.</blockquote>\n<blockquote>As you descend, your bird\u2019s-eye view of Gear Island reveals why you had trouble finding anyone on your way up: half of Gear Island is empty, but the half below you is a giant factory\u00a0city!</blockquote>\n<blockquote>You land near the gradually-filling pool of lava at the base of your new lavafall. Lavaducts will eventually carry the lava throughout the city, but to make use of it immediately, Elves are loading it into large <a href=\"https://en.wikipedia.org/wiki/Crucible\">crucibles</a> on\u00a0wheels.</blockquote>\n<blockquote>The crucibles are top-heavy and pushed by hand. Unfortunately, the crucibles become very difficult to steer at high speeds, and so it can be hard to go in a straight line for very\u00a0long.</blockquote>\n<blockquote>To get Desert Island the machine parts it needs as soon as possible, you\u2019ll need to find the best way to get the crucible from the lava pool to the machine parts factory. To do this, you need to minimize heat loss while choosing a route that doesn\u2019t require the crucible to go in a straight linefor too\u00a0long.</blockquote>\n<blockquote>Fortunately, the Elves here have a map (your puzzle input) that uses traffic patterns, ambient temperature, and hundreds of other parameters to calculate exactly how much heat loss can be expected for a crucible entering any particular city\u00a0block.</blockquote>\n<blockquote>For example:</blockquote>\n<blockquote>2413432311323<br>3215453535623<br>3255245654254<br>3446585845452<br>4546657867536<br>1438598798454<br>4457876987766<br>3637877979653<br>4654967986887<br>4564679986453<br>1224686865563<br>2546548887735<br>4322674655533</blockquote>\n<blockquote>Each city block is marked by a single digit that represents the amount of heat loss if the crucible enters that block. The starting point, the lava pool, is the top-left city block; the destination, the machine parts factory, is the bottom-right city block. (Because you already start in the top-left block, you don\u2019t incur that block\u2019s heat loss unless you leave that block and then return to\u00a0it.)</blockquote>\n<blockquote>Because it is difficult to keep the top-heavy crucible going in a straight line for very long, it can move at most three blocks in a single direction before it must turn 90 degrees left or right. The crucible also can\u2019t reverse direction; after entering each city block, it may only turn left, continue straight, or turn\u00a0right.</blockquote>\n<blockquote>One way to minimize heat loss is this\u00a0path:</blockquote>\n<blockquote>2&gt;&gt;34^&gt;&gt;&gt;1323<br>32v&gt;&gt;&gt;35v5623<br>32552456v&gt;&gt;54<br>3446585845v52<br>4546657867v&gt;6<br>14385987984v4<br>44578769877v6<br>36378779796v&gt;<br>465496798688v<br>456467998645v<br>12246868655&lt;v<br>25465488877v5<br>43226746555v&gt;</blockquote>\n<blockquote>This path never moves more than three consecutive blocks in the same direction and incurs a heat loss of only\u00a0102.</blockquote>\n<blockquote>Directing the crucible from the lava pool to the machine parts factory, but not moving more than three consecutive blocks in the same direction, what is the least heat loss it can\u00a0incur?</blockquote>\n<blockquote>Yay! Lava Production Facility is operational!</blockquote>\n<p>Seems like now we need to find the best way to get the lava crucible from the lava pool to the machine parts\u00a0factory!</p>\n<p>We need to <strong><em>minimize </em></strong>heat loss by <strong>NOT</strong> taking a route with a long straight line as supposedly, crucibles become difficult to steer at high speed?! Well, that\u2019s an interesting limitation.</p>\n<p>So, to solve this, we are given a map with traffic patterns, ambient temperature and hundred of other params to help us calculate expected heatloss for the crucible while entering any city block, that look something like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1016/1*CmYlpzrbuOK0vG7RtHQPwQ.png\"></figure><p><strong>\ud83d\udca1\ufffdConditions to remember:</strong></p>\n<ul>\n<li>Because you already start in the <strong>top-left block</strong>, you <strong>don\u2019t</strong> incur that block\u2019s heat loss unless you leave that block and then return to\u00a0it!</li>\n<li>Because it is difficult to keep the top-heavy crucible going in a straight line for very long, it can move <strong>at most three blocks</strong> in a <strong>single direction</strong> before it must turn <strong>90 degrees left or\u00a0right.</strong>\n</li>\n<li>The crucible also <strong>can\u2019t reverse direction</strong>; after entering each city block, it may only <strong>turn left, continue straight, or turn\u00a0right</strong>.</li>\n</ul>\n<p>So, let\u2019s see for the given base case example, what can be a way to minimize the heat loss in the\u00a0path?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5zgsgBaC0KBm6JXWMl_CDg.gif\"></figure><p>This path never moves more than three consecutive blocks in the same direction. Here we incur a total heat loss of <strong>102\u00a0</strong>units.</p>\n<p>Now we need to find the answer similarly in the puzzle input. First things first, let\u2019s write unit test for base case and try to fix that\u00a0first?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/803/1*fTDdrnXE1FqfGOKG77upSQ.png\"><figcaption>Skelton code</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>Traceback (most recent call last):<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 29, in &lt;module&gt;<br>    test_get_min_heat_loss_path()<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 25, in test_get_min_heat_loss_path<br>    assert min_heat_loss == 102, f\"Expected 102, got {min_heat_loss}\"<br>AssertionError: Expected 102, got 0<br><br>[Done] exited with code=1 in 0.224 seconds</pre>\n<p>Let\u2019s break down the\u00a0problem!</p>\n<blockquote>It seems very similar to the last few problems, where we need to find path from top left to bottom right while obeying some rules and trying to minimize the heat\u00a0loss!</blockquote>\n<p>The naive approach is to just explore all possible paths and then just pick the one with the lowest heat loss, but it will lead to a time complexity of: <strong><em>O(2^(N*M)) </em></strong>which means we will\u00a0have:</p>\n<ul>\n<li>2\u00b9\u2076\u2079 combinations for our base test case here with 13 x 13\u00a0grid</li>\n<li>2\u00b9\u2079\u2078\u2078\u00b9 combinations for puzzle input with a 141 x 141\u00a0grid.</li>\n</ul>\n<p><strong><em>Fun fact? It is estimated that there may be ~2\u00b2\u2075\u2076 atoms in the known universe!</em></strong></p>\n<p>So, you can we the problem with the brute force approach\u00a0here!</p>\n<p>We can reduce our search space by a lot here by following the given constraints!</p>\n<p>\ud83d\udcad One way that crosses my mind is to just do the DFS (Depth first search) by iterating through grid and store result in a var which will update whenever a path reaches bottom right\u00a0like:</p>\n<p><strong>MIN_HEAT_LOSS = min(MIN_HEAT_LOSS, path_heat_loss)</strong></p>\n<p>And during iteration, on each choice just abandon any path that takes our path_heat_loss &gt; MIN_HEAT_LOSS\u00a0! By doing this, we can greatly reduce our search space to opt for more efficient paths on each\u00a0try!</p>\n<p>Let\u2019s write some\u00a0code?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6mirpbc9wQv8qSPCtsw-yg.png\"><figcaption>Shit tons of debugging ensued!</figcaption></figure><p>So, we have written functionally correct code, as I can see the output trending towards the intended result, but the problem is our <strong><em>stack </em></strong>keeps increasing as it backtracks for all possible directions! I wrote a small script to visualize the state of my MIN_HEAT_LOSS_PATH, take a look as it optimises the path quickly at start but then gets caught\u00a0up:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*myypKLXpQZELvZZDSpD69w.gif\"></figure><p>It\u2019s clear that my code as it backtracks, it tries to process same path again as again as in DFS it will keep looping into a subsection of those 2\u00b9\u2076\u2079 combinations as we discussed above!</p>\n<p>To avoid this, we can use memoization to store the minimum heat loss encountered at <strong>each node</strong>. If a path reaches the same node with a higher heat loss than previously recorded, we can just prune that path\u00a0early.</p>\n<p>Adding a simple 2D arraymemo of same size as grid just to keep a track of lowest_heat_loss seen at every iteration:</p>\n<pre>memo = [[float('inf') for _ in range(len(grid[0]))] for _ in range(len(grid))]</pre>\n<p>And we can add a simple check in our code to ensure\u00a0that:</p>\n<pre><br># if heat loss is already greater than min heat loss, continue<br>if next_heat_loss &gt;= memo[next_row][next_col]:<br>  continue</pre>\n<p>Let\u2019s run it?\u00a0And\u2026</p>\n<pre>New min heat loss: 107<br># # # # . . # # # # . . .<br>. . . # # # # . . # . . .<br>. . . . . . . . . # # . .<br>. . . . . . . . . . # # .<br>. . . . . . . . . . . # .<br>. . . . . . . . . . . # #<br>. . . . . . . . . . . . #<br>. . . . . . . . . . . # #<br>. . . . . . . . . . . # .<br>. . . . . . . . . . . # #<br>. . . . . . . . . . . . #<br>. . . . . . . . . . . . #<br>. . . . . . . . . . . . #<br><br>Traceback (most recent call last):<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 112, in &lt;module&gt;<br>    test_get_min_heat_loss_path()<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 107, in test_get_min_heat_loss_path<br>    assert min_heat_loss == 102, f\"Expected 102, got {min_heat_loss}\"<br>AssertionError: Expected 102, got 107<br><br>[Done] exited with code=1 in 0.251 seconds</pre>\n<p>We are getting close! Atleast our runtime suggests that we have reduced our search space by a lot! We should get 102 but we are getting 107\u00a0here.</p>\n<p>Again, some debugging to\u00a0go:</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>Ah! Found it. Our memo is currently just storing 1 dimension of heat_loss but we can basically get to that cell from any direction which may lead to a shorter path overall! We need to store heat_loss for all 4 directions for each\u00a0cell</p>\n<pre># Initialize memoization table with dictionaries<br>memo = [[{d: float('inf') for d in Direction} for _ in range(len(grid[0]))] for _ in range(len(grid))]</pre>\n<p>And our memo condition will be modified\u00a0to:</p>\n<pre># Continue to the next direction if the new path is not better<br>if next_heat_loss &gt; memo[next_row][next_col][direction]:<br>    continue<br>.<br>.<br>.<br># Update memo<br>memo[next_row][next_col][direction] = next_heat_loss  </pre>\n<p>Let\u2019s run the base test\u00a0case?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>\u2705 get_min_heat_loss_path() tests passed!<br><br>[Done] exited with code=0 in 0.726 seconds</pre>\n<p>Yas! Now, let\u2019s load up our puzzle\u00a0input?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>\u2757\ufe0f Minimum heat loss for crucible: XXX<br><br>[Done] exited with code=0 in 0.818 seconds</pre>\n<p>Let\u2019s input the answer\u00a0and\u2026.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iANd1s2bvHp2YSBOxDSdBw.png\"><figcaption>\u2b50\ufe0f</figcaption></figure><p>Our approach is quite messy! I am inclined to also explore this from BFS point of view in next part as I now feel we could have just used Djikstra's algo and called it a day by optimizing for low_heat_loss using a\u00a0heapq.</p>\n<h3>Part Two</h3>\n<blockquote>The crucibles of lava simply aren\u2019t large enough to provide an adequate supply of lava to the machine parts factory. Instead, the Elves are going to upgrade to ultra crucibles.</blockquote>\n<blockquote>Ultra crucibles are even more difficult to steer than normal crucibles. Not only do they have trouble going in a straight line, but they also have trouble\u00a0turning!</blockquote>\n<blockquote>Once an ultra crucible starts moving in a direction, it needs to move a minimum of four blocks in that direction before it can turn (or even before it can stop at the end). However, it will eventually start to get wobbly: an ultra crucible can move a maximum of ten consecutive blocks without\u00a0turning.</blockquote>\n<blockquote>In the above example, an ultra crucible could follow this path to minimize heat\u00a0loss:</blockquote>\n<blockquote>2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;1323<br>32154535v5623<br>32552456v4254<br>34465858v5452<br>45466578v&gt;&gt;&gt;&gt;<br>143859879845v<br>445787698776v<br>363787797965v<br>465496798688v<br>456467998645v<br>122468686556v<br>254654888773v<br>432267465553v</blockquote>\n<blockquote>In the above example, an ultra crucible would incur the minimum possible heat loss of\u00a094.</blockquote>\n<blockquote>Here\u2019s another\u00a0example:</blockquote>\n<blockquote>111111111111<br>999999999991<br>999999999991<br>999999999991<br>999999999991</blockquote>\n<blockquote>Sadly, an ultra crucible would need to take an unfortunate path like this\u00a0one:</blockquote>\n<blockquote>1&gt;&gt;&gt;&gt;&gt;&gt;&gt;1111<br>9999999v9991<br>9999999v9991<br>9999999v9991<br>9999999v&gt;&gt;&gt;&gt;</blockquote>\n<blockquote>This route causes the ultra crucible to incur the minimum possible heat loss of\u00a071.</blockquote>\n<blockquote>Directing the ultra crucible from the lava pool to the machine parts factory, what is the least heat loss it can\u00a0incur?</blockquote>\n<p>So! We now have <strong>Ultra Crucibles!</strong></p>\n<p>It seems like we need to modifty our code to handle the new conditions:</p>\n<ul>\n<li>once it starts moving in a direction, it needs to move a <strong>minimum of four blocks in that direction</strong> before it can turn.<br>- or even before it can stop at the\u00a0end.</li>\n<li>can move a <strong>maximum of ten consecutive blocks</strong> without\u00a0turning.</li>\n</ul>\n<p>So, for the same example like in last part, here\u2019s how the traversal will look like for an Ultra Crucible:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*7djuAO8y7gNYz-uE5XyEgw.gif\"></figure><p>Now, using the similar thinking, all we need to change is blocks_before_turn and max_in_direction for the given crucible where\u00a0for:</p>\n<ul>\n<li>\n<strong><em>normal crucible</em></strong>: blocks_before_turn=0, max_in_direction=3</li>\n<li>\n<strong><em>ultra crucible: </em></strong>blocks_before_turn=3, max_in_direction=10</li>\n</ul>\n<p>We will try and go for the Dijkstra\u2019s algorithm to solve this one! The idea is that I would like to create memo i.e. a nested dict of dicts which will store heat_loss for the given cell for all 4 directions!</p>\n<p>Something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zODE9y2vAcF91EOrQNpj9w.png\"></figure><p>And to simplify our crucible turning, we can just define a map: ALLOWED_CRUCIBLE_TURNS to keep a track\u00a0of:</p>\n<pre>ALLOWED_CRUCIBLE_TURNS = {<br>    Direction.RIGHT: [Direction.UP, Direction.DOWN],<br>    Direction.LEFT: [Direction.UP, Direction.DOWN],<br>    Direction.UP: [Direction.LEFT, Direction.RIGHT],<br>    Direction.DOWN: [Direction.LEFT, Direction.RIGHT]<br>}</pre>\n<p>Let\u2019s write some\u00a0code:</p>\n<p>First, we initialize a nested defaultdict memo with sys.maxsize as the default value. This dictionary will store the minimum heat loss for each position and direction.</p>\n<p>The use of sys.maxsize is a common trick in algorithms that need to find a minimum value - it's the largest possible integer in Python, so any real heat loss will be less than\u00a0this.</p>\n<pre># Initialize heat loss dictionary with max values for each direction<br>memo = defaultdict(lambda: defaultdict(lambda: sys.maxsize))</pre>\n<p>Next, we initialize the heat loss for each direction at the starting position (0, 0) to be 0. This makes sense because we haven\u2019t moved the crucible yet, so there\u2019s no heat\u00a0loss.</p>\n<pre>for direction in Direction:<br>  memo[(0, 0)][direction] = 0</pre>\n<p>We can then create a priority queue pq to manage the positions we need to explore. The priority queue is a perfect data structure for <strong>Dijkstra's algorithm</strong> because it allows us to efficiently get the position with the <strong>smallest heat\u00a0loss</strong>.</p>\n<p>Our pq will store (heat_loss, position, dir_name) where it will be sorted wrt to <em>heat_loss. </em>We can seed the queue with all possible directions from the starting position i.e: <strong>RIGHT</strong> and\u00a0<strong>DOWN</strong>:</p>\n<pre># Initialize the priority queue for Dijkstra's algorithm<br>pq = PriorityQueue()<br><br># seed pq with all possible directions from the starting position<br>pq.put((0, (0, 0), Direction.RIGHT.name))<br>pq.put((0, (0, 0), Direction.DOWN.name))</pre>\n<p>Now, all we need to do\u00a0is:</p>\n<ul>\n<li>continually take the position with the smallest heat loss from the queue and explore new positions from\u00a0there</li>\n<li>if the new position\u2019s heat loss is less than the currently known minimum for that position and direction, we update the minimum and add the new position to the\u00a0queue.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*ILNsqUT6rK5gGqyNsEUq1Q.png\"></figure><p>Once we are done with this, our memo will have min(heat_loss) from all 4 directions for each cell, something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ayANZkHBUOqd54tuQl-s7A.png\"><figcaption>For (12, 12), we have 4 values: 104, 104, 102,\u00a0102</figcaption></figure><p>All we need to do is, return the minimun\u00a0value!</p>\n<p>Let\u2019s update our base case now for Part\u00a02?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/880/1*1fAUkceIy5qYMP1y1_hz0g.png\"></figure><p>Let\u2019s run\u00a0it?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>\u2705 get_min_heat_loss_path() tests passed for Crucible!<br>\u2705 get_min_heat_loss_path() tests passed for Ultra Crucible!<br><br>[Done] exited with code=0 in 0.227 seconds</pre>\n<p>We can now run for Part 2 for ultra crucible with values: blocks_before_turn=3, max_in_direction=10</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/768/1*83NF71L3n-qYZ4AeWQN5vA.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>\u2757\ufe0f\u2757\ufe0f Minimum heat loss for Ultra Crucible: XXX<br><br>[Done] exited with code=0 in 1.337 seconds</pre>\n<p>We have an answer! Let\u2019s input this in our answer box,\u00a0and:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Q-bwTP-vYtDcHwB-eQSYjw.png\"><figcaption>\ud83c\udf1f</figcaption></figure><p>Here\u2019s our final code till now, <em>I am keeping inline comments in for the understanding of the\u00a0reader:</em></p>\n<pre># Day 17: Clumsy Crucible<br><br>import sys<br>from enum import Enum<br>from queue import PriorityQueue<br>from collections import defaultdict<br><br><br># Define the Direction Enum for clarity and ease of use<br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br># Define allowed turns for the crucible from each direction<br>ALLOWED_CRUCIBLE_TURNS = {<br>    Direction.RIGHT: [Direction.UP, Direction.DOWN],<br>    Direction.LEFT: [Direction.UP, Direction.DOWN],<br>    Direction.UP: [Direction.LEFT, Direction.RIGHT],<br>    Direction.DOWN: [Direction.LEFT, Direction.RIGHT],<br>}<br><br><br># Function to find the minimum heat loss for moving the crucible<br>def find_min_heat_loss(grid, blocks_before_turn, max_in_direction):<br>    # Initialize distance dictionary with max values for each direction<br>    memo = defaultdict(lambda: defaultdict(lambda: sys.maxsize))<br><br>    for direction in Direction:<br>        memo[(0, 0)][direction] = 0<br><br>    # Initialize the priority queue for Dijkstra's algorithm<br>    pq = PriorityQueue()<br><br>    # seed pq with all possible directions from the starting position<br>    pq.put((0, (0, 0), Direction.RIGHT.name))<br>    pq.put((0, (0, 0), Direction.DOWN.name))<br><br>    while not pq.empty():<br>        heat_loss, position, dir_name = pq.get()<br>        direction = Direction[dir_name]  # Convert back to Direction enum<br><br>        # Skip if the current path's heat loss is not better than already known<br>        if heat_loss &gt; memo[position][direction]:<br>            continue<br><br>        x, y = position<br>        for block in range(max_in_direction):<br>            # Move in the current direction<br>            dx, dy = direction.value<br>            x, y = x + dx, y + dy<br><br>            # Check if the new position is out of bounds<br>            if x &lt; 0 or x &gt;= len(grid[0]) or y &lt; 0 or y &gt;= len(grid):<br>                break<br><br>            # Accumulate heat loss<br>            heat_loss += grid[y][x]<br><br>            # Check if the crucible has moved the required blocks before turning<br>            if block &lt; blocks_before_turn:<br>                continue<br><br>            # Explore new directions from the current position<br>            for new_dir in ALLOWED_CRUCIBLE_TURNS[direction]:<br>                if heat_loss &lt; memo[(x, y)][new_dir]:<br>                    memo[(x, y)][new_dir] = heat_loss<br>                    pq.put((heat_loss, (x, y), new_dir.name))<br><br>    # Return the minimum heat loss to reach the bottom-right corner<br>    return min(memo[(len(grid[0]) - 1, len(grid) - 1)].values())<br><br><br>def parse_grid(input_str):<br>    return [[int(x) for x in line] for line in input_str.split(\"\\n\")]<br><br><br>def part_one():<br>    with open(\"day_17/input.txt\", \"r\") as f:<br>        grid = parse_grid(f.read())<br>    min_heat_loss = find_min_heat_loss(grid, 0, 3)<br>    print(f\"\u2757\ufe0f Minimum heat loss for Normal Crucible: {min_heat_loss}\")<br><br><br>def part_two():<br>    with open(\"day_17/input.txt\", \"r\") as f:<br>        grid = parse_grid(f.read())<br>    min_heat_loss = find_min_heat_loss(grid, 3, 10)<br>    print(f\"\u2757\ufe0f\u2757\ufe0f Minimum heat loss for Ultra Crucible: {min_heat_loss}\")<br><br><br>def test_get_min_heat_loss_path_normal_crucible():<br>    input_str = \"\"\"2413432311323<br>3215453535623<br>3255245654254<br>3446585845452<br>4546657867536<br>1438598798454<br>4457876987766<br>3637877979653<br>4654967986887<br>4564679986453<br>1224686865563<br>2546548887735<br>4322674655533\"\"\"<br>    grid = parse_grid(input_str)<br>    min_heat_loss = find_min_heat_loss(grid, 0, 3)<br>    assert min_heat_loss == 102, f\"Expected 102, got {min_heat_loss}\"<br>    print(\"\u2705 get_min_heat_loss_path() tests passed for Crucible!\")<br><br>def test_get_min_heat_loss_path_ultra_crucible():<br>    input_str = \"\"\"2413432311323<br>3215453535623<br>3255245654254<br>3446585845452<br>4546657867536<br>1438598798454<br>4457876987766<br>3637877979653<br>4654967986887<br>4564679986453<br>1224686865563<br>2546548887735<br>4322674655533\"\"\"<br>    grid = parse_grid(input_str)<br>    min_heat_loss = find_min_heat_loss(grid, 3, 10)<br>    assert min_heat_loss == 94, f\"Expected 94, got {min_heat_loss}\"<br>    print(\"\u2705 get_min_heat_loss_path() tests passed for Ultra Crucible!\")<br><br><br>if __name__ == \"__main__\":<br>    test_get_min_heat_loss_path_normal_crucible()<br>    part_one()<br><br>    test_get_min_heat_loss_path_ultra_crucible()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=2aade00ab25e\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*yySJqIpnZupAF8I0\"><figcaption>Clumsy Crucible (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/17\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>The lava starts flowing rapidly once the Lava Production Facility is operational. As you leave, the reindeer offers you a parachute, allowing you to quickly reach Gear\u00a0Island.</blockquote>\n<blockquote>As you descend, your bird\u2019s-eye view of Gear Island reveals why you had trouble finding anyone on your way up: half of Gear Island is empty, but the half below you is a giant factory\u00a0city!</blockquote>\n<blockquote>You land near the gradually-filling pool of lava at the base of your new lavafall. Lavaducts will eventually carry the lava throughout the city, but to make use of it immediately, Elves are loading it into large <a href=\"https://en.wikipedia.org/wiki/Crucible\">crucibles</a> on\u00a0wheels.</blockquote>\n<blockquote>The crucibles are top-heavy and pushed by hand. Unfortunately, the crucibles become very difficult to steer at high speeds, and so it can be hard to go in a straight line for very\u00a0long.</blockquote>\n<blockquote>To get Desert Island the machine parts it needs as soon as possible, you\u2019ll need to find the best way to get the crucible from the lava pool to the machine parts factory. To do this, you need to minimize heat loss while choosing a route that doesn\u2019t require the crucible to go in a straight linefor too\u00a0long.</blockquote>\n<blockquote>Fortunately, the Elves here have a map (your puzzle input) that uses traffic patterns, ambient temperature, and hundreds of other parameters to calculate exactly how much heat loss can be expected for a crucible entering any particular city\u00a0block.</blockquote>\n<blockquote>For example:</blockquote>\n<blockquote>2413432311323<br>3215453535623<br>3255245654254<br>3446585845452<br>4546657867536<br>1438598798454<br>4457876987766<br>3637877979653<br>4654967986887<br>4564679986453<br>1224686865563<br>2546548887735<br>4322674655533</blockquote>\n<blockquote>Each city block is marked by a single digit that represents the amount of heat loss if the crucible enters that block. The starting point, the lava pool, is the top-left city block; the destination, the machine parts factory, is the bottom-right city block. (Because you already start in the top-left block, you don\u2019t incur that block\u2019s heat loss unless you leave that block and then return to\u00a0it.)</blockquote>\n<blockquote>Because it is difficult to keep the top-heavy crucible going in a straight line for very long, it can move at most three blocks in a single direction before it must turn 90 degrees left or right. The crucible also can\u2019t reverse direction; after entering each city block, it may only turn left, continue straight, or turn\u00a0right.</blockquote>\n<blockquote>One way to minimize heat loss is this\u00a0path:</blockquote>\n<blockquote>2&gt;&gt;34^&gt;&gt;&gt;1323<br>32v&gt;&gt;&gt;35v5623<br>32552456v&gt;&gt;54<br>3446585845v52<br>4546657867v&gt;6<br>14385987984v4<br>44578769877v6<br>36378779796v&gt;<br>465496798688v<br>456467998645v<br>12246868655&lt;v<br>25465488877v5<br>43226746555v&gt;</blockquote>\n<blockquote>This path never moves more than three consecutive blocks in the same direction and incurs a heat loss of only\u00a0102.</blockquote>\n<blockquote>Directing the crucible from the lava pool to the machine parts factory, but not moving more than three consecutive blocks in the same direction, what is the least heat loss it can\u00a0incur?</blockquote>\n<blockquote>Yay! Lava Production Facility is operational!</blockquote>\n<p>Seems like now we need to find the best way to get the lava crucible from the lava pool to the machine parts\u00a0factory!</p>\n<p>We need to <strong><em>minimize </em></strong>heat loss by <strong>NOT</strong> taking a route with a long straight line as supposedly, crucibles become difficult to steer at high speed?! Well, that\u2019s an interesting limitation.</p>\n<p>So, to solve this, we are given a map with traffic patterns, ambient temperature and hundred of other params to help us calculate expected heatloss for the crucible while entering any city block, that look something like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1016/1*CmYlpzrbuOK0vG7RtHQPwQ.png\"></figure><p><strong>\ud83d\udca1\ufffdConditions to remember:</strong></p>\n<ul>\n<li>Because you already start in the <strong>top-left block</strong>, you <strong>don\u2019t</strong> incur that block\u2019s heat loss unless you leave that block and then return to\u00a0it!</li>\n<li>Because it is difficult to keep the top-heavy crucible going in a straight line for very long, it can move <strong>at most three blocks</strong> in a <strong>single direction</strong> before it must turn <strong>90 degrees left or\u00a0right.</strong>\n</li>\n<li>The crucible also <strong>can\u2019t reverse direction</strong>; after entering each city block, it may only <strong>turn left, continue straight, or turn\u00a0right</strong>.</li>\n</ul>\n<p>So, let\u2019s see for the given base case example, what can be a way to minimize the heat loss in the\u00a0path?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5zgsgBaC0KBm6JXWMl_CDg.gif\"></figure><p>This path never moves more than three consecutive blocks in the same direction. Here we incur a total heat loss of <strong>102\u00a0</strong>units.</p>\n<p>Now we need to find the answer similarly in the puzzle input. First things first, let\u2019s write unit test for base case and try to fix that\u00a0first?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/803/1*fTDdrnXE1FqfGOKG77upSQ.png\"><figcaption>Skelton code</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>Traceback (most recent call last):<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 29, in &lt;module&gt;<br>    test_get_min_heat_loss_path()<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 25, in test_get_min_heat_loss_path<br>    assert min_heat_loss == 102, f\"Expected 102, got {min_heat_loss}\"<br>AssertionError: Expected 102, got 0<br><br>[Done] exited with code=1 in 0.224 seconds</pre>\n<p>Let\u2019s break down the\u00a0problem!</p>\n<blockquote>It seems very similar to the last few problems, where we need to find path from top left to bottom right while obeying some rules and trying to minimize the heat\u00a0loss!</blockquote>\n<p>The naive approach is to just explore all possible paths and then just pick the one with the lowest heat loss, but it will lead to a time complexity of: <strong><em>O(2^(N*M)) </em></strong>which means we will\u00a0have:</p>\n<ul>\n<li>2\u00b9\u2076\u2079 combinations for our base test case here with 13 x 13\u00a0grid</li>\n<li>2\u00b9\u2079\u2078\u2078\u00b9 combinations for puzzle input with a 141 x 141\u00a0grid.</li>\n</ul>\n<p><strong><em>Fun fact? It is estimated that there may be ~2\u00b2\u2075\u2076 atoms in the known universe!</em></strong></p>\n<p>So, you can we the problem with the brute force approach\u00a0here!</p>\n<p>We can reduce our search space by a lot here by following the given constraints!</p>\n<p>\ud83d\udcad One way that crosses my mind is to just do the DFS (Depth first search) by iterating through grid and store result in a var which will update whenever a path reaches bottom right\u00a0like:</p>\n<p><strong>MIN_HEAT_LOSS = min(MIN_HEAT_LOSS, path_heat_loss)</strong></p>\n<p>And during iteration, on each choice just abandon any path that takes our path_heat_loss &gt; MIN_HEAT_LOSS\u00a0! By doing this, we can greatly reduce our search space to opt for more efficient paths on each\u00a0try!</p>\n<p>Let\u2019s write some\u00a0code?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6mirpbc9wQv8qSPCtsw-yg.png\"><figcaption>Shit tons of debugging ensued!</figcaption></figure><p>So, we have written functionally correct code, as I can see the output trending towards the intended result, but the problem is our <strong><em>stack </em></strong>keeps increasing as it backtracks for all possible directions! I wrote a small script to visualize the state of my MIN_HEAT_LOSS_PATH, take a look as it optimises the path quickly at start but then gets caught\u00a0up:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*myypKLXpQZELvZZDSpD69w.gif\"></figure><p>It\u2019s clear that my code as it backtracks, it tries to process same path again as again as in DFS it will keep looping into a subsection of those 2\u00b9\u2076\u2079 combinations as we discussed above!</p>\n<p>To avoid this, we can use memoization to store the minimum heat loss encountered at <strong>each node</strong>. If a path reaches the same node with a higher heat loss than previously recorded, we can just prune that path\u00a0early.</p>\n<p>Adding a simple 2D arraymemo of same size as grid just to keep a track of lowest_heat_loss seen at every iteration:</p>\n<pre>memo = [[float('inf') for _ in range(len(grid[0]))] for _ in range(len(grid))]</pre>\n<p>And we can add a simple check in our code to ensure\u00a0that:</p>\n<pre><br># if heat loss is already greater than min heat loss, continue<br>if next_heat_loss &gt;= memo[next_row][next_col]:<br>  continue</pre>\n<p>Let\u2019s run it?\u00a0And\u2026</p>\n<pre>New min heat loss: 107<br># # # # . . # # # # . . .<br>. . . # # # # . . # . . .<br>. . . . . . . . . # # . .<br>. . . . . . . . . . # # .<br>. . . . . . . . . . . # .<br>. . . . . . . . . . . # #<br>. . . . . . . . . . . . #<br>. . . . . . . . . . . # #<br>. . . . . . . . . . . # .<br>. . . . . . . . . . . # #<br>. . . . . . . . . . . . #<br>. . . . . . . . . . . . #<br>. . . . . . . . . . . . #<br><br>Traceback (most recent call last):<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 112, in &lt;module&gt;<br>    test_get_min_heat_loss_path()<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 107, in test_get_min_heat_loss_path<br>    assert min_heat_loss == 102, f\"Expected 102, got {min_heat_loss}\"<br>AssertionError: Expected 102, got 107<br><br>[Done] exited with code=1 in 0.251 seconds</pre>\n<p>We are getting close! Atleast our runtime suggests that we have reduced our search space by a lot! We should get 102 but we are getting 107\u00a0here.</p>\n<p>Again, some debugging to\u00a0go:</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>Ah! Found it. Our memo is currently just storing 1 dimension of heat_loss but we can basically get to that cell from any direction which may lead to a shorter path overall! We need to store heat_loss for all 4 directions for each\u00a0cell</p>\n<pre># Initialize memoization table with dictionaries<br>memo = [[{d: float('inf') for d in Direction} for _ in range(len(grid[0]))] for _ in range(len(grid))]</pre>\n<p>And our memo condition will be modified\u00a0to:</p>\n<pre># Continue to the next direction if the new path is not better<br>if next_heat_loss &gt; memo[next_row][next_col][direction]:<br>    continue<br>.<br>.<br>.<br># Update memo<br>memo[next_row][next_col][direction] = next_heat_loss  </pre>\n<p>Let\u2019s run the base test\u00a0case?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>\u2705 get_min_heat_loss_path() tests passed!<br><br>[Done] exited with code=0 in 0.726 seconds</pre>\n<p>Yas! Now, let\u2019s load up our puzzle\u00a0input?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>\u2757\ufe0f Minimum heat loss for crucible: XXX<br><br>[Done] exited with code=0 in 0.818 seconds</pre>\n<p>Let\u2019s input the answer\u00a0and\u2026.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iANd1s2bvHp2YSBOxDSdBw.png\"><figcaption>\u2b50\ufe0f</figcaption></figure><p>Our approach is quite messy! I am inclined to also explore this from BFS point of view in next part as I now feel we could have just used Djikstra's algo and called it a day by optimizing for low_heat_loss using a\u00a0heapq.</p>\n<h3>Part Two</h3>\n<blockquote>The crucibles of lava simply aren\u2019t large enough to provide an adequate supply of lava to the machine parts factory. Instead, the Elves are going to upgrade to ultra crucibles.</blockquote>\n<blockquote>Ultra crucibles are even more difficult to steer than normal crucibles. Not only do they have trouble going in a straight line, but they also have trouble\u00a0turning!</blockquote>\n<blockquote>Once an ultra crucible starts moving in a direction, it needs to move a minimum of four blocks in that direction before it can turn (or even before it can stop at the end). However, it will eventually start to get wobbly: an ultra crucible can move a maximum of ten consecutive blocks without\u00a0turning.</blockquote>\n<blockquote>In the above example, an ultra crucible could follow this path to minimize heat\u00a0loss:</blockquote>\n<blockquote>2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;1323<br>32154535v5623<br>32552456v4254<br>34465858v5452<br>45466578v&gt;&gt;&gt;&gt;<br>143859879845v<br>445787698776v<br>363787797965v<br>465496798688v<br>456467998645v<br>122468686556v<br>254654888773v<br>432267465553v</blockquote>\n<blockquote>In the above example, an ultra crucible would incur the minimum possible heat loss of\u00a094.</blockquote>\n<blockquote>Here\u2019s another\u00a0example:</blockquote>\n<blockquote>111111111111<br>999999999991<br>999999999991<br>999999999991<br>999999999991</blockquote>\n<blockquote>Sadly, an ultra crucible would need to take an unfortunate path like this\u00a0one:</blockquote>\n<blockquote>1&gt;&gt;&gt;&gt;&gt;&gt;&gt;1111<br>9999999v9991<br>9999999v9991<br>9999999v9991<br>9999999v&gt;&gt;&gt;&gt;</blockquote>\n<blockquote>This route causes the ultra crucible to incur the minimum possible heat loss of\u00a071.</blockquote>\n<blockquote>Directing the ultra crucible from the lava pool to the machine parts factory, what is the least heat loss it can\u00a0incur?</blockquote>\n<p>So! We now have <strong>Ultra Crucibles!</strong></p>\n<p>It seems like we need to modifty our code to handle the new conditions:</p>\n<ul>\n<li>once it starts moving in a direction, it needs to move a <strong>minimum of four blocks in that direction</strong> before it can turn.<br>- or even before it can stop at the\u00a0end.</li>\n<li>can move a <strong>maximum of ten consecutive blocks</strong> without\u00a0turning.</li>\n</ul>\n<p>So, for the same example like in last part, here\u2019s how the traversal will look like for an Ultra Crucible:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*7djuAO8y7gNYz-uE5XyEgw.gif\"></figure><p>Now, using the similar thinking, all we need to change is blocks_before_turn and max_in_direction for the given crucible where\u00a0for:</p>\n<ul>\n<li>\n<strong><em>normal crucible</em></strong>: blocks_before_turn=0, max_in_direction=3</li>\n<li>\n<strong><em>ultra crucible: </em></strong>blocks_before_turn=3, max_in_direction=10</li>\n</ul>\n<p>We will try and go for the Dijkstra\u2019s algorithm to solve this one! The idea is that I would like to create memo i.e. a nested dict of dicts which will store heat_loss for the given cell for all 4 directions!</p>\n<p>Something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zODE9y2vAcF91EOrQNpj9w.png\"></figure><p>And to simplify our crucible turning, we can just define a map: ALLOWED_CRUCIBLE_TURNS to keep a track\u00a0of:</p>\n<pre>ALLOWED_CRUCIBLE_TURNS = {<br>    Direction.RIGHT: [Direction.UP, Direction.DOWN],<br>    Direction.LEFT: [Direction.UP, Direction.DOWN],<br>    Direction.UP: [Direction.LEFT, Direction.RIGHT],<br>    Direction.DOWN: [Direction.LEFT, Direction.RIGHT]<br>}</pre>\n<p>Let\u2019s write some\u00a0code:</p>\n<p>First, we initialize a nested defaultdict memo with sys.maxsize as the default value. This dictionary will store the minimum heat loss for each position and direction.</p>\n<p>The use of sys.maxsize is a common trick in algorithms that need to find a minimum value - it's the largest possible integer in Python, so any real heat loss will be less than\u00a0this.</p>\n<pre># Initialize heat loss dictionary with max values for each direction<br>memo = defaultdict(lambda: defaultdict(lambda: sys.maxsize))</pre>\n<p>Next, we initialize the heat loss for each direction at the starting position (0, 0) to be 0. This makes sense because we haven\u2019t moved the crucible yet, so there\u2019s no heat\u00a0loss.</p>\n<pre>for direction in Direction:<br>  memo[(0, 0)][direction] = 0</pre>\n<p>We can then create a priority queue pq to manage the positions we need to explore. The priority queue is a perfect data structure for <strong>Dijkstra's algorithm</strong> because it allows us to efficiently get the position with the <strong>smallest heat\u00a0loss</strong>.</p>\n<p>Our pq will store (heat_loss, position, dir_name) where it will be sorted wrt to <em>heat_loss. </em>We can seed the queue with all possible directions from the starting position i.e: <strong>RIGHT</strong> and\u00a0<strong>DOWN</strong>:</p>\n<pre># Initialize the priority queue for Dijkstra's algorithm<br>pq = PriorityQueue()<br><br># seed pq with all possible directions from the starting position<br>pq.put((0, (0, 0), Direction.RIGHT.name))<br>pq.put((0, (0, 0), Direction.DOWN.name))</pre>\n<p>Now, all we need to do\u00a0is:</p>\n<ul>\n<li>continually take the position with the smallest heat loss from the queue and explore new positions from\u00a0there</li>\n<li>if the new position\u2019s heat loss is less than the currently known minimum for that position and direction, we update the minimum and add the new position to the\u00a0queue.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*ILNsqUT6rK5gGqyNsEUq1Q.png\"></figure><p>Once we are done with this, our memo will have min(heat_loss) from all 4 directions for each cell, something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ayANZkHBUOqd54tuQl-s7A.png\"><figcaption>For (12, 12), we have 4 values: 104, 104, 102,\u00a0102</figcaption></figure><p>All we need to do is, return the minimun\u00a0value!</p>\n<p>Let\u2019s update our base case now for Part\u00a02?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/880/1*1fAUkceIy5qYMP1y1_hz0g.png\"></figure><p>Let\u2019s run\u00a0it?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>\u2705 get_min_heat_loss_path() tests passed for Crucible!<br>\u2705 get_min_heat_loss_path() tests passed for Ultra Crucible!<br><br>[Done] exited with code=0 in 0.227 seconds</pre>\n<p>We can now run for Part 2 for ultra crucible with values: blocks_before_turn=3, max_in_direction=10</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/768/1*83NF71L3n-qYZ4AeWQN5vA.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>\u2757\ufe0f\u2757\ufe0f Minimum heat loss for Ultra Crucible: XXX<br><br>[Done] exited with code=0 in 1.337 seconds</pre>\n<p>We have an answer! Let\u2019s input this in our answer box,\u00a0and:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Q-bwTP-vYtDcHwB-eQSYjw.png\"><figcaption>\ud83c\udf1f</figcaption></figure><p>Here\u2019s our final code till now, <em>I am keeping inline comments in for the understanding of the\u00a0reader:</em></p>\n<pre># Day 17: Clumsy Crucible<br><br>import sys<br>from enum import Enum<br>from queue import PriorityQueue<br>from collections import defaultdict<br><br><br># Define the Direction Enum for clarity and ease of use<br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br># Define allowed turns for the crucible from each direction<br>ALLOWED_CRUCIBLE_TURNS = {<br>    Direction.RIGHT: [Direction.UP, Direction.DOWN],<br>    Direction.LEFT: [Direction.UP, Direction.DOWN],<br>    Direction.UP: [Direction.LEFT, Direction.RIGHT],<br>    Direction.DOWN: [Direction.LEFT, Direction.RIGHT],<br>}<br><br><br># Function to find the minimum heat loss for moving the crucible<br>def find_min_heat_loss(grid, blocks_before_turn, max_in_direction):<br>    # Initialize distance dictionary with max values for each direction<br>    memo = defaultdict(lambda: defaultdict(lambda: sys.maxsize))<br><br>    for direction in Direction:<br>        memo[(0, 0)][direction] = 0<br><br>    # Initialize the priority queue for Dijkstra's algorithm<br>    pq = PriorityQueue()<br><br>    # seed pq with all possible directions from the starting position<br>    pq.put((0, (0, 0), Direction.RIGHT.name))<br>    pq.put((0, (0, 0), Direction.DOWN.name))<br><br>    while not pq.empty():<br>        heat_loss, position, dir_name = pq.get()<br>        direction = Direction[dir_name]  # Convert back to Direction enum<br><br>        # Skip if the current path's heat loss is not better than already known<br>        if heat_loss &gt; memo[position][direction]:<br>            continue<br><br>        x, y = position<br>        for block in range(max_in_direction):<br>            # Move in the current direction<br>            dx, dy = direction.value<br>            x, y = x + dx, y + dy<br><br>            # Check if the new position is out of bounds<br>            if x &lt; 0 or x &gt;= len(grid[0]) or y &lt; 0 or y &gt;= len(grid):<br>                break<br><br>            # Accumulate heat loss<br>            heat_loss += grid[y][x]<br><br>            # Check if the crucible has moved the required blocks before turning<br>            if block &lt; blocks_before_turn:<br>                continue<br><br>            # Explore new directions from the current position<br>            for new_dir in ALLOWED_CRUCIBLE_TURNS[direction]:<br>                if heat_loss &lt; memo[(x, y)][new_dir]:<br>                    memo[(x, y)][new_dir] = heat_loss<br>                    pq.put((heat_loss, (x, y), new_dir.name))<br><br>    # Return the minimum heat loss to reach the bottom-right corner<br>    return min(memo[(len(grid[0]) - 1, len(grid) - 1)].values())<br><br><br>def parse_grid(input_str):<br>    return [[int(x) for x in line] for line in input_str.split(\"\\n\")]<br><br><br>def part_one():<br>    with open(\"day_17/input.txt\", \"r\") as f:<br>        grid = parse_grid(f.read())<br>    min_heat_loss = find_min_heat_loss(grid, 0, 3)<br>    print(f\"\u2757\ufe0f Minimum heat loss for Normal Crucible: {min_heat_loss}\")<br><br><br>def part_two():<br>    with open(\"day_17/input.txt\", \"r\") as f:<br>        grid = parse_grid(f.read())<br>    min_heat_loss = find_min_heat_loss(grid, 3, 10)<br>    print(f\"\u2757\ufe0f\u2757\ufe0f Minimum heat loss for Ultra Crucible: {min_heat_loss}\")<br><br><br>def test_get_min_heat_loss_path_normal_crucible():<br>    input_str = \"\"\"2413432311323<br>3215453535623<br>3255245654254<br>3446585845452<br>4546657867536<br>1438598798454<br>4457876987766<br>3637877979653<br>4654967986887<br>4564679986453<br>1224686865563<br>2546548887735<br>4322674655533\"\"\"<br>    grid = parse_grid(input_str)<br>    min_heat_loss = find_min_heat_loss(grid, 0, 3)<br>    assert min_heat_loss == 102, f\"Expected 102, got {min_heat_loss}\"<br>    print(\"\u2705 get_min_heat_loss_path() tests passed for Crucible!\")<br><br>def test_get_min_heat_loss_path_ultra_crucible():<br>    input_str = \"\"\"2413432311323<br>3215453535623<br>3255245654254<br>3446585845452<br>4546657867536<br>1438598798454<br>4457876987766<br>3637877979653<br>4654967986887<br>4564679986453<br>1224686865563<br>2546548887735<br>4322674655533\"\"\"<br>    grid = parse_grid(input_str)<br>    min_heat_loss = find_min_heat_loss(grid, 3, 10)<br>    assert min_heat_loss == 94, f\"Expected 94, got {min_heat_loss}\"<br>    print(\"\u2705 get_min_heat_loss_path() tests passed for Ultra Crucible!\")<br><br><br>if __name__ == \"__main__\":<br>    test_get_min_heat_loss_path_normal_crucible()<br>    part_one()<br><br>    test_get_min_heat_loss_path_ultra_crucible()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=2aade00ab25e\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["advent-of-code-2023","coding","python","advent-of-code","programming"]},{"title":"[Day 16] The Floor Will Be Lava // Advent of Code 2023 (Python)","pubDate":"2023-12-24 14:38:13","link":"https://medium.com/@jatinkrmalik/day-16-the-floor-will-be-lava-advent-of-code-2023-python-1b8564d9c6d5?source=rss-ec576e4b06b0------2","guid":"https://medium.com/p/1b8564d9c6d5","author":"Jatin K Malik","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*-QHl1p1sdwzFDm91\"><figcaption>The Floor Will Be\u00a0Lava</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/16\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>With the beam of light completely focused somewhere, the reindeer leads you deeper still into the Lava Production Facility. At some point, you realize that the steel facility walls have been replaced with cave, and the doorways are just cave, and the floor is cave, and you\u2019re pretty sure this is actually just a giant\u00a0cave.</blockquote>\n<blockquote>Finally, as you approach what must be the heart of the mountain, you see a bright light in a cavern up ahead. There, you discover that the beam of light you so carefully focused is emerging from the cavern wall closest to the facility and pouring all of its energy into a contraption on the opposite\u00a0side.</blockquote>\n<blockquote>Upon closer inspection, the contraption appears to be a flat, two-dimensional square grid containing empty space (.), mirrors (/ and \\), and splitters (| and\u00a0-).</blockquote>\n<blockquote>The contraption is aligned so that most of the beam bounces around the grid, but each tile on the grid converts some of the beam\u2019s light into heatto melt the rock in the\u00a0cavern.</blockquote>\n<blockquote>You note the layout of the contraption (your puzzle input). For\u00a0example:</blockquote>\n<blockquote>.|...\\....<br>|.-.\\.....<br>.....|-...<br>........|.<br>..........<br>.........\\<br>..../.\\\\..<br>.-.-/..|..<br>.|....-|.\\<br>..//.|....</blockquote>\n<blockquote>The beam enters in the top-left corner from the left and heading to the right. Then, its behavior depends on what it encounters as it\u00a0moves:</blockquote>\n<blockquote>If the beam encounters empty space (.), it continues in the same direction.</blockquote>\n<blockquote>If the beam encounters a mirror (/ or \\), the beam is reflected 90 degrees depending on the angle of the mirror. For instance, a rightward-moving beam that encounters a / mirror would continue upwardin the mirror's column, while a rightward-moving beam that encounters a \\ mirror would continue downward from the mirror's\u00a0column.</blockquote>\n<blockquote>If the beam encounters the pointy end of a splitter (| or -), the beam passes through the splitter as if the splitter were empty space. For instance, a rightward-moving beam that encounters a - splitter would continue in the same direction.</blockquote>\n<blockquote>If the beam encounters the flat side of a splitter (| or -), the beam is split into two beams going in each of the two directions the splitter's pointy ends are pointing. For instance, a rightward-moving beam that encounters a | splitter would split into two beams: one that continues upward from the splitter's column and one that continues downward from the splitter's column.</blockquote>\n<blockquote>Beams do not interact with other beams; a tile can have many beams passing through it at the same time. A tile is energized if that tile has at least one beam pass through it, reflect in it, or split in\u00a0it.</blockquote>\n<blockquote>In the above example, here is how the beam of light bounces around the contraption:</blockquote>\n<blockquote>&gt;|&lt;&lt;&lt;\\....<br>|v-.\\^....<br>.v...|-&gt;&gt;&gt;<br>.v...v^.|.<br>.v...v^...<br>.v...v^..\\<br>.v../2\\\\..<br>&lt;-&gt;-/vv|..<br>.|&lt;&lt;&lt;2-|.\\<br>.v//.|.v..</blockquote>\n<blockquote>Beams are only shown on empty tiles; arrows indicate the direction of the beams. If a tile contains beams moving in multiple directions, the number of distinct directions is shown instead. Here is the same diagram but instead only showing whether a tile is energized (#) or not\u00a0(.):</blockquote>\n<blockquote>######....<br>.#...#....<br>.#...#####<br>.#...##...<br>.#...##...<br>.#...##...<br>.#..####..<br>########..<br>.#######..<br>.#...#.#..</blockquote>\n<blockquote>Ultimately, in this example, 46 tiles become energized.</blockquote>\n<blockquote>The light isn\u2019t energizing enough tiles to produce lava; to debug the contraption, you need to start by analyzing the current situation. With the beam starting in the top-left heading right, how many tiles end up being energized?</blockquote>\n<p>Seems like we have to simular a light beam entering the grid and then interest the beam with empty space\u00a0. mirrors / \\ and splitters |\u00a0-</p>\n<p>Let\u2019s see the rules and maybe draw a visualization in our whiteboard to understand the test case\u00a0better:</p>\n<blockquote>The beam enters in the top-left corner from the left and heading to the right. Then, its behavior depends on what it encounters as it\u00a0moves:</blockquote>\n<blockquote>- If the beam encounters empty space (.), it continues in the same direction.</blockquote>\n<blockquote>- If the beam encounters a mirror (/ or \\), the beam is reflected 90 degrees depending on the angle of the mirror. For instance, a rightward-moving beam that encounters a / mirror would continue upwardin the mirror's column, while a rightward-moving beam that encounters a \\ mirror would continue downward from the mirror's\u00a0column.</blockquote>\n<blockquote>- If the beam encounters the pointy end of a splitter (| or -), the beam passes through the splitter as if the splitter were empty space. For instance, a rightward-moving beam that encounters a - splitter would continue in the same direction.</blockquote>\n<blockquote>- If the beam encounters the flat side of a splitter (| or -), the beam is split into two beams going in each of the two directions the splitter's pointy ends are pointing. For instance, a rightward-moving beam that encounters a | splitter would split into two beams: one that continues upward from the splitter's column and one that continues downward from the splitter's column.</blockquote>\n<blockquote>Beams do not interact with other\u00a0beams!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1016/1*jKjHaTpjQoMaOOb4O1O-sg.gif\"><figcaption>Here\u2019s how the light beam\u00a0travels!</figcaption></figure><p>So, now all the tiles that our beam will pass through will be <strong>energized </strong><strong># </strong>v/s not\u00a0. meaning our input grid will transform into something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*-IckU73juFoFcPmxqwwF3w.png\"></figure><p>Then all we need to do is, just count the number of energized # tiles and that\u2019s our\u00a0answer!</p>\n<blockquote>\ud83d\udca1See, breaking down the problem along with some visualizations always help! Once you practise enough, you will be able to form with visualisations in your mind and then break down the problem into smaller\u00a0chunks!</blockquote>\n<p>Let\u2019s do the first chunk, where we will try to simulate the light beam travelling from top left (0, 0) and then do the traversal. One important point we can already observe from our viz above is that light beam can get trapped in cycles such as this subsection here:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1016/1*eIWAeNY9Li0fFPaCJbUkgw.gif\"></figure><p>So, we will need to be mindful of these\u00a0cycles!</p>\n<p>Let\u2019s write our base test case\u00a0first?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/911/1*zfYBHDtgCs-eNkQ-MJqGpg.png\"><figcaption>I plan to structure my code like\u00a0this!</figcaption></figure><p>I think we should do a BFS (Breadth first search) to explore all paths in direction of beam as it will allow us to traverse multiple paths in case of beam split or exit early in case beam leaves the grid! We would need some kind of a cycle detector to ensure the same part of beam is not reflecting across again and\u00a0again!</p>\n<p>First, let\u2019s define some\u00a0helpers:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/572/1*49z-kP5Bhti9FBM-raG8wA.png\"></figure><p>Direction to track directions, Tile to track type of tile, and LightBeamNode to just track the idx, last direction and next direction.</p>\n<p>Using these, we can implement our super messy code for simulate_light_beam\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/845/1*oj-vjMBN0PtTwzym1jahpQ.png\"><figcaption>Truly a spagheti code! Had to pop VS Code on vertical montior to snap this\u00a0one!</figcaption></figure><p>Let\u2019s debug and walkover this one\u2026well before that, for my own and my code interpretor sanity, I have decided to rename the \\ and / mirrors to L and R respectively as backslash \\ is a reserved character in Python and I dont want to deal with handling that everywhere!</p>\n<p>So, my input_str is\u00a0now:</p>\n<pre>input_str = \"\"\".|...L....<br>|.-.L.....<br>.....|-...<br>........|.<br>..........<br>.........L<br>....R.LL..<br>.-.-R..|..<br>.|....-|.L<br>..RR.|....\"\"\"</pre>\n<p>And similarly, my Tile enum is\u00a0now:</p>\n<pre>class Tile(Enum):<br>    EMPTY = \".\"<br>    VERTICAL_SPLITTER = \"|\"<br>    HORIZONTAL_SPLITTER = \"-\"<br>    RIGHT_TILTED_MIRROR = \"R\"<br>    LEFT_TILTED_MIRROR = \"L\"</pre>\n<p>Rest of the functionality remains the\u00a0same!</p>\n<p>Continue to debugging, found that my Directions values were wrong\u00a0\ud83d\ude05</p>\n<pre>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)</pre>\n<p>Found another bug here as we can\u2019t just check if a title is visited before, as our light beam can visit a tile from 4 different directions, so in order to not block our light beam from discovering new tiles, we will have to hash a tuple of (tile_idx, last_dir)</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5VTLvFXSZgo53w7DmlrOoA.png\"></figure><p>Something like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*paXNtQZduqLuN5ztfux18w.png\"></figure><p>Perfect! Now once our queue is empty, we should have a set of energized_tiles which may have repeated values for tile_idx but with different directions! All we need to do now is to iterate over tile_idx and update our grid with # and return\u00a0it!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*hUEiZXbunSnYq0aVXmn2IQ.png\"><figcaption>Looks good!</figcaption></figure><p>Now, let\u2019s just count the number of # cells and we should be able to test the base\u00a0case\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/430/1*VDsica0U1HtxUljeyo40Xw.png\"></figure><p>Executing our test function\u2026we have the correct solution!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_16/the_floor_will_be_lava.py\"<br>\u2705 test_get_energized_tiles passed<br><br>[Done] exited with code=0 in 0.268 seconds</pre>\n<p>This seems pretty efficient as we are just tracing light beam, node by node over each tile and we are practising early returns in case of out of bounds or if we have seen the same tile before for same light beam\u00a0node!</p>\n<p>Let\u2019s load up our puzzle input and\u00a0test!</p>\n<blockquote>\u2757\ufe0fRemember, we need to replace \\ and / with L and R in our puzzle input as well! VS Code find and replace for rescue\u00a0here!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*UWYc7DhXlgYsgwSmcFvU-w.png\"><figcaption>Done!</figcaption></figure><p>Let\u2019s run\u00a0this!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/751/1*ub0WSCbca0hNByXqUBPrqg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_16/the_floor_will_be_lava.py\"<br>\u2757\ufe0f Number of energized tiles: XXXX<br><br>[Done] exited with code=0 in 0.234 seconds</pre>\n<p>We got an answer in just <strong>0.234</strong> seconds! Let\u2019s put this in the puzzle answer box and\u00a0\u2026.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*k6iv1X_oepJkzImkF-_zag.png\"><figcaption>\ud83d\ude0e</figcaption></figure><p>Let\u2019s debug the code and see how our grid looks like post light beam simulation:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SFk02w77mh56Ke8RnFgT2A.png\"><figcaption>This is beautiful! I have a strong urge to animate this!\u00a0:D</figcaption></figure><p>Here\u2019s our code till now, it\u2019s a bit spagheti code, I will fix it in final form for Part\u00a02:</p>\n<pre># Day 16 - The Floor will be Lava<br><br>from enum import Enum<br>from collections import deque<br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br>class Tile(Enum):<br>    EMPTY = \".\"<br>    VERTICAL_SPLITTER = \"|\"<br>    HORIZONTAL_SPLITTER = \"-\"<br>    RIGHT_TILTED_MIRROR = \"R\"<br>    LEFT_TILTED_MIRROR = \"L\"<br><br>class LightBeamNode:<br>    def __init__(self, idx, last_dir, next_dir):<br>        self.idx = idx<br>        self.last_dir = last_dir<br>        self.next_dir = next_dir<br><br><br>def get_next_tile_idx(tile_idx, direction):<br>    x, y = tile_idx<br>    dx, dy = direction.value<br>    return (x + dx, y + dy)<br><br>def simulate_light_beam(grid, start_pos=(0,0)):<br>    energized_tiles = set() <br>    queue = deque()<br>    # init position<br>    node = LightBeamNode(start_pos, Direction.LEFT, Direction.RIGHT)<br>    queue.append(node)<br><br>    while queue:<br>        node = queue.popleft()<br><br>        # check if node is out of bounds for grid<br>        if node.idx[0] &lt; 0 or node.idx[0] &gt;= len(grid[0]) or node.idx[1] &lt; 0 or node.idx[1] &gt;= len(grid):<br>            continue<br><br>        if (node.idx, node.last_dir) in energized_tiles:<br>            continue<br>        else:<br>            energized_tiles.add((node.idx, node.last_dir))<br><br>        tile = grid[node.idx[0]][node.idx[1]]<br><br>        if tile == Tile.EMPTY.value:<br>            queue.append(LightBeamNode(get_next_tile_idx(node.idx, node.next_dir), node.last_dir, node.next_dir))<br><br>        elif tile == Tile.VERTICAL_SPLITTER.value:<br>            if node.last_dir in [Direction.UP, Direction.DOWN]:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, node.next_dir), node.last_dir, node.next_dir))<br>            else:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.UP), Direction.DOWN, Direction.UP))<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.DOWN), Direction.UP, Direction.DOWN))<br><br>        elif tile == Tile.HORIZONTAL_SPLITTER.value:<br>            if node.last_dir in [Direction.LEFT, Direction.RIGHT]:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, node.next_dir), node.last_dir, node.next_dir))<br>            else:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.LEFT), Direction.RIGHT, Direction.LEFT))<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.RIGHT), Direction.LEFT, Direction.RIGHT))<br><br>        elif tile == Tile.RIGHT_TILTED_MIRROR.value:<br>            if node.last_dir == Direction.UP:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.LEFT), Direction.RIGHT, Direction.LEFT))<br>            elif node.last_dir == Direction.RIGHT:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.DOWN), Direction.UP, Direction.DOWN))<br>            elif node.last_dir == Direction.DOWN:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.RIGHT), Direction.LEFT, Direction.RIGHT))<br>            elif node.last_dir == Direction.LEFT:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.UP), Direction.DOWN, Direction.UP))<br><br>        elif tile == Tile.LEFT_TILTED_MIRROR.value:<br>            if node.last_dir == Direction.UP:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.RIGHT), Direction.LEFT, Direction.RIGHT))<br>            elif node.last_dir == Direction.RIGHT:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.UP), Direction.DOWN, Direction.UP))<br>            elif node.last_dir == Direction.DOWN:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.LEFT), Direction.RIGHT, Direction.LEFT))<br>            elif node.last_dir == Direction.LEFT:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.DOWN), Direction.UP, Direction.DOWN))<br><br>    for tile, _ in energized_tiles:<br>        grid[tile[0]][tile[1]] = \"#\"<br><br>    return grid<br><br><br><br>def get_num_of_energized_tiles(grid):<br>    count = 0<br>    for row in grid:<br>        for tile in row:<br>            if tile == \"#\":<br>                count += 1<br>    return count<br><br>def parse_input(input_str):<br>    grid = []<br>    for line in input_str.splitlines():<br>        grid.append(list(line))<br>    return grid<br><br>def part_one():<br>    with open(\"day_16/input.txt\", \"r\") as f:<br>        input_str = f.read()<br>    grid = parse_input(input_str)<br>    updated_grid = simulate_light_beam(grid)<br>    num_of_energized_tiles = get_num_of_energized_tiles(updated_grid)<br>    print(f\"\u2757\ufe0f Number of energized tiles: {num_of_energized_tiles}\")<br><br>def test_get_energized_tiles():<br>    input_str = \"\"\".|...L....<br>|.-.L.....<br>.....|-...<br>........|.<br>..........<br>.........L<br>....R.LL..<br>.-.-R..|..<br>.|....-|.L<br>..RR.|....\"\"\"<br><br>    grid = parse_input(input_str)<br>    updated_grid = simulate_light_beam(grid)<br>    num_of_energized_tiles = get_num_of_energized_tiles(updated_grid)<br>    assert num_of_energized_tiles == 46, f\"Expected 46, got {num_of_energized_tiles}\"<br>    print(\"\u2705 test_get_energized_tiles passed\")<br><br><br>if __name__ == \"__main__\":<br>    # test_get_energized_tiles()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>As you try to work out what might be wrong, the reindeer tugs on your shirt and leads you to a nearby control panel. There, a collection of buttons lets you align the contraption so that the beam enters from any edge tileand heading away from that edge. (You can choose either of two directions for the beam if it starts on a corner; for instance, if the beam starts in the bottom-right corner, it can start heading either left or\u00a0upward.)</blockquote>\n<blockquote>So, the beam could start on any tile in the top row (heading downward), any tile in the bottom row (heading upward), any tile in the leftmost column (heading right), or any tile in the rightmost column (heading left). To produce lava, you need to find the configuration that energizes as many tiles as possible.</blockquote>\n<blockquote>In the above example, this can be achieved by starting the beam in the fourth tile from the left in the top\u00a0row:</blockquote>\n<blockquote>.|&lt;2&lt;\\....<br>|v-v\\^....<br>.v.v.|-&gt;&gt;&gt;<br>.v.v.v^.|.<br>.v.v.v^...<br>.v.v.v^..\\<br>.v.v/2\\\\..<br>&lt;-2-/vv|..<br>.|&lt;&lt;&lt;2-|.\\<br>.v//.|.v..</blockquote>\n<blockquote>Using this configuration, 51 tiles are energized:</blockquote>\n<blockquote>.#####....<br>.#.#.#....<br>.#.#.#####<br>.#.#.##...<br>.#.#.##...<br>.#.#.##...<br>.#.#####..<br>########..<br>.#######..<br>.#...#.#..</blockquote>\n<blockquote>Find the initial beam configuration that energizes the largest number of tiles; how many tiles are energized in that configuration?</blockquote>\n<p>So\u2026our reindeer friend has just shared\u00a0that:</p>\n<blockquote>A collection of buttons lets you align the contraption so that the beam enters from any edge tileand heading away from that edge. (You can choose either of two directions for the beam if it starts on a corner; for instance, if the beam starts in the bottom-right corner, it can start heading either left or\u00a0upward.)</blockquote>\n<blockquote>Now, as per the question, the beam could start on any tile in the top row (heading downward), any tile in the bottom row (heading upward), any tile in the leftmost column (heading right), or any tile in the rightmost column (heading left). <strong><em>To produce lava, you need to find the configuration that energizes as many tiles as possible.</em></strong>\n</blockquote>\n<p>I am just proud of my part 1 solution as my intuition told me we need to keep a track of prev_direction and next_direction. That part of the code will prove critical\u00a0here!</p>\n<p>Well, this does explode our search space by quite a lot, but given the puzzle input is a 110 x 110 grid, we have 110 + 110 + 108 + 108 = 436 possible configurations for ingress points + 4 extra direction option per corner leading to 440 combinations!</p>\n<p>Looking at how, we were able to produce Part 1 answer in just <strong>0.234 seconds </strong>I am just inclined to run all 440 combinations and just pick the max value of all\u00a0outputs!</p>\n<p>We will need to modify our <em><br></em><em>def</em> simulate_light_beam(grid, start_pos=(0,0)) signature to also accept last_dir, next_dir. Let\u2019s do\u00a0that:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1002/1*fBiZ1TVplpnDChiUsUvtrA.png\"></figure><p>I have set default values to ensure part_one() doesn\u2019t\u00a0break!</p>\n<p>Now, let\u2019s create a new function to basically call those 440 combinations?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/951/1*_pofDwIpc1shpwb7il7CQQ.png\"></figure><p>This utilizes a helper function process_tile that basically just calls simulate_light_beam and then append get_num_of_energized_tiles() output to the\u00a0record:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*_ipKlR3MCG08fa27AuWqvQ.png\"></figure><p>We just return max(energized_tiles_record) at the\u00a0end!</p>\n<p>Let\u2019s write a new test case to test this <em>brute force</em> approach for given test\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/951/1*_kM9Nc2E3AET6XNgEniwAg.png\"></figure><p>Running this\u00a0one:</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_16/the_floor_will_be_lava.py\"<br>\u2705 test_get_max_energized_tiles passed<br><br>[Done] exited with code=0 in 0.214 seconds</pre>\n<p>Not a bad runtime as it would have tested <strong>10+10+8+8=36 combinations</strong> for test\u00a0input!</p>\n<p>Let\u2019s load up our puzzle input and run this one\u00a0\ud83e\udd1e</p>\n<p>And\u2026.</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_16/the_floor_will_be_lava.py\"<br>\u2757\ufe0f\u2757\ufe0f Number of energized tiles: XXXX<br><br>[Done] exited with code=0 in 6.619 seconds</pre>\n<p>We get an answer in <strong>6.619 seconds </strong>not great, not terrible! Let\u2019s check if this is correct\u00a0one?</p>\n<p>And\u2026 \ud83d\ude4c</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*83c4f_EWSAcABevYy5atiQ.png\"><figcaption>\u2b50\ufe0f \u2b50\ufe0f</figcaption></figure><p>Here\u2019s out final\u00a0code:</p>\n<pre># Day 16 - The Floor will be Lava<br><br>from enum import Enum<br>from collections import deque<br><br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br>class Tile(Enum):<br>    EMPTY = \".\"<br>    VERTICAL_SPLITTER = \"|\"<br>    HORIZONTAL_SPLITTER = \"-\"<br>    RIGHT_TILTED_MIRROR = \"R\"<br>    LEFT_TILTED_MIRROR = \"L\"<br><br><br>class LightBeamNode:<br>    def __init__(self, idx, last_dir, next_dir):<br>        self.idx = idx<br>        self.last_dir = last_dir<br>        self.next_dir = next_dir<br><br><br>def get_next_tile_idx(tile_idx, direction):<br>    dx, dy = direction.value<br>    return (tile_idx[0] + dx, tile_idx[1] + dy)<br><br><br>def simulate_light_beam(<br>    grid, start_pos=(0, 0), last_dir=Direction.LEFT, next_dir=Direction.RIGHT<br>):<br>    energized_tiles = set()<br>    queue = deque()<br><br>    # Initialize the light beam's starting position and direction.<br>    node = LightBeamNode(start_pos, last_dir, next_dir)<br>    queue.append(node)<br><br>    while queue:<br>        # Process the next node in the queue.<br>        node = queue.popleft()<br><br>        # Skip processing if the node is out of the grid's bounds.<br>        if (<br>            node.idx[0] &lt; 0<br>            or node.idx[0] &gt;= len(grid[0])<br>            or node.idx[1] &lt; 0<br>            or node.idx[1] &gt;= len(grid)<br>        ):<br>            continue<br><br>        # Skip processing if the tile in this direction has already been energized.<br>        if (node.idx, node.last_dir) in energized_tiles:<br>            continue<br>        else:<br>            energized_tiles.add((node.idx, node.last_dir))<br><br>        # Get the tile at the current node's position.<br>        tile = grid[node.idx[0]][node.idx[1]]<br><br>        # If the tile is empty, propagate the light beam in the same direction.<br>        if tile == Tile.EMPTY.value:<br>            queue.append(<br>                LightBeamNode(<br>                    get_next_tile_idx(node.idx, node.next_dir),<br>                    node.last_dir,<br>                    node.next_dir,<br>                )<br>            )<br><br>        # Handle interaction with vertical splitters.<br>        elif tile == Tile.VERTICAL_SPLITTER.value:<br>            # Continue in the same direction if moving vertically.<br>            if node.last_dir in [Direction.UP, Direction.DOWN]:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, node.next_dir),<br>                        node.last_dir,<br>                        node.next_dir,<br>                    )<br>                )<br><br>            # Split the beam in up and down directions if moving horizontally.<br>            else:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.UP),<br>                        Direction.DOWN,<br>                        Direction.UP,<br>                    )<br>                )<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.DOWN),<br>                        Direction.UP,<br>                        Direction.DOWN,<br>                    )<br>                )<br><br>        # Handle interaction with horizontal splitters.<br>        elif tile == Tile.HORIZONTAL_SPLITTER.value:<br>            # Continue in the same direction if moving horizontally.<br>            if node.last_dir in [Direction.LEFT, Direction.RIGHT]:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, node.next_dir),<br>                        node.last_dir,<br>                        node.next_dir,<br>                    )<br>                )<br><br>            # Split the beam in left and right directions if moving vertically.<br>            else:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.LEFT),<br>                        Direction.RIGHT,<br>                        Direction.LEFT,<br>                    )<br>                )<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.RIGHT),<br>                        Direction.LEFT,<br>                        Direction.RIGHT,<br>                    )<br>                )<br><br>        # Handle interaction with right-tilted mirrors.<br>        elif tile == Tile.RIGHT_TILTED_MIRROR.value:<br>            # Change direction based on the mirror's orientation and the beam's current direction.<br>            if node.last_dir == Direction.UP:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.LEFT),<br>                        Direction.RIGHT,<br>                        Direction.LEFT,<br>                    )<br>                )<br>            elif node.last_dir == Direction.RIGHT:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.DOWN),<br>                        Direction.UP,<br>                        Direction.DOWN,<br>                    )<br>                )<br>            elif node.last_dir == Direction.DOWN:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.RIGHT),<br>                        Direction.LEFT,<br>                        Direction.RIGHT,<br>                    )<br>                )<br>            elif node.last_dir == Direction.LEFT:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.UP),<br>                        Direction.DOWN,<br>                        Direction.UP,<br>                    )<br>                )<br><br>        # Handle interaction with left-tilted mirrors.<br>        elif tile == Tile.LEFT_TILTED_MIRROR.value:<br>            # Change direction based on the mirror's orientation and the beam's current direction.<br>            if node.last_dir == Direction.UP:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.RIGHT),<br>                        Direction.LEFT,<br>                        Direction.RIGHT,<br>                    )<br>                )<br>            elif node.last_dir == Direction.RIGHT:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.UP),<br>                        Direction.DOWN,<br>                        Direction.UP,<br>                    )<br>                )<br>            elif node.last_dir == Direction.DOWN:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.LEFT),<br>                        Direction.RIGHT,<br>                        Direction.LEFT,<br>                    )<br>                )<br>            elif node.last_dir == Direction.LEFT:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.DOWN),<br>                        Direction.UP,<br>                        Direction.DOWN,<br>                    )<br>                )<br><br>    # Create a new grid representation showing the energized tiles.<br>    new_grid = [<br>        [Tile.EMPTY.value for _ in range(len(grid[0]))] for _ in range(len(grid))<br>    ]<br><br>    # Mark energized tiles in the new grid.<br>    for tile, _ in energized_tiles:<br>        new_grid[tile[0]][tile[1]] = \"#\"<br><br>    return new_grid<br><br><br>def process_tile(grid, tile, last_dir, next_dir, record):<br>    updated_grid = simulate_light_beam(<br>        grid, start_pos=tile, last_dir=last_dir, next_dir=next_dir<br>    )<br>    record.append(sum(tile == \"#\" for row in updated_grid for tile in row))<br><br><br>def get_max_energized_tiles(grid):<br>    energized_tiles_record = []<br><br>    grid_corners = [<br>        (0, 0),<br>        (0, len(grid[0]) - 1),<br>        (len(grid) - 1, 0),<br>        (len(grid) - 1, len(grid[0]) - 1),<br>    ]<br><br>    directions = [Direction.LEFT, Direction.UP, Direction.RIGHT, Direction.DOWN]<br><br>    # Process corners<br>    for corner in grid_corners:<br>        for i in range(2):<br>            process_tile(<br>                grid,<br>                corner,<br>                directions[i * 2],<br>                directions[i * 2 + 1],<br>                energized_tiles_record,<br>            )<br><br>    # Process edges without corners<br>    for i in range(1, len(grid[0]) - 1):  # Top and bottom rows<br>        process_tile(grid, (0, i), Direction.UP, Direction.DOWN, energized_tiles_record)<br>        process_tile(<br>            grid,<br>            (len(grid) - 1, i),<br>            Direction.DOWN,<br>            Direction.UP,<br>            energized_tiles_record,<br>        )<br><br>    for i in range(1, len(grid) - 1):  # Left and right columns<br>        process_tile(<br>            grid, (i, 0), Direction.LEFT, Direction.RIGHT, energized_tiles_record<br>        )<br>        process_tile(<br>            grid,<br>            (i, len(grid[0]) - 1),<br>            Direction.RIGHT,<br>            Direction.LEFT,<br>            energized_tiles_record,<br>        )<br><br>    return max(energized_tiles_record)<br><br><br>def parse_input(input_str):<br>    grid = []<br>    for line in input_str.splitlines():<br>        grid.append(list(line))<br>    return grid<br><br><br>def part_one():<br>    with open(\"day_16/input.txt\", \"r\") as f:<br>        input_str = f.read()<br>    grid = parse_input(input_str)<br>    updated_grid = simulate_light_beam(grid)<br>    num_of_energized_tiles = sum(tile == \"#\" for row in updated_grid for tile in row)<br>    print(f\"\u2757\ufe0f Number of energized tiles: {num_of_energized_tiles}\")<br><br><br>def part_two():<br>    with open(\"day_16/input.txt\", \"r\") as f:<br>        input_str = f.read()<br>    grid = parse_input(input_str)<br>    maximum_energized_tiles = get_max_energized_tiles(grid)<br>    print(f\"\u2757\ufe0f\u2757\ufe0f Number of energized tiles: {maximum_energized_tiles}\")<br><br><br>def test_get_max_energized_tiles():<br>    input_str = \"\"\".|...L....<br>|.-.L.....<br>.....|-...<br>........|.<br>..........<br>.........L<br>....R.LL..<br>.-.-R..|..<br>.|....-|.L<br>..RR.|....\"\"\"<br>    grid = parse_input(input_str)<br>    maximum_energized_tiles = get_max_energized_tiles(grid)<br>    assert maximum_energized_tiles == 51, f\"Expected 51, got {maximum_energized_tiles}\"<br>    print(\"\u2705 test_get_max_energized_tiles passed\")<br><br><br>def test_get_energized_tiles():<br>    input_str = \"\"\".|...L....<br>|.-.L.....<br>.....|-...<br>........|.<br>..........<br>.........L<br>....R.LL..<br>.-.-R..|..<br>.|....-|.L<br>..RR.|....\"\"\"<br><br>    grid = parse_input(input_str)<br>    updated_grid = simulate_light_beam(grid)<br>    num_of_energized_tiles = sum(tile == \"#\" for row in updated_grid for tile in row)<br>    assert num_of_energized_tiles == 46, f\"Expected 46, got {num_of_energized_tiles}\"<br>    print(\"\u2705 test_get_energized_tiles passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_get_energized_tiles()<br>    part_one()<br><br>    test_get_max_energized_tiles()<br>    part_two()</pre>\n<p>\ud83c\udf85 I have not fixed extreme nesting in simulate_light_beam\u00a0, if you have made it till here in this post, and are passionate for clean python code, <strong>please raise a PR in my project</strong> and I will <strong>gift</strong> you something in spirit of Merry Christmas! \ud83c\udf84</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1b8564d9c6d5\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*-QHl1p1sdwzFDm91\"><figcaption>The Floor Will Be\u00a0Lava</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/16\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>With the beam of light completely focused somewhere, the reindeer leads you deeper still into the Lava Production Facility. At some point, you realize that the steel facility walls have been replaced with cave, and the doorways are just cave, and the floor is cave, and you\u2019re pretty sure this is actually just a giant\u00a0cave.</blockquote>\n<blockquote>Finally, as you approach what must be the heart of the mountain, you see a bright light in a cavern up ahead. There, you discover that the beam of light you so carefully focused is emerging from the cavern wall closest to the facility and pouring all of its energy into a contraption on the opposite\u00a0side.</blockquote>\n<blockquote>Upon closer inspection, the contraption appears to be a flat, two-dimensional square grid containing empty space (.), mirrors (/ and \\), and splitters (| and\u00a0-).</blockquote>\n<blockquote>The contraption is aligned so that most of the beam bounces around the grid, but each tile on the grid converts some of the beam\u2019s light into heatto melt the rock in the\u00a0cavern.</blockquote>\n<blockquote>You note the layout of the contraption (your puzzle input). For\u00a0example:</blockquote>\n<blockquote>.|...\\....<br>|.-.\\.....<br>.....|-...<br>........|.<br>..........<br>.........\\<br>..../.\\\\..<br>.-.-/..|..<br>.|....-|.\\<br>..//.|....</blockquote>\n<blockquote>The beam enters in the top-left corner from the left and heading to the right. Then, its behavior depends on what it encounters as it\u00a0moves:</blockquote>\n<blockquote>If the beam encounters empty space (.), it continues in the same direction.</blockquote>\n<blockquote>If the beam encounters a mirror (/ or \\), the beam is reflected 90 degrees depending on the angle of the mirror. For instance, a rightward-moving beam that encounters a / mirror would continue upwardin the mirror's column, while a rightward-moving beam that encounters a \\ mirror would continue downward from the mirror's\u00a0column.</blockquote>\n<blockquote>If the beam encounters the pointy end of a splitter (| or -), the beam passes through the splitter as if the splitter were empty space. For instance, a rightward-moving beam that encounters a - splitter would continue in the same direction.</blockquote>\n<blockquote>If the beam encounters the flat side of a splitter (| or -), the beam is split into two beams going in each of the two directions the splitter's pointy ends are pointing. For instance, a rightward-moving beam that encounters a | splitter would split into two beams: one that continues upward from the splitter's column and one that continues downward from the splitter's column.</blockquote>\n<blockquote>Beams do not interact with other beams; a tile can have many beams passing through it at the same time. A tile is energized if that tile has at least one beam pass through it, reflect in it, or split in\u00a0it.</blockquote>\n<blockquote>In the above example, here is how the beam of light bounces around the contraption:</blockquote>\n<blockquote>&gt;|&lt;&lt;&lt;\\....<br>|v-.\\^....<br>.v...|-&gt;&gt;&gt;<br>.v...v^.|.<br>.v...v^...<br>.v...v^..\\<br>.v../2\\\\..<br>&lt;-&gt;-/vv|..<br>.|&lt;&lt;&lt;2-|.\\<br>.v//.|.v..</blockquote>\n<blockquote>Beams are only shown on empty tiles; arrows indicate the direction of the beams. If a tile contains beams moving in multiple directions, the number of distinct directions is shown instead. Here is the same diagram but instead only showing whether a tile is energized (#) or not\u00a0(.):</blockquote>\n<blockquote>######....<br>.#...#....<br>.#...#####<br>.#...##...<br>.#...##...<br>.#...##...<br>.#..####..<br>########..<br>.#######..<br>.#...#.#..</blockquote>\n<blockquote>Ultimately, in this example, 46 tiles become energized.</blockquote>\n<blockquote>The light isn\u2019t energizing enough tiles to produce lava; to debug the contraption, you need to start by analyzing the current situation. With the beam starting in the top-left heading right, how many tiles end up being energized?</blockquote>\n<p>Seems like we have to simular a light beam entering the grid and then interest the beam with empty space\u00a0. mirrors / \\ and splitters |\u00a0-</p>\n<p>Let\u2019s see the rules and maybe draw a visualization in our whiteboard to understand the test case\u00a0better:</p>\n<blockquote>The beam enters in the top-left corner from the left and heading to the right. Then, its behavior depends on what it encounters as it\u00a0moves:</blockquote>\n<blockquote>- If the beam encounters empty space (.), it continues in the same direction.</blockquote>\n<blockquote>- If the beam encounters a mirror (/ or \\), the beam is reflected 90 degrees depending on the angle of the mirror. For instance, a rightward-moving beam that encounters a / mirror would continue upwardin the mirror's column, while a rightward-moving beam that encounters a \\ mirror would continue downward from the mirror's\u00a0column.</blockquote>\n<blockquote>- If the beam encounters the pointy end of a splitter (| or -), the beam passes through the splitter as if the splitter were empty space. For instance, a rightward-moving beam that encounters a - splitter would continue in the same direction.</blockquote>\n<blockquote>- If the beam encounters the flat side of a splitter (| or -), the beam is split into two beams going in each of the two directions the splitter's pointy ends are pointing. For instance, a rightward-moving beam that encounters a | splitter would split into two beams: one that continues upward from the splitter's column and one that continues downward from the splitter's column.</blockquote>\n<blockquote>Beams do not interact with other\u00a0beams!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1016/1*jKjHaTpjQoMaOOb4O1O-sg.gif\"><figcaption>Here\u2019s how the light beam\u00a0travels!</figcaption></figure><p>So, now all the tiles that our beam will pass through will be <strong>energized </strong><strong># </strong>v/s not\u00a0. meaning our input grid will transform into something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*-IckU73juFoFcPmxqwwF3w.png\"></figure><p>Then all we need to do is, just count the number of energized # tiles and that\u2019s our\u00a0answer!</p>\n<blockquote>\ud83d\udca1See, breaking down the problem along with some visualizations always help! Once you practise enough, you will be able to form with visualisations in your mind and then break down the problem into smaller\u00a0chunks!</blockquote>\n<p>Let\u2019s do the first chunk, where we will try to simulate the light beam travelling from top left (0, 0) and then do the traversal. One important point we can already observe from our viz above is that light beam can get trapped in cycles such as this subsection here:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1016/1*eIWAeNY9Li0fFPaCJbUkgw.gif\"></figure><p>So, we will need to be mindful of these\u00a0cycles!</p>\n<p>Let\u2019s write our base test case\u00a0first?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/911/1*zfYBHDtgCs-eNkQ-MJqGpg.png\"><figcaption>I plan to structure my code like\u00a0this!</figcaption></figure><p>I think we should do a BFS (Breadth first search) to explore all paths in direction of beam as it will allow us to traverse multiple paths in case of beam split or exit early in case beam leaves the grid! We would need some kind of a cycle detector to ensure the same part of beam is not reflecting across again and\u00a0again!</p>\n<p>First, let\u2019s define some\u00a0helpers:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/572/1*49z-kP5Bhti9FBM-raG8wA.png\"></figure><p>Direction to track directions, Tile to track type of tile, and LightBeamNode to just track the idx, last direction and next direction.</p>\n<p>Using these, we can implement our super messy code for simulate_light_beam\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/845/1*oj-vjMBN0PtTwzym1jahpQ.png\"><figcaption>Truly a spagheti code! Had to pop VS Code on vertical montior to snap this\u00a0one!</figcaption></figure><p>Let\u2019s debug and walkover this one\u2026well before that, for my own and my code interpretor sanity, I have decided to rename the \\ and / mirrors to L and R respectively as backslash \\ is a reserved character in Python and I dont want to deal with handling that everywhere!</p>\n<p>So, my input_str is\u00a0now:</p>\n<pre>input_str = \"\"\".|...L....<br>|.-.L.....<br>.....|-...<br>........|.<br>..........<br>.........L<br>....R.LL..<br>.-.-R..|..<br>.|....-|.L<br>..RR.|....\"\"\"</pre>\n<p>And similarly, my Tile enum is\u00a0now:</p>\n<pre>class Tile(Enum):<br>    EMPTY = \".\"<br>    VERTICAL_SPLITTER = \"|\"<br>    HORIZONTAL_SPLITTER = \"-\"<br>    RIGHT_TILTED_MIRROR = \"R\"<br>    LEFT_TILTED_MIRROR = \"L\"</pre>\n<p>Rest of the functionality remains the\u00a0same!</p>\n<p>Continue to debugging, found that my Directions values were wrong\u00a0\ud83d\ude05</p>\n<pre>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)</pre>\n<p>Found another bug here as we can\u2019t just check if a title is visited before, as our light beam can visit a tile from 4 different directions, so in order to not block our light beam from discovering new tiles, we will have to hash a tuple of (tile_idx, last_dir)</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5VTLvFXSZgo53w7DmlrOoA.png\"></figure><p>Something like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*paXNtQZduqLuN5ztfux18w.png\"></figure><p>Perfect! Now once our queue is empty, we should have a set of energized_tiles which may have repeated values for tile_idx but with different directions! All we need to do now is to iterate over tile_idx and update our grid with # and return\u00a0it!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*hUEiZXbunSnYq0aVXmn2IQ.png\"><figcaption>Looks good!</figcaption></figure><p>Now, let\u2019s just count the number of # cells and we should be able to test the base\u00a0case\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/430/1*VDsica0U1HtxUljeyo40Xw.png\"></figure><p>Executing our test function\u2026we have the correct solution!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_16/the_floor_will_be_lava.py\"<br>\u2705 test_get_energized_tiles passed<br><br>[Done] exited with code=0 in 0.268 seconds</pre>\n<p>This seems pretty efficient as we are just tracing light beam, node by node over each tile and we are practising early returns in case of out of bounds or if we have seen the same tile before for same light beam\u00a0node!</p>\n<p>Let\u2019s load up our puzzle input and\u00a0test!</p>\n<blockquote>\u2757\ufe0fRemember, we need to replace \\ and / with L and R in our puzzle input as well! VS Code find and replace for rescue\u00a0here!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*UWYc7DhXlgYsgwSmcFvU-w.png\"><figcaption>Done!</figcaption></figure><p>Let\u2019s run\u00a0this!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/751/1*ub0WSCbca0hNByXqUBPrqg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_16/the_floor_will_be_lava.py\"<br>\u2757\ufe0f Number of energized tiles: XXXX<br><br>[Done] exited with code=0 in 0.234 seconds</pre>\n<p>We got an answer in just <strong>0.234</strong> seconds! Let\u2019s put this in the puzzle answer box and\u00a0\u2026.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*k6iv1X_oepJkzImkF-_zag.png\"><figcaption>\ud83d\ude0e</figcaption></figure><p>Let\u2019s debug the code and see how our grid looks like post light beam simulation:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SFk02w77mh56Ke8RnFgT2A.png\"><figcaption>This is beautiful! I have a strong urge to animate this!\u00a0:D</figcaption></figure><p>Here\u2019s our code till now, it\u2019s a bit spagheti code, I will fix it in final form for Part\u00a02:</p>\n<pre># Day 16 - The Floor will be Lava<br><br>from enum import Enum<br>from collections import deque<br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br>class Tile(Enum):<br>    EMPTY = \".\"<br>    VERTICAL_SPLITTER = \"|\"<br>    HORIZONTAL_SPLITTER = \"-\"<br>    RIGHT_TILTED_MIRROR = \"R\"<br>    LEFT_TILTED_MIRROR = \"L\"<br><br>class LightBeamNode:<br>    def __init__(self, idx, last_dir, next_dir):<br>        self.idx = idx<br>        self.last_dir = last_dir<br>        self.next_dir = next_dir<br><br><br>def get_next_tile_idx(tile_idx, direction):<br>    x, y = tile_idx<br>    dx, dy = direction.value<br>    return (x + dx, y + dy)<br><br>def simulate_light_beam(grid, start_pos=(0,0)):<br>    energized_tiles = set() <br>    queue = deque()<br>    # init position<br>    node = LightBeamNode(start_pos, Direction.LEFT, Direction.RIGHT)<br>    queue.append(node)<br><br>    while queue:<br>        node = queue.popleft()<br><br>        # check if node is out of bounds for grid<br>        if node.idx[0] &lt; 0 or node.idx[0] &gt;= len(grid[0]) or node.idx[1] &lt; 0 or node.idx[1] &gt;= len(grid):<br>            continue<br><br>        if (node.idx, node.last_dir) in energized_tiles:<br>            continue<br>        else:<br>            energized_tiles.add((node.idx, node.last_dir))<br><br>        tile = grid[node.idx[0]][node.idx[1]]<br><br>        if tile == Tile.EMPTY.value:<br>            queue.append(LightBeamNode(get_next_tile_idx(node.idx, node.next_dir), node.last_dir, node.next_dir))<br><br>        elif tile == Tile.VERTICAL_SPLITTER.value:<br>            if node.last_dir in [Direction.UP, Direction.DOWN]:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, node.next_dir), node.last_dir, node.next_dir))<br>            else:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.UP), Direction.DOWN, Direction.UP))<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.DOWN), Direction.UP, Direction.DOWN))<br><br>        elif tile == Tile.HORIZONTAL_SPLITTER.value:<br>            if node.last_dir in [Direction.LEFT, Direction.RIGHT]:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, node.next_dir), node.last_dir, node.next_dir))<br>            else:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.LEFT), Direction.RIGHT, Direction.LEFT))<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.RIGHT), Direction.LEFT, Direction.RIGHT))<br><br>        elif tile == Tile.RIGHT_TILTED_MIRROR.value:<br>            if node.last_dir == Direction.UP:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.LEFT), Direction.RIGHT, Direction.LEFT))<br>            elif node.last_dir == Direction.RIGHT:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.DOWN), Direction.UP, Direction.DOWN))<br>            elif node.last_dir == Direction.DOWN:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.RIGHT), Direction.LEFT, Direction.RIGHT))<br>            elif node.last_dir == Direction.LEFT:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.UP), Direction.DOWN, Direction.UP))<br><br>        elif tile == Tile.LEFT_TILTED_MIRROR.value:<br>            if node.last_dir == Direction.UP:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.RIGHT), Direction.LEFT, Direction.RIGHT))<br>            elif node.last_dir == Direction.RIGHT:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.UP), Direction.DOWN, Direction.UP))<br>            elif node.last_dir == Direction.DOWN:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.LEFT), Direction.RIGHT, Direction.LEFT))<br>            elif node.last_dir == Direction.LEFT:<br>                queue.append(LightBeamNode(get_next_tile_idx(node.idx, Direction.DOWN), Direction.UP, Direction.DOWN))<br><br>    for tile, _ in energized_tiles:<br>        grid[tile[0]][tile[1]] = \"#\"<br><br>    return grid<br><br><br><br>def get_num_of_energized_tiles(grid):<br>    count = 0<br>    for row in grid:<br>        for tile in row:<br>            if tile == \"#\":<br>                count += 1<br>    return count<br><br>def parse_input(input_str):<br>    grid = []<br>    for line in input_str.splitlines():<br>        grid.append(list(line))<br>    return grid<br><br>def part_one():<br>    with open(\"day_16/input.txt\", \"r\") as f:<br>        input_str = f.read()<br>    grid = parse_input(input_str)<br>    updated_grid = simulate_light_beam(grid)<br>    num_of_energized_tiles = get_num_of_energized_tiles(updated_grid)<br>    print(f\"\u2757\ufe0f Number of energized tiles: {num_of_energized_tiles}\")<br><br>def test_get_energized_tiles():<br>    input_str = \"\"\".|...L....<br>|.-.L.....<br>.....|-...<br>........|.<br>..........<br>.........L<br>....R.LL..<br>.-.-R..|..<br>.|....-|.L<br>..RR.|....\"\"\"<br><br>    grid = parse_input(input_str)<br>    updated_grid = simulate_light_beam(grid)<br>    num_of_energized_tiles = get_num_of_energized_tiles(updated_grid)<br>    assert num_of_energized_tiles == 46, f\"Expected 46, got {num_of_energized_tiles}\"<br>    print(\"\u2705 test_get_energized_tiles passed\")<br><br><br>if __name__ == \"__main__\":<br>    # test_get_energized_tiles()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>As you try to work out what might be wrong, the reindeer tugs on your shirt and leads you to a nearby control panel. There, a collection of buttons lets you align the contraption so that the beam enters from any edge tileand heading away from that edge. (You can choose either of two directions for the beam if it starts on a corner; for instance, if the beam starts in the bottom-right corner, it can start heading either left or\u00a0upward.)</blockquote>\n<blockquote>So, the beam could start on any tile in the top row (heading downward), any tile in the bottom row (heading upward), any tile in the leftmost column (heading right), or any tile in the rightmost column (heading left). To produce lava, you need to find the configuration that energizes as many tiles as possible.</blockquote>\n<blockquote>In the above example, this can be achieved by starting the beam in the fourth tile from the left in the top\u00a0row:</blockquote>\n<blockquote>.|&lt;2&lt;\\....<br>|v-v\\^....<br>.v.v.|-&gt;&gt;&gt;<br>.v.v.v^.|.<br>.v.v.v^...<br>.v.v.v^..\\<br>.v.v/2\\\\..<br>&lt;-2-/vv|..<br>.|&lt;&lt;&lt;2-|.\\<br>.v//.|.v..</blockquote>\n<blockquote>Using this configuration, 51 tiles are energized:</blockquote>\n<blockquote>.#####....<br>.#.#.#....<br>.#.#.#####<br>.#.#.##...<br>.#.#.##...<br>.#.#.##...<br>.#.#####..<br>########..<br>.#######..<br>.#...#.#..</blockquote>\n<blockquote>Find the initial beam configuration that energizes the largest number of tiles; how many tiles are energized in that configuration?</blockquote>\n<p>So\u2026our reindeer friend has just shared\u00a0that:</p>\n<blockquote>A collection of buttons lets you align the contraption so that the beam enters from any edge tileand heading away from that edge. (You can choose either of two directions for the beam if it starts on a corner; for instance, if the beam starts in the bottom-right corner, it can start heading either left or\u00a0upward.)</blockquote>\n<blockquote>Now, as per the question, the beam could start on any tile in the top row (heading downward), any tile in the bottom row (heading upward), any tile in the leftmost column (heading right), or any tile in the rightmost column (heading left). <strong><em>To produce lava, you need to find the configuration that energizes as many tiles as possible.</em></strong>\n</blockquote>\n<p>I am just proud of my part 1 solution as my intuition told me we need to keep a track of prev_direction and next_direction. That part of the code will prove critical\u00a0here!</p>\n<p>Well, this does explode our search space by quite a lot, but given the puzzle input is a 110 x 110 grid, we have 110 + 110 + 108 + 108 = 436 possible configurations for ingress points + 4 extra direction option per corner leading to 440 combinations!</p>\n<p>Looking at how, we were able to produce Part 1 answer in just <strong>0.234 seconds </strong>I am just inclined to run all 440 combinations and just pick the max value of all\u00a0outputs!</p>\n<p>We will need to modify our <em><br></em><em>def</em> simulate_light_beam(grid, start_pos=(0,0)) signature to also accept last_dir, next_dir. Let\u2019s do\u00a0that:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1002/1*fBiZ1TVplpnDChiUsUvtrA.png\"></figure><p>I have set default values to ensure part_one() doesn\u2019t\u00a0break!</p>\n<p>Now, let\u2019s create a new function to basically call those 440 combinations?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/951/1*_pofDwIpc1shpwb7il7CQQ.png\"></figure><p>This utilizes a helper function process_tile that basically just calls simulate_light_beam and then append get_num_of_energized_tiles() output to the\u00a0record:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/1*_ipKlR3MCG08fa27AuWqvQ.png\"></figure><p>We just return max(energized_tiles_record) at the\u00a0end!</p>\n<p>Let\u2019s write a new test case to test this <em>brute force</em> approach for given test\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/951/1*_kM9Nc2E3AET6XNgEniwAg.png\"></figure><p>Running this\u00a0one:</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_16/the_floor_will_be_lava.py\"<br>\u2705 test_get_max_energized_tiles passed<br><br>[Done] exited with code=0 in 0.214 seconds</pre>\n<p>Not a bad runtime as it would have tested <strong>10+10+8+8=36 combinations</strong> for test\u00a0input!</p>\n<p>Let\u2019s load up our puzzle input and run this one\u00a0\ud83e\udd1e</p>\n<p>And\u2026.</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_16/the_floor_will_be_lava.py\"<br>\u2757\ufe0f\u2757\ufe0f Number of energized tiles: XXXX<br><br>[Done] exited with code=0 in 6.619 seconds</pre>\n<p>We get an answer in <strong>6.619 seconds </strong>not great, not terrible! Let\u2019s check if this is correct\u00a0one?</p>\n<p>And\u2026 \ud83d\ude4c</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*83c4f_EWSAcABevYy5atiQ.png\"><figcaption>\u2b50\ufe0f \u2b50\ufe0f</figcaption></figure><p>Here\u2019s out final\u00a0code:</p>\n<pre># Day 16 - The Floor will be Lava<br><br>from enum import Enum<br>from collections import deque<br><br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br>class Tile(Enum):<br>    EMPTY = \".\"<br>    VERTICAL_SPLITTER = \"|\"<br>    HORIZONTAL_SPLITTER = \"-\"<br>    RIGHT_TILTED_MIRROR = \"R\"<br>    LEFT_TILTED_MIRROR = \"L\"<br><br><br>class LightBeamNode:<br>    def __init__(self, idx, last_dir, next_dir):<br>        self.idx = idx<br>        self.last_dir = last_dir<br>        self.next_dir = next_dir<br><br><br>def get_next_tile_idx(tile_idx, direction):<br>    dx, dy = direction.value<br>    return (tile_idx[0] + dx, tile_idx[1] + dy)<br><br><br>def simulate_light_beam(<br>    grid, start_pos=(0, 0), last_dir=Direction.LEFT, next_dir=Direction.RIGHT<br>):<br>    energized_tiles = set()<br>    queue = deque()<br><br>    # Initialize the light beam's starting position and direction.<br>    node = LightBeamNode(start_pos, last_dir, next_dir)<br>    queue.append(node)<br><br>    while queue:<br>        # Process the next node in the queue.<br>        node = queue.popleft()<br><br>        # Skip processing if the node is out of the grid's bounds.<br>        if (<br>            node.idx[0] &lt; 0<br>            or node.idx[0] &gt;= len(grid[0])<br>            or node.idx[1] &lt; 0<br>            or node.idx[1] &gt;= len(grid)<br>        ):<br>            continue<br><br>        # Skip processing if the tile in this direction has already been energized.<br>        if (node.idx, node.last_dir) in energized_tiles:<br>            continue<br>        else:<br>            energized_tiles.add((node.idx, node.last_dir))<br><br>        # Get the tile at the current node's position.<br>        tile = grid[node.idx[0]][node.idx[1]]<br><br>        # If the tile is empty, propagate the light beam in the same direction.<br>        if tile == Tile.EMPTY.value:<br>            queue.append(<br>                LightBeamNode(<br>                    get_next_tile_idx(node.idx, node.next_dir),<br>                    node.last_dir,<br>                    node.next_dir,<br>                )<br>            )<br><br>        # Handle interaction with vertical splitters.<br>        elif tile == Tile.VERTICAL_SPLITTER.value:<br>            # Continue in the same direction if moving vertically.<br>            if node.last_dir in [Direction.UP, Direction.DOWN]:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, node.next_dir),<br>                        node.last_dir,<br>                        node.next_dir,<br>                    )<br>                )<br><br>            # Split the beam in up and down directions if moving horizontally.<br>            else:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.UP),<br>                        Direction.DOWN,<br>                        Direction.UP,<br>                    )<br>                )<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.DOWN),<br>                        Direction.UP,<br>                        Direction.DOWN,<br>                    )<br>                )<br><br>        # Handle interaction with horizontal splitters.<br>        elif tile == Tile.HORIZONTAL_SPLITTER.value:<br>            # Continue in the same direction if moving horizontally.<br>            if node.last_dir in [Direction.LEFT, Direction.RIGHT]:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, node.next_dir),<br>                        node.last_dir,<br>                        node.next_dir,<br>                    )<br>                )<br><br>            # Split the beam in left and right directions if moving vertically.<br>            else:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.LEFT),<br>                        Direction.RIGHT,<br>                        Direction.LEFT,<br>                    )<br>                )<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.RIGHT),<br>                        Direction.LEFT,<br>                        Direction.RIGHT,<br>                    )<br>                )<br><br>        # Handle interaction with right-tilted mirrors.<br>        elif tile == Tile.RIGHT_TILTED_MIRROR.value:<br>            # Change direction based on the mirror's orientation and the beam's current direction.<br>            if node.last_dir == Direction.UP:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.LEFT),<br>                        Direction.RIGHT,<br>                        Direction.LEFT,<br>                    )<br>                )<br>            elif node.last_dir == Direction.RIGHT:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.DOWN),<br>                        Direction.UP,<br>                        Direction.DOWN,<br>                    )<br>                )<br>            elif node.last_dir == Direction.DOWN:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.RIGHT),<br>                        Direction.LEFT,<br>                        Direction.RIGHT,<br>                    )<br>                )<br>            elif node.last_dir == Direction.LEFT:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.UP),<br>                        Direction.DOWN,<br>                        Direction.UP,<br>                    )<br>                )<br><br>        # Handle interaction with left-tilted mirrors.<br>        elif tile == Tile.LEFT_TILTED_MIRROR.value:<br>            # Change direction based on the mirror's orientation and the beam's current direction.<br>            if node.last_dir == Direction.UP:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.RIGHT),<br>                        Direction.LEFT,<br>                        Direction.RIGHT,<br>                    )<br>                )<br>            elif node.last_dir == Direction.RIGHT:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.UP),<br>                        Direction.DOWN,<br>                        Direction.UP,<br>                    )<br>                )<br>            elif node.last_dir == Direction.DOWN:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.LEFT),<br>                        Direction.RIGHT,<br>                        Direction.LEFT,<br>                    )<br>                )<br>            elif node.last_dir == Direction.LEFT:<br>                queue.append(<br>                    LightBeamNode(<br>                        get_next_tile_idx(node.idx, Direction.DOWN),<br>                        Direction.UP,<br>                        Direction.DOWN,<br>                    )<br>                )<br><br>    # Create a new grid representation showing the energized tiles.<br>    new_grid = [<br>        [Tile.EMPTY.value for _ in range(len(grid[0]))] for _ in range(len(grid))<br>    ]<br><br>    # Mark energized tiles in the new grid.<br>    for tile, _ in energized_tiles:<br>        new_grid[tile[0]][tile[1]] = \"#\"<br><br>    return new_grid<br><br><br>def process_tile(grid, tile, last_dir, next_dir, record):<br>    updated_grid = simulate_light_beam(<br>        grid, start_pos=tile, last_dir=last_dir, next_dir=next_dir<br>    )<br>    record.append(sum(tile == \"#\" for row in updated_grid for tile in row))<br><br><br>def get_max_energized_tiles(grid):<br>    energized_tiles_record = []<br><br>    grid_corners = [<br>        (0, 0),<br>        (0, len(grid[0]) - 1),<br>        (len(grid) - 1, 0),<br>        (len(grid) - 1, len(grid[0]) - 1),<br>    ]<br><br>    directions = [Direction.LEFT, Direction.UP, Direction.RIGHT, Direction.DOWN]<br><br>    # Process corners<br>    for corner in grid_corners:<br>        for i in range(2):<br>            process_tile(<br>                grid,<br>                corner,<br>                directions[i * 2],<br>                directions[i * 2 + 1],<br>                energized_tiles_record,<br>            )<br><br>    # Process edges without corners<br>    for i in range(1, len(grid[0]) - 1):  # Top and bottom rows<br>        process_tile(grid, (0, i), Direction.UP, Direction.DOWN, energized_tiles_record)<br>        process_tile(<br>            grid,<br>            (len(grid) - 1, i),<br>            Direction.DOWN,<br>            Direction.UP,<br>            energized_tiles_record,<br>        )<br><br>    for i in range(1, len(grid) - 1):  # Left and right columns<br>        process_tile(<br>            grid, (i, 0), Direction.LEFT, Direction.RIGHT, energized_tiles_record<br>        )<br>        process_tile(<br>            grid,<br>            (i, len(grid[0]) - 1),<br>            Direction.RIGHT,<br>            Direction.LEFT,<br>            energized_tiles_record,<br>        )<br><br>    return max(energized_tiles_record)<br><br><br>def parse_input(input_str):<br>    grid = []<br>    for line in input_str.splitlines():<br>        grid.append(list(line))<br>    return grid<br><br><br>def part_one():<br>    with open(\"day_16/input.txt\", \"r\") as f:<br>        input_str = f.read()<br>    grid = parse_input(input_str)<br>    updated_grid = simulate_light_beam(grid)<br>    num_of_energized_tiles = sum(tile == \"#\" for row in updated_grid for tile in row)<br>    print(f\"\u2757\ufe0f Number of energized tiles: {num_of_energized_tiles}\")<br><br><br>def part_two():<br>    with open(\"day_16/input.txt\", \"r\") as f:<br>        input_str = f.read()<br>    grid = parse_input(input_str)<br>    maximum_energized_tiles = get_max_energized_tiles(grid)<br>    print(f\"\u2757\ufe0f\u2757\ufe0f Number of energized tiles: {maximum_energized_tiles}\")<br><br><br>def test_get_max_energized_tiles():<br>    input_str = \"\"\".|...L....<br>|.-.L.....<br>.....|-...<br>........|.<br>..........<br>.........L<br>....R.LL..<br>.-.-R..|..<br>.|....-|.L<br>..RR.|....\"\"\"<br>    grid = parse_input(input_str)<br>    maximum_energized_tiles = get_max_energized_tiles(grid)<br>    assert maximum_energized_tiles == 51, f\"Expected 51, got {maximum_energized_tiles}\"<br>    print(\"\u2705 test_get_max_energized_tiles passed\")<br><br><br>def test_get_energized_tiles():<br>    input_str = \"\"\".|...L....<br>|.-.L.....<br>.....|-...<br>........|.<br>..........<br>.........L<br>....R.LL..<br>.-.-R..|..<br>.|....-|.L<br>..RR.|....\"\"\"<br><br>    grid = parse_input(input_str)<br>    updated_grid = simulate_light_beam(grid)<br>    num_of_energized_tiles = sum(tile == \"#\" for row in updated_grid for tile in row)<br>    assert num_of_energized_tiles == 46, f\"Expected 46, got {num_of_energized_tiles}\"<br>    print(\"\u2705 test_get_energized_tiles passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_get_energized_tiles()<br>    part_one()<br><br>    test_get_max_energized_tiles()<br>    part_two()</pre>\n<p>\ud83c\udf85 I have not fixed extreme nesting in simulate_light_beam\u00a0, if you have made it till here in this post, and are passionate for clean python code, <strong>please raise a PR in my project</strong> and I will <strong>gift</strong> you something in spirit of Merry Christmas! \ud83c\udf84</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1b8564d9c6d5\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["advent-of-code-2023","python","christmas","programming","advent-of-code"]},{"title":"[Day 15] Lens Library // Advent of Code 2023 (Python)","pubDate":"2023-12-23 18:52:54","link":"https://medium.com/@jatinkrmalik/day-15-lens-library-advent-of-code-2023-python-0597f87f340e?source=rss-ec576e4b06b0------2","guid":"https://medium.com/p/0597f87f340e","author":"Jatin K Malik","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*w9P4RSw269Zpn0Zy\"><figcaption>Lens Library (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/15\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>The newly-focused parabolic reflector dish is sending all of the collected light to a point on the side of yet another mountain\u200a\u2014\u200athe largest mountain on Lava Island. As you approach the mountain, you find that the light is being collected by the wall of a large facility embedded in the mountainside.</blockquote>\n<blockquote>You find a door under a large sign that says \u201cLava Production Facility\u201d and next to a smaller sign that says \u201cDanger\u200a\u2014\u200aPersonal Protective Equipment required beyond this\u00a0point\u201d.</blockquote>\n<blockquote>As you step inside, you are immediately greeted by a somewhat panicked reindeer wearing goggles and a loose-fitting <a href=\"https://en.wikipedia.org/wiki/Hard_hat\">hard hat</a>. The reindeer leads you to a shelf of goggles and hard hats (you quickly find some that fit) and then further into the facility. At one point, you pass a button with a faint snout mark and the label \u201cPUSH FOR HELP\u201d. No wonder you were loaded into that <a href=\"https://adventofcode.com/2023/day/1\">trebuchet</a> so\u00a0quickly!</blockquote>\n<blockquote>You pass through a final set of doors surrounded with even more warning signs and into what must be the room that collects all of the light from outside. As you admire the large assortment of lenses available to further focus the light, the reindeer brings you a book titled \u201cInitialization Manual\u201d.</blockquote>\n<blockquote>\u201cHello!\u201d, the book cheerfully begins, apparently unaware of the concerned reindeer reading over your shoulder. \u201cThis procedure will let you bring the Lava Production Facility online\u200a\u2014\u200aall without burning or melting anything unintended!\u201d</blockquote>\n<blockquote>\u201cBefore you begin, please be prepared to use the Holiday ASCII String Helper algorithm (appendix 1A).\u201d You turn to appendix 1A. The reindeer leans closer with interest.</blockquote>\n<blockquote>The HASH algorithm is a way to turn any <a href=\"https://en.wikipedia.org/wiki/String_(computer_science)\">string</a> of characters into a single number in the range 0 to 255. To run the HASH algorithm on a string, start with a current value of 0. Then, for each character in the string starting from the beginning:</blockquote>\n<blockquote>Determine the <a href=\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\">ASCII code</a> for the current character of the\u00a0string.</blockquote>\n<blockquote>Increase the current value by the ASCII code you just determined.</blockquote>\n<blockquote>Set the current value to itself multiplied by\u00a017.</blockquote>\n<blockquote>Set the current value to the <a href=\"https://en.wikipedia.org/wiki/Modulo\">remainder</a> of dividing itself by\u00a0256.</blockquote>\n<blockquote>After following these steps for each character in the string in order, the current value is the output of the HASH algorithm.</blockquote>\n<blockquote>So, to find the result of running the HASH algorithm on the string\u00a0HASH:</blockquote>\n<blockquote>The current value starts at\u00a00.</blockquote>\n<blockquote>The first character is H; its ASCII code is\u00a072.</blockquote>\n<blockquote>The current value increases to\u00a072.</blockquote>\n<blockquote>The current value is multiplied by 17 to become\u00a01224.</blockquote>\n<blockquote>The current value becomes 200 (the remainder of 1224 divided by\u00a0256).</blockquote>\n<blockquote>The next character is A; its ASCII code is\u00a065.</blockquote>\n<blockquote>The current value increases to\u00a0265.</blockquote>\n<blockquote>The current value is multiplied by 17 to become\u00a04505.</blockquote>\n<blockquote>The current value becomes 153 (the remainder of 4505 divided by\u00a0256).</blockquote>\n<blockquote>The next character is S; its ASCII code is\u00a083.</blockquote>\n<blockquote>The current value increases to\u00a0236.</blockquote>\n<blockquote>The current value is multiplied by 17 to become\u00a04012.</blockquote>\n<blockquote>The current value becomes 172 (the remainder of 4012 divided by\u00a0256).</blockquote>\n<blockquote>The next character is H; its ASCII code is\u00a072.</blockquote>\n<blockquote>The current value increases to\u00a0244.</blockquote>\n<blockquote>The current value is multiplied by 17 to become\u00a04148.</blockquote>\n<blockquote>The current value becomes 52 (the remainder of 4148 divided by\u00a0256).</blockquote>\n<blockquote>So, the result of running the HASH algorithm on the string HASH is\u00a052.</blockquote>\n<blockquote>The initialization sequence (your puzzle input) is a comma-separated list of steps to start the Lava Production Facility. Ignore newline characterswhen parsing the initialization sequence. To verify that your HASH algorithm is working, the book offers the sum of the result of running the HASH algorithm on each step in the initialization sequence.</blockquote>\n<blockquote>For example:</blockquote>\n<blockquote>rn=1,cm-,qp=3,cm=2,qp-,pc=4,ot=9,ab=5,pc-,pc=6,ot=7</blockquote>\n<blockquote>This initialization sequence specifies 11 individual steps; the result of running the HASH algorithm on each of the steps is as\u00a0follows:</blockquote>\n<blockquote>rn=1 becomes\u00a030.</blockquote>\n<blockquote>cm- becomes\u00a0253.</blockquote>\n<blockquote>qp=3 becomes\u00a097.</blockquote>\n<blockquote>cm=2 becomes\u00a047.</blockquote>\n<blockquote>qp- becomes\u00a014.</blockquote>\n<blockquote>pc=4 becomes\u00a0180.</blockquote>\n<blockquote>ot=9 becomes\u00a09.</blockquote>\n<blockquote>ab=5 becomes\u00a0197.</blockquote>\n<blockquote>pc- becomes\u00a048.</blockquote>\n<blockquote>pc=6 becomes\u00a0214.</blockquote>\n<blockquote>ot=7 becomes\u00a0231.</blockquote>\n<blockquote>In this example, the sum of these results is 1320. Unfortunately, the reindeer has stolen the page containing the expected verification number and is currently running around the facility with it excitedly.</blockquote>\n<blockquote>Run the HASH algorithm on each step in the initialization sequence. What is the sum of the results? (The initialization sequence is one long line; be careful when copy-pasting it.)</blockquote>\n<p>Intereisting problem! It seems like we need to implement a new hashing algorithm\u200a\u2014\u200a<strong>Holiday ASCII String Helper Algorithm!</strong></p>\n<p>Well, this algo will turn any string of characters into a single number in the range 0 to 255 by starting with a current value of 0. Then, for each character in the string starting from the beginning:</p>\n<ul>\n<li>Determine the <a href=\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\">ASCII code</a> for the current character of the\u00a0string.</li>\n<li>Increase the current value by the ASCII code you just determined.</li>\n<li>Set the current value to itself multiplied by\u00a017.</li>\n<li>Set the current value to the <a href=\"https://en.wikipedia.org/wiki/Modulo\">remainder</a> of dividing itself by\u00a0256.</li>\n</ul>\n<p>Looks pretty straight forward! Let\u2019s write some code? We will start with the base case\u00a0first:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/725/1*nUIxhV9rFPpavxwRjKc_Lg.png\"></figure><p>The code seems pretty simple to implement <strong><em>for\u00a0now:</em></strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/501/1*p1Lxnslgpn36_7vWtWkNog.png\"></figure><p>Let\u2019s test our base\u00a0case?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_15/lens_library.py\"<br>\u2705 test_process_sequence Passed<br><br>[Done] exited with code=0 in 0.067 seconds</pre>\n<p>Lets run this for our puzzle input while ensuring all of the sequence is just a 1 line string so we need to ignore new newline characters while\u00a0parsing:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/444/1*ovfiX-cTmKtlBJITUQH2lQ.png\"></figure><p>Let\u2019s run this? This seems just suspiciously easy!\u00a0\ud83d\ude05</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_15/lens_library.py\"<br>\u2757\ufe0f Part One: XXXXX<br><br>[Done] exited with code=0 in 0.067 seconds</pre>\n<p>We have an answer, let\u2019s try it on the puzzle page\u00a0and\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/816/1*U-6onPyytv6IZfdtxPBWsA.png\"><figcaption>\u2705</figcaption></figure><p>Boom! Easy. Let\u2019s go to part 2, here\u2019s our code till now, can\u2019t be anymore efficient!</p>\n<pre># Day 15: Lens Library<br><br>def holiday_helper(step):<br>    current_value = 0<br>    for ch in step:<br>        ascii_code = ord(ch)<br>        current_value += ascii_code<br>        current_value *= 17<br>        current_value %= 256<br><br>    return current_value<br><br><br>def process_sequence(sequence):<br>    sum = 0<br>    for step in sequence.split(\",\"):<br>        sum += holiday_helper(step)<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_15/input.txt\") as f:<br>        sequence = f.read().strip()<br><br>    sum = process_sequence(sequence)<br>    print(f\"\u2757\ufe0f Part One: {sum}\")<br><br>def test_process_sequence():<br>    sequence = \"rn=1,cm-,qp=3,cm=2,qp-,pc=4,ot=9,ab=5,pc-,pc=6,ot=7\"<br>    sum = process_sequence(sequence)<br>    assert sum == 1320, f\"Expected 1320, but got {sum}\"<br>    print(\"\u2705 test_process_sequence Passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_process_sequence()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>You convince the reindeer to bring you the page; the page confirms that your HASH algorithm is\u00a0working.</blockquote>\n<blockquote>The book goes on to describe a series of 256 boxes numbered 0 through 255. The boxes are arranged in a line starting from the point where light enters the facility. The boxes have holes that allow light to pass from one box to the next all the way down the\u00a0line.</blockquote>\n<blockquote>+-----+ +-----+ +-----+<br>Light | Box | | Box |\u00a0... | Box |<br>-----------------------------------------&gt;<br> | 0 | | 1 |\u00a0... | 255 |<br> +-----+ +-----+\u00a0+-----+</blockquote>\n<blockquote>Inside each box, there are several lens slots that will keep a lens correctly positioned to focus light passing through the box. The side of each box has a panel that opens to allow you to insert or remove lenses as necessary.</blockquote>\n<blockquote>Along the wall running parallel to the boxes is a large library containing lenses organized by focal length ranging from 1 through 9. The reindeer also brings you a small handheld <a href=\"https://en.wikipedia.org/wiki/Label_printer\">label\u00a0printer</a>.</blockquote>\n<blockquote>The book goes on to explain how to perform each step in the initialization sequence, a process it calls the Holiday ASCII String Helper Manual Arrangement Procedure, or HASHMAP for\u00a0short.</blockquote>\n<blockquote>Each step begins with a sequence of letters that indicate the label of the lens on which the step operates. The result of running the HASH algorithm on the label indicates the correct box for that\u00a0step.</blockquote>\n<blockquote>The label will be immediately followed by a character that indicates the operation to perform: either an equals sign (=) or a dash\u00a0(-).</blockquote>\n<blockquote>If the operation character is a dash (-), go to the relevant box and remove the lens with the given label if it is present in the box. Then, move any remaining lenses as far forward in the box as they can go without changing their order, filling any space made by removing the indicated lens. (If no lens in that box has the given label, nothing happens.)</blockquote>\n<blockquote>If the operation character is an equals sign (=), it will be followed by a number indicating the focal length of the lens that needs to go into the relevant box; be sure to use the label maker to mark the lens with the label given in the beginning of the step so you can find it later. There are two possible situations:</blockquote>\n<blockquote>If there is already a lens in the box with the same label, replace the old lens with the new lens: remove the old lens and put the new lens in its place, not moving any other lenses in the\u00a0box.</blockquote>\n<blockquote>If there is not already a lens in the box with the same label, add the lens to the box immediately behind any lenses already in the box. Don\u2019t move any of the other lenses when you do this. If there aren\u2019t any lenses in the box, the new lens goes all the way to the front of the\u00a0box.</blockquote>\n<blockquote>Here is the contents of every box after each step in the example initialization sequence\u00a0above:</blockquote>\n<blockquote>After \"rn=1\":<br>Box 0: [rn\u00a01]</blockquote>\n<blockquote>After \"cm-\":<br>Box 0: [rn\u00a01]</blockquote>\n<blockquote>After \"qp=3\":<br>Box 0: [rn 1]<br>Box 1: [qp\u00a03]</blockquote>\n<blockquote>After \"cm=2\":<br>Box 0: [rn 1] [cm 2]<br>Box 1: [qp\u00a03]</blockquote>\n<blockquote>After \"qp-\":<br>Box 0: [rn 1] [cm\u00a02]</blockquote>\n<blockquote>After \"pc=4\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [pc\u00a04]</blockquote>\n<blockquote>After \"ot=9\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [pc 4] [ot\u00a09]</blockquote>\n<blockquote>After \"ab=5\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [pc 4] [ot 9] [ab\u00a05]</blockquote>\n<blockquote>After \"pc-\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [ot 9] [ab\u00a05]</blockquote>\n<blockquote>After \"pc=6\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [ot 9] [ab 5] [pc\u00a06]</blockquote>\n<blockquote>After \"ot=7\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [ot 7] [ab 5] [pc\u00a06]</blockquote>\n<blockquote>All 256 boxes are always present; only the boxes that contain any lenses are shown here. Within each box, lenses are listed from front to back; each lens is shown as its label and focal length in square brackets.</blockquote>\n<blockquote>To confirm that all of the lenses are installed correctly, add up the focusing power of all of the lenses. The focusing power of a single lens is the result of multiplying together:</blockquote>\n<blockquote>One plus the box number of the lens in question.</blockquote>\n<blockquote>The slot number of the lens within the box: 1 for the first lens, 2for the second lens, and so\u00a0on.</blockquote>\n<blockquote>The focal length of the\u00a0lens.</blockquote>\n<blockquote>At the end of the above example, the focusing power of each lens is as\u00a0follows:</blockquote>\n<blockquote>rn: 1 (box 0) * 1 (first slot) * 1 (focal length) =\u00a01</blockquote>\n<blockquote>cm: 1 (box 0) * 2 (second slot) * 2 (focal length) =\u00a04</blockquote>\n<blockquote>ot: 4 (box 3) * 1 (first slot) * 7 (focal length) =\u00a028</blockquote>\n<blockquote>ab: 4 (box 3) * 2 (second slot) * 5 (focal length) =\u00a040</blockquote>\n<blockquote>pc: 4 (box 3) * 3 (third slot) * 6 (focal length) =\u00a072</blockquote>\n<blockquote>So, the above example ends up with a total focusing power of\u00a0145.</blockquote>\n<blockquote>With the help of an over-enthusiastic reindeer in a hard hat, follow the initialization sequence. What is the focusing power of the resulting lens configuration?</blockquote>\n<blockquote><em>You convince the reindeer to bring you the page; the page confirms that your HASH algorithm is\u00a0working.</em></blockquote>\n<p>Well, duh! Here we go, this puzzle is going to get super complex\u00a0now\u2026</p>\n<p>So, the setup is something like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/675/1*Www7KbCoZ3ktNplUfH5IWA.png\"></figure><p>And we have a <strong><em>label\u00a0printer!</em></strong></p>\n<p>Initialization sequence(or Holiday ASCII String Helper Manual Arrangement Procedure or H.A.S.H.M.A.P.) goes on something like\u00a0this:</p>\n<ol>\n<li>Each step begins with a sequence of letters that indicate the label of the lens on which the step operates. <br>-&gt; The result of running the HASH algorithm on the label indicates the correct box for that\u00a0step.</li>\n<li>The label will be immediately followed by a character that indicates the operation to perform: either an equals sign (=) or a dash\u00a0(-).</li>\n<li>If the operation character is a dash (-):<br>* go to the relevant box and remove the lens with the given label if it is present in the box.<br>* move any remaining lenses as far forward in the box as they can go without changing their order, filling any space made by removing the indicated lens.</li>\n<li>If the operation character is an equals sign (=):<br>* it will be followed by a number indicating the focal length of the lens that needs to go into the relevant box<br>* be sure to use the label maker to mark the lens with the label given in the beginning of the step so you can find it\u00a0later.</li>\n</ol>\n<blockquote>There are two possible situations:</blockquote>\n<blockquote>- If there is already a lens in the box with the same label, replace the old lens with the new lens: remove the old lens and put the new lens in its place, not moving any other lenses in the\u00a0box.</blockquote>\n<blockquote>- If there is not already a lens in the box with the same label, add the lens to the box immediately behind any lenses already in the box. Don\u2019t move any of the other lenses when you do this. If there aren\u2019t any lenses in the box, the new lens goes all the way to the front of the\u00a0box.</blockquote>\n<p>This is a mouthfull, let\u2019s do it one by\u00a0one!</p>\n<p>First, we need a new parsing logic for each step of the sequence:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/689/1*RlyIk7rWvUtjqOlWzWJFGw.png\"><figcaption>This should take care of the \u201cOperation\u201d nuance</figcaption></figure><p>Let\u2019s setup some classes for Box and Lens so we can have object embedding for cleaner\u00a0code:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/613/1*JP2hv9IUmEbaBvkZYWWk7w.png\"></figure><p>Now, let\u2019s implement some of the box operations for\u200a\u2014\u200aand =\u00a0!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/839/1*9nAp_zu35eTR0MSZdimHuQ.png\"></figure><p>Now, let\u2019s implement our H.A.S.H.M.A.P function that will utilise our Box methods to do the processing:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/872/1*2o4jjLn9_mQITbhhtWhjiQ.png\"><figcaption>I have added some logging for my own\u00a0sanity!</figcaption></figure><p>Let\u2019s run the test case with the help of our debugger, our final state of BOXES should look like\u00a0this:</p>\n<pre>After \"ot=7\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [ot 7] [ab 5] [pc 6]</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/737/1*EDr-xHyl61TEKG1TIwS7rA.png\"><figcaption>Indeed, it is!\u00a0\ud83d\ude4c</figcaption></figure><p>Post this, all we need to do is, implement a sum function to give us our answer, i.e: <strong>focusing power of the resulting lens configuration</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/637/1*jaBKBtIarf_FaonlkWd4UQ.png\"></figure><p>Let\u2019s test our new base test case as given in the part\u00a02:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*7koJsd2tnYcBBxjEv-Kjig.png\"></figure><p>And\u2026</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_15/lens_library.py\"<br>Lens: rn | ADDED | in box: 0<br>Lens: cm | NOT FOUND | in box: 0<br>Lens: qp | ADDED | in box: 1<br>Lens: cm | ADDED | in box: 0<br>Lens: qp | REMOVED | in box: 1<br>Lens: pc | ADDED | in box: 3<br>Lens: ot | ADDED | in box: 3<br>Lens: ab | ADDED | in box: 3<br>Lens: pc | REMOVED | in box: 3<br>Lens: pc | ADDED | in box: 3<br>Lens: ot | UPDATED | in box: 3<br>\u2705 test_hashmap Passed<br><br>[Done] exited with code=0 in 0.05 seconds</pre>\n<p>Beautiful! Let\u2019s now run this for our puzzle\u00a0input?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/852/1*FbUwOkVh8EwkJMhJnoL_Lw.png\"></figure><blockquote>\ud83d\udca1Remember to not run test_hashmap() before part_two() as it will modify the state of our global BOXES.\u00a0\ud83d\ude05</blockquote>\n<blockquote>I will fix that post verification!</blockquote>\n<p>Let\u2019s remove the logging and just execute the part_two()\u00a0:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_15/lens_library.py\"<br>\u2757\ufe0f\u2757\ufe0f Focusing power of the resulting lens configuration: XXXXXX<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>We got an answer in just sweet <strong>0.073 seconds, </strong>let\u2019s input this in our answer box\u2026..and\u2026. \ud83d\udca5</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/875/1*-O9fB2a5ZM9THFV4029-fw.png\"><figcaption>First try!\u00a0\ud83d\ude0e</figcaption></figure><p>Here\u2019s our final optimized pythonic code with production level quality with inline comments!</p>\n<blockquote>Since I was able to do this one quickly, spent some time writing quality code! You will enjoy reading\u00a0this!</blockquote>\n<pre># Day 15: Lens Library<br><br>from enum import Enum<br><br><br>class Operation(Enum):<br>    DASH = \"-\"<br>    EQUALS = \"=\"<br><br><br># Represents a step in the initialization sequence, parsing its components<br>class Step:<br>    def __init__(self, step):<br>        # Check if the step involves removing a lens (indicated by a dash)<br>        if Operation.DASH.value in step:<br>            self.label, _ = step.split(Operation.DASH.value)<br>            self.operation = Operation.DASH<br>            self.focal_length = None<br><br>        # Check if the step involves adding or updating a lens (indicated by an equals sign)<br>        elif Operation.EQUALS.value in step:<br>            self.label, focal_length = step.split(Operation.EQUALS.value)<br>            self.operation = Operation.EQUALS<br>            self.focal_length = int(focal_length)<br><br>        else:<br>            raise ValueError(f\"Invalid step: {step}\")<br><br><br># Represents a lens with a label and focal length<br>class Lens:<br>    def __init__(self, label, focal_length):<br>        self.label = label<br>        self.focal_length = focal_length<br><br>    def __repr__(self):<br>        return f\"[{self.label} {self.focal_length}]\"<br><br><br># Represents a box that can hold multiple lenses<br>class Box:<br>    def __init__(self, id):<br>        self.id = id<br>        self.lenses = []<br><br>    def find_lens(self, label):<br>        for lens in self.lenses:<br>            if lens.label == label:<br>                return lens<br>        return None<br><br>    def remove_lens(self, label):<br>        lens = self.find_lens(label)<br>        if lens:<br>            self.lenses.remove(lens)<br><br>    def add_or_update_lens(self, lens):<br>        existing_lens = self.find_lens(lens.label)<br>        if existing_lens:<br>            existing_lens.focal_length = lens.focal_length<br>        else:<br>            self.lenses.append(lens)<br><br>    def calc_focusing_power(self):<br>        return sum(<br>            (self.id + 1) * (idx + 1) * lens.focal_length<br>            for idx, lens in enumerate(self.lenses)<br>        )<br><br><br># Represents the entire Lava Production Facility with its boxes<br>class LavaProductionFacility:<br>    def __init__(self):<br>        self.boxes = [Box(id) for id in range(256)]<br><br>    # H.A.S.H.M.A.P. = Holiday ASCII String Helper Manual Arrangement Procedure<br>    def holiday_ascii_string_helper_manual_arrangement_procedure(self, sequence_steps):<br>        for step in sequence_steps:<br>            step_obj = Step(step)<br>            box_id = self.holiday_ascii_string_helper(step_obj.label)<br>            box = self.boxes[box_id]<br><br>            if step_obj.operation == Operation.DASH:<br>                box.remove_lens(step_obj.label)<br>            elif step_obj.operation == Operation.EQUALS:<br>                lens = Lens(step_obj.label, step_obj.focal_length)<br>                box.add_or_update_lens(lens)<br><br>    def sum_focusing_power(self):<br>        return sum(box.calc_focusing_power() for box in self.boxes)<br><br>    @staticmethod<br>    # H.A.S.H. = Holiday ASCII String Helper<br>    def holiday_ascii_string_helper(step):<br>        current_value = 0<br>        for ch in step:<br>            current_value = (current_value + ord(ch)) * 17 % 256<br>        return current_value<br><br>    def get_sequence_hash(self, sequence):<br>        return sum(<br>            self.holiday_ascii_string_helper(step) for step in sequence.split(\",\")<br>        )<br><br><br>def part_one():<br>    with open(\"day_15/input.txt\") as f:<br>        sequence = f.read().strip()<br><br>    facility = LavaProductionFacility()<br>    sum_hash = facility.get_sequence_hash(sequence)<br>    print(f\"\u2757\ufe0f Part One: {sum_hash}\")<br><br><br>def part_two():<br>    with open(\"day_15/input.txt\") as f:<br>        sequence = f.read().strip()<br><br>    facility = LavaProductionFacility()<br>    facility.holiday_ascii_string_helper_manual_arrangement_procedure(<br>        sequence.split(\",\")<br>    )<br>    sum_focusing_power = facility.sum_focusing_power()<br>    print(<br>        f\"\u2757\ufe0f\u2757\ufe0f Focusing power of the resulting lens configuration: {sum_focusing_power}\"<br>    )<br><br><br>def test_hashmap():<br>    sequence = \"rn=1,cm-,qp=3,cm=2,qp-,pc=4,ot=9,ab=5,pc-,pc=6,ot=7\"<br>    facility = LavaProductionFacility()<br>    facility.holiday_ascii_string_helper_manual_arrangement_procedure(<br>        sequence.split(\",\")<br>    )<br>    sum_focusing_power = facility.sum_focusing_power()<br>    assert sum_focusing_power == 145, f\"Expected 145, but got {sum_focusing_power}\"<br>    print(\"\u2705 test_hashmap Passed\")<br><br><br>def test_get_sequence_hash():<br>    sequence = \"rn=1,cm-,qp=3,cm=2,qp-,pc=4,ot=9,ab=5,pc-,pc=6,ot=7\"<br>    facility = LavaProductionFacility()<br>    sum_hash = facility.get_sequence_hash(sequence)<br>    assert sum_hash == 1320, f\"Expected 1320, but got {sum_hash}\"<br>    print(\"\u2705 test_process_sequence Passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_get_sequence_hash()<br>    part_one()<br><br>    test_hashmap()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=0597f87f340e\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*w9P4RSw269Zpn0Zy\"><figcaption>Lens Library (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/15\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>The newly-focused parabolic reflector dish is sending all of the collected light to a point on the side of yet another mountain\u200a\u2014\u200athe largest mountain on Lava Island. As you approach the mountain, you find that the light is being collected by the wall of a large facility embedded in the mountainside.</blockquote>\n<blockquote>You find a door under a large sign that says \u201cLava Production Facility\u201d and next to a smaller sign that says \u201cDanger\u200a\u2014\u200aPersonal Protective Equipment required beyond this\u00a0point\u201d.</blockquote>\n<blockquote>As you step inside, you are immediately greeted by a somewhat panicked reindeer wearing goggles and a loose-fitting <a href=\"https://en.wikipedia.org/wiki/Hard_hat\">hard hat</a>. The reindeer leads you to a shelf of goggles and hard hats (you quickly find some that fit) and then further into the facility. At one point, you pass a button with a faint snout mark and the label \u201cPUSH FOR HELP\u201d. No wonder you were loaded into that <a href=\"https://adventofcode.com/2023/day/1\">trebuchet</a> so\u00a0quickly!</blockquote>\n<blockquote>You pass through a final set of doors surrounded with even more warning signs and into what must be the room that collects all of the light from outside. As you admire the large assortment of lenses available to further focus the light, the reindeer brings you a book titled \u201cInitialization Manual\u201d.</blockquote>\n<blockquote>\u201cHello!\u201d, the book cheerfully begins, apparently unaware of the concerned reindeer reading over your shoulder. \u201cThis procedure will let you bring the Lava Production Facility online\u200a\u2014\u200aall without burning or melting anything unintended!\u201d</blockquote>\n<blockquote>\u201cBefore you begin, please be prepared to use the Holiday ASCII String Helper algorithm (appendix 1A).\u201d You turn to appendix 1A. The reindeer leans closer with interest.</blockquote>\n<blockquote>The HASH algorithm is a way to turn any <a href=\"https://en.wikipedia.org/wiki/String_(computer_science)\">string</a> of characters into a single number in the range 0 to 255. To run the HASH algorithm on a string, start with a current value of 0. Then, for each character in the string starting from the beginning:</blockquote>\n<blockquote>Determine the <a href=\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\">ASCII code</a> for the current character of the\u00a0string.</blockquote>\n<blockquote>Increase the current value by the ASCII code you just determined.</blockquote>\n<blockquote>Set the current value to itself multiplied by\u00a017.</blockquote>\n<blockquote>Set the current value to the <a href=\"https://en.wikipedia.org/wiki/Modulo\">remainder</a> of dividing itself by\u00a0256.</blockquote>\n<blockquote>After following these steps for each character in the string in order, the current value is the output of the HASH algorithm.</blockquote>\n<blockquote>So, to find the result of running the HASH algorithm on the string\u00a0HASH:</blockquote>\n<blockquote>The current value starts at\u00a00.</blockquote>\n<blockquote>The first character is H; its ASCII code is\u00a072.</blockquote>\n<blockquote>The current value increases to\u00a072.</blockquote>\n<blockquote>The current value is multiplied by 17 to become\u00a01224.</blockquote>\n<blockquote>The current value becomes 200 (the remainder of 1224 divided by\u00a0256).</blockquote>\n<blockquote>The next character is A; its ASCII code is\u00a065.</blockquote>\n<blockquote>The current value increases to\u00a0265.</blockquote>\n<blockquote>The current value is multiplied by 17 to become\u00a04505.</blockquote>\n<blockquote>The current value becomes 153 (the remainder of 4505 divided by\u00a0256).</blockquote>\n<blockquote>The next character is S; its ASCII code is\u00a083.</blockquote>\n<blockquote>The current value increases to\u00a0236.</blockquote>\n<blockquote>The current value is multiplied by 17 to become\u00a04012.</blockquote>\n<blockquote>The current value becomes 172 (the remainder of 4012 divided by\u00a0256).</blockquote>\n<blockquote>The next character is H; its ASCII code is\u00a072.</blockquote>\n<blockquote>The current value increases to\u00a0244.</blockquote>\n<blockquote>The current value is multiplied by 17 to become\u00a04148.</blockquote>\n<blockquote>The current value becomes 52 (the remainder of 4148 divided by\u00a0256).</blockquote>\n<blockquote>So, the result of running the HASH algorithm on the string HASH is\u00a052.</blockquote>\n<blockquote>The initialization sequence (your puzzle input) is a comma-separated list of steps to start the Lava Production Facility. Ignore newline characterswhen parsing the initialization sequence. To verify that your HASH algorithm is working, the book offers the sum of the result of running the HASH algorithm on each step in the initialization sequence.</blockquote>\n<blockquote>For example:</blockquote>\n<blockquote>rn=1,cm-,qp=3,cm=2,qp-,pc=4,ot=9,ab=5,pc-,pc=6,ot=7</blockquote>\n<blockquote>This initialization sequence specifies 11 individual steps; the result of running the HASH algorithm on each of the steps is as\u00a0follows:</blockquote>\n<blockquote>rn=1 becomes\u00a030.</blockquote>\n<blockquote>cm- becomes\u00a0253.</blockquote>\n<blockquote>qp=3 becomes\u00a097.</blockquote>\n<blockquote>cm=2 becomes\u00a047.</blockquote>\n<blockquote>qp- becomes\u00a014.</blockquote>\n<blockquote>pc=4 becomes\u00a0180.</blockquote>\n<blockquote>ot=9 becomes\u00a09.</blockquote>\n<blockquote>ab=5 becomes\u00a0197.</blockquote>\n<blockquote>pc- becomes\u00a048.</blockquote>\n<blockquote>pc=6 becomes\u00a0214.</blockquote>\n<blockquote>ot=7 becomes\u00a0231.</blockquote>\n<blockquote>In this example, the sum of these results is 1320. Unfortunately, the reindeer has stolen the page containing the expected verification number and is currently running around the facility with it excitedly.</blockquote>\n<blockquote>Run the HASH algorithm on each step in the initialization sequence. What is the sum of the results? (The initialization sequence is one long line; be careful when copy-pasting it.)</blockquote>\n<p>Intereisting problem! It seems like we need to implement a new hashing algorithm\u200a\u2014\u200a<strong>Holiday ASCII String Helper Algorithm!</strong></p>\n<p>Well, this algo will turn any string of characters into a single number in the range 0 to 255 by starting with a current value of 0. Then, for each character in the string starting from the beginning:</p>\n<ul>\n<li>Determine the <a href=\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\">ASCII code</a> for the current character of the\u00a0string.</li>\n<li>Increase the current value by the ASCII code you just determined.</li>\n<li>Set the current value to itself multiplied by\u00a017.</li>\n<li>Set the current value to the <a href=\"https://en.wikipedia.org/wiki/Modulo\">remainder</a> of dividing itself by\u00a0256.</li>\n</ul>\n<p>Looks pretty straight forward! Let\u2019s write some code? We will start with the base case\u00a0first:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/725/1*nUIxhV9rFPpavxwRjKc_Lg.png\"></figure><p>The code seems pretty simple to implement <strong><em>for\u00a0now:</em></strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/501/1*p1Lxnslgpn36_7vWtWkNog.png\"></figure><p>Let\u2019s test our base\u00a0case?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_15/lens_library.py\"<br>\u2705 test_process_sequence Passed<br><br>[Done] exited with code=0 in 0.067 seconds</pre>\n<p>Lets run this for our puzzle input while ensuring all of the sequence is just a 1 line string so we need to ignore new newline characters while\u00a0parsing:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/444/1*ovfiX-cTmKtlBJITUQH2lQ.png\"></figure><p>Let\u2019s run this? This seems just suspiciously easy!\u00a0\ud83d\ude05</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_15/lens_library.py\"<br>\u2757\ufe0f Part One: XXXXX<br><br>[Done] exited with code=0 in 0.067 seconds</pre>\n<p>We have an answer, let\u2019s try it on the puzzle page\u00a0and\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/816/1*U-6onPyytv6IZfdtxPBWsA.png\"><figcaption>\u2705</figcaption></figure><p>Boom! Easy. Let\u2019s go to part 2, here\u2019s our code till now, can\u2019t be anymore efficient!</p>\n<pre># Day 15: Lens Library<br><br>def holiday_helper(step):<br>    current_value = 0<br>    for ch in step:<br>        ascii_code = ord(ch)<br>        current_value += ascii_code<br>        current_value *= 17<br>        current_value %= 256<br><br>    return current_value<br><br><br>def process_sequence(sequence):<br>    sum = 0<br>    for step in sequence.split(\",\"):<br>        sum += holiday_helper(step)<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_15/input.txt\") as f:<br>        sequence = f.read().strip()<br><br>    sum = process_sequence(sequence)<br>    print(f\"\u2757\ufe0f Part One: {sum}\")<br><br>def test_process_sequence():<br>    sequence = \"rn=1,cm-,qp=3,cm=2,qp-,pc=4,ot=9,ab=5,pc-,pc=6,ot=7\"<br>    sum = process_sequence(sequence)<br>    assert sum == 1320, f\"Expected 1320, but got {sum}\"<br>    print(\"\u2705 test_process_sequence Passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_process_sequence()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>You convince the reindeer to bring you the page; the page confirms that your HASH algorithm is\u00a0working.</blockquote>\n<blockquote>The book goes on to describe a series of 256 boxes numbered 0 through 255. The boxes are arranged in a line starting from the point where light enters the facility. The boxes have holes that allow light to pass from one box to the next all the way down the\u00a0line.</blockquote>\n<blockquote>+-----+ +-----+ +-----+<br>Light | Box | | Box |\u00a0... | Box |<br>-----------------------------------------&gt;<br> | 0 | | 1 |\u00a0... | 255 |<br> +-----+ +-----+\u00a0+-----+</blockquote>\n<blockquote>Inside each box, there are several lens slots that will keep a lens correctly positioned to focus light passing through the box. The side of each box has a panel that opens to allow you to insert or remove lenses as necessary.</blockquote>\n<blockquote>Along the wall running parallel to the boxes is a large library containing lenses organized by focal length ranging from 1 through 9. The reindeer also brings you a small handheld <a href=\"https://en.wikipedia.org/wiki/Label_printer\">label\u00a0printer</a>.</blockquote>\n<blockquote>The book goes on to explain how to perform each step in the initialization sequence, a process it calls the Holiday ASCII String Helper Manual Arrangement Procedure, or HASHMAP for\u00a0short.</blockquote>\n<blockquote>Each step begins with a sequence of letters that indicate the label of the lens on which the step operates. The result of running the HASH algorithm on the label indicates the correct box for that\u00a0step.</blockquote>\n<blockquote>The label will be immediately followed by a character that indicates the operation to perform: either an equals sign (=) or a dash\u00a0(-).</blockquote>\n<blockquote>If the operation character is a dash (-), go to the relevant box and remove the lens with the given label if it is present in the box. Then, move any remaining lenses as far forward in the box as they can go without changing their order, filling any space made by removing the indicated lens. (If no lens in that box has the given label, nothing happens.)</blockquote>\n<blockquote>If the operation character is an equals sign (=), it will be followed by a number indicating the focal length of the lens that needs to go into the relevant box; be sure to use the label maker to mark the lens with the label given in the beginning of the step so you can find it later. There are two possible situations:</blockquote>\n<blockquote>If there is already a lens in the box with the same label, replace the old lens with the new lens: remove the old lens and put the new lens in its place, not moving any other lenses in the\u00a0box.</blockquote>\n<blockquote>If there is not already a lens in the box with the same label, add the lens to the box immediately behind any lenses already in the box. Don\u2019t move any of the other lenses when you do this. If there aren\u2019t any lenses in the box, the new lens goes all the way to the front of the\u00a0box.</blockquote>\n<blockquote>Here is the contents of every box after each step in the example initialization sequence\u00a0above:</blockquote>\n<blockquote>After \"rn=1\":<br>Box 0: [rn\u00a01]</blockquote>\n<blockquote>After \"cm-\":<br>Box 0: [rn\u00a01]</blockquote>\n<blockquote>After \"qp=3\":<br>Box 0: [rn 1]<br>Box 1: [qp\u00a03]</blockquote>\n<blockquote>After \"cm=2\":<br>Box 0: [rn 1] [cm 2]<br>Box 1: [qp\u00a03]</blockquote>\n<blockquote>After \"qp-\":<br>Box 0: [rn 1] [cm\u00a02]</blockquote>\n<blockquote>After \"pc=4\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [pc\u00a04]</blockquote>\n<blockquote>After \"ot=9\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [pc 4] [ot\u00a09]</blockquote>\n<blockquote>After \"ab=5\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [pc 4] [ot 9] [ab\u00a05]</blockquote>\n<blockquote>After \"pc-\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [ot 9] [ab\u00a05]</blockquote>\n<blockquote>After \"pc=6\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [ot 9] [ab 5] [pc\u00a06]</blockquote>\n<blockquote>After \"ot=7\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [ot 7] [ab 5] [pc\u00a06]</blockquote>\n<blockquote>All 256 boxes are always present; only the boxes that contain any lenses are shown here. Within each box, lenses are listed from front to back; each lens is shown as its label and focal length in square brackets.</blockquote>\n<blockquote>To confirm that all of the lenses are installed correctly, add up the focusing power of all of the lenses. The focusing power of a single lens is the result of multiplying together:</blockquote>\n<blockquote>One plus the box number of the lens in question.</blockquote>\n<blockquote>The slot number of the lens within the box: 1 for the first lens, 2for the second lens, and so\u00a0on.</blockquote>\n<blockquote>The focal length of the\u00a0lens.</blockquote>\n<blockquote>At the end of the above example, the focusing power of each lens is as\u00a0follows:</blockquote>\n<blockquote>rn: 1 (box 0) * 1 (first slot) * 1 (focal length) =\u00a01</blockquote>\n<blockquote>cm: 1 (box 0) * 2 (second slot) * 2 (focal length) =\u00a04</blockquote>\n<blockquote>ot: 4 (box 3) * 1 (first slot) * 7 (focal length) =\u00a028</blockquote>\n<blockquote>ab: 4 (box 3) * 2 (second slot) * 5 (focal length) =\u00a040</blockquote>\n<blockquote>pc: 4 (box 3) * 3 (third slot) * 6 (focal length) =\u00a072</blockquote>\n<blockquote>So, the above example ends up with a total focusing power of\u00a0145.</blockquote>\n<blockquote>With the help of an over-enthusiastic reindeer in a hard hat, follow the initialization sequence. What is the focusing power of the resulting lens configuration?</blockquote>\n<blockquote><em>You convince the reindeer to bring you the page; the page confirms that your HASH algorithm is\u00a0working.</em></blockquote>\n<p>Well, duh! Here we go, this puzzle is going to get super complex\u00a0now\u2026</p>\n<p>So, the setup is something like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/675/1*Www7KbCoZ3ktNplUfH5IWA.png\"></figure><p>And we have a <strong><em>label\u00a0printer!</em></strong></p>\n<p>Initialization sequence(or Holiday ASCII String Helper Manual Arrangement Procedure or H.A.S.H.M.A.P.) goes on something like\u00a0this:</p>\n<ol>\n<li>Each step begins with a sequence of letters that indicate the label of the lens on which the step operates. <br>-&gt; The result of running the HASH algorithm on the label indicates the correct box for that\u00a0step.</li>\n<li>The label will be immediately followed by a character that indicates the operation to perform: either an equals sign (=) or a dash\u00a0(-).</li>\n<li>If the operation character is a dash (-):<br>* go to the relevant box and remove the lens with the given label if it is present in the box.<br>* move any remaining lenses as far forward in the box as they can go without changing their order, filling any space made by removing the indicated lens.</li>\n<li>If the operation character is an equals sign (=):<br>* it will be followed by a number indicating the focal length of the lens that needs to go into the relevant box<br>* be sure to use the label maker to mark the lens with the label given in the beginning of the step so you can find it\u00a0later.</li>\n</ol>\n<blockquote>There are two possible situations:</blockquote>\n<blockquote>- If there is already a lens in the box with the same label, replace the old lens with the new lens: remove the old lens and put the new lens in its place, not moving any other lenses in the\u00a0box.</blockquote>\n<blockquote>- If there is not already a lens in the box with the same label, add the lens to the box immediately behind any lenses already in the box. Don\u2019t move any of the other lenses when you do this. If there aren\u2019t any lenses in the box, the new lens goes all the way to the front of the\u00a0box.</blockquote>\n<p>This is a mouthfull, let\u2019s do it one by\u00a0one!</p>\n<p>First, we need a new parsing logic for each step of the sequence:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/689/1*RlyIk7rWvUtjqOlWzWJFGw.png\"><figcaption>This should take care of the \u201cOperation\u201d nuance</figcaption></figure><p>Let\u2019s setup some classes for Box and Lens so we can have object embedding for cleaner\u00a0code:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/613/1*JP2hv9IUmEbaBvkZYWWk7w.png\"></figure><p>Now, let\u2019s implement some of the box operations for\u200a\u2014\u200aand =\u00a0!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/839/1*9nAp_zu35eTR0MSZdimHuQ.png\"></figure><p>Now, let\u2019s implement our H.A.S.H.M.A.P function that will utilise our Box methods to do the processing:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/872/1*2o4jjLn9_mQITbhhtWhjiQ.png\"><figcaption>I have added some logging for my own\u00a0sanity!</figcaption></figure><p>Let\u2019s run the test case with the help of our debugger, our final state of BOXES should look like\u00a0this:</p>\n<pre>After \"ot=7\":<br>Box 0: [rn 1] [cm 2]<br>Box 3: [ot 7] [ab 5] [pc 6]</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/737/1*EDr-xHyl61TEKG1TIwS7rA.png\"><figcaption>Indeed, it is!\u00a0\ud83d\ude4c</figcaption></figure><p>Post this, all we need to do is, implement a sum function to give us our answer, i.e: <strong>focusing power of the resulting lens configuration</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/637/1*jaBKBtIarf_FaonlkWd4UQ.png\"></figure><p>Let\u2019s test our new base test case as given in the part\u00a02:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*7koJsd2tnYcBBxjEv-Kjig.png\"></figure><p>And\u2026</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_15/lens_library.py\"<br>Lens: rn | ADDED | in box: 0<br>Lens: cm | NOT FOUND | in box: 0<br>Lens: qp | ADDED | in box: 1<br>Lens: cm | ADDED | in box: 0<br>Lens: qp | REMOVED | in box: 1<br>Lens: pc | ADDED | in box: 3<br>Lens: ot | ADDED | in box: 3<br>Lens: ab | ADDED | in box: 3<br>Lens: pc | REMOVED | in box: 3<br>Lens: pc | ADDED | in box: 3<br>Lens: ot | UPDATED | in box: 3<br>\u2705 test_hashmap Passed<br><br>[Done] exited with code=0 in 0.05 seconds</pre>\n<p>Beautiful! Let\u2019s now run this for our puzzle\u00a0input?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/852/1*FbUwOkVh8EwkJMhJnoL_Lw.png\"></figure><blockquote>\ud83d\udca1Remember to not run test_hashmap() before part_two() as it will modify the state of our global BOXES.\u00a0\ud83d\ude05</blockquote>\n<blockquote>I will fix that post verification!</blockquote>\n<p>Let\u2019s remove the logging and just execute the part_two()\u00a0:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_15/lens_library.py\"<br>\u2757\ufe0f\u2757\ufe0f Focusing power of the resulting lens configuration: XXXXXX<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>We got an answer in just sweet <strong>0.073 seconds, </strong>let\u2019s input this in our answer box\u2026..and\u2026. \ud83d\udca5</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/875/1*-O9fB2a5ZM9THFV4029-fw.png\"><figcaption>First try!\u00a0\ud83d\ude0e</figcaption></figure><p>Here\u2019s our final optimized pythonic code with production level quality with inline comments!</p>\n<blockquote>Since I was able to do this one quickly, spent some time writing quality code! You will enjoy reading\u00a0this!</blockquote>\n<pre># Day 15: Lens Library<br><br>from enum import Enum<br><br><br>class Operation(Enum):<br>    DASH = \"-\"<br>    EQUALS = \"=\"<br><br><br># Represents a step in the initialization sequence, parsing its components<br>class Step:<br>    def __init__(self, step):<br>        # Check if the step involves removing a lens (indicated by a dash)<br>        if Operation.DASH.value in step:<br>            self.label, _ = step.split(Operation.DASH.value)<br>            self.operation = Operation.DASH<br>            self.focal_length = None<br><br>        # Check if the step involves adding or updating a lens (indicated by an equals sign)<br>        elif Operation.EQUALS.value in step:<br>            self.label, focal_length = step.split(Operation.EQUALS.value)<br>            self.operation = Operation.EQUALS<br>            self.focal_length = int(focal_length)<br><br>        else:<br>            raise ValueError(f\"Invalid step: {step}\")<br><br><br># Represents a lens with a label and focal length<br>class Lens:<br>    def __init__(self, label, focal_length):<br>        self.label = label<br>        self.focal_length = focal_length<br><br>    def __repr__(self):<br>        return f\"[{self.label} {self.focal_length}]\"<br><br><br># Represents a box that can hold multiple lenses<br>class Box:<br>    def __init__(self, id):<br>        self.id = id<br>        self.lenses = []<br><br>    def find_lens(self, label):<br>        for lens in self.lenses:<br>            if lens.label == label:<br>                return lens<br>        return None<br><br>    def remove_lens(self, label):<br>        lens = self.find_lens(label)<br>        if lens:<br>            self.lenses.remove(lens)<br><br>    def add_or_update_lens(self, lens):<br>        existing_lens = self.find_lens(lens.label)<br>        if existing_lens:<br>            existing_lens.focal_length = lens.focal_length<br>        else:<br>            self.lenses.append(lens)<br><br>    def calc_focusing_power(self):<br>        return sum(<br>            (self.id + 1) * (idx + 1) * lens.focal_length<br>            for idx, lens in enumerate(self.lenses)<br>        )<br><br><br># Represents the entire Lava Production Facility with its boxes<br>class LavaProductionFacility:<br>    def __init__(self):<br>        self.boxes = [Box(id) for id in range(256)]<br><br>    # H.A.S.H.M.A.P. = Holiday ASCII String Helper Manual Arrangement Procedure<br>    def holiday_ascii_string_helper_manual_arrangement_procedure(self, sequence_steps):<br>        for step in sequence_steps:<br>            step_obj = Step(step)<br>            box_id = self.holiday_ascii_string_helper(step_obj.label)<br>            box = self.boxes[box_id]<br><br>            if step_obj.operation == Operation.DASH:<br>                box.remove_lens(step_obj.label)<br>            elif step_obj.operation == Operation.EQUALS:<br>                lens = Lens(step_obj.label, step_obj.focal_length)<br>                box.add_or_update_lens(lens)<br><br>    def sum_focusing_power(self):<br>        return sum(box.calc_focusing_power() for box in self.boxes)<br><br>    @staticmethod<br>    # H.A.S.H. = Holiday ASCII String Helper<br>    def holiday_ascii_string_helper(step):<br>        current_value = 0<br>        for ch in step:<br>            current_value = (current_value + ord(ch)) * 17 % 256<br>        return current_value<br><br>    def get_sequence_hash(self, sequence):<br>        return sum(<br>            self.holiday_ascii_string_helper(step) for step in sequence.split(\",\")<br>        )<br><br><br>def part_one():<br>    with open(\"day_15/input.txt\") as f:<br>        sequence = f.read().strip()<br><br>    facility = LavaProductionFacility()<br>    sum_hash = facility.get_sequence_hash(sequence)<br>    print(f\"\u2757\ufe0f Part One: {sum_hash}\")<br><br><br>def part_two():<br>    with open(\"day_15/input.txt\") as f:<br>        sequence = f.read().strip()<br><br>    facility = LavaProductionFacility()<br>    facility.holiday_ascii_string_helper_manual_arrangement_procedure(<br>        sequence.split(\",\")<br>    )<br>    sum_focusing_power = facility.sum_focusing_power()<br>    print(<br>        f\"\u2757\ufe0f\u2757\ufe0f Focusing power of the resulting lens configuration: {sum_focusing_power}\"<br>    )<br><br><br>def test_hashmap():<br>    sequence = \"rn=1,cm-,qp=3,cm=2,qp-,pc=4,ot=9,ab=5,pc-,pc=6,ot=7\"<br>    facility = LavaProductionFacility()<br>    facility.holiday_ascii_string_helper_manual_arrangement_procedure(<br>        sequence.split(\",\")<br>    )<br>    sum_focusing_power = facility.sum_focusing_power()<br>    assert sum_focusing_power == 145, f\"Expected 145, but got {sum_focusing_power}\"<br>    print(\"\u2705 test_hashmap Passed\")<br><br><br>def test_get_sequence_hash():<br>    sequence = \"rn=1,cm-,qp=3,cm=2,qp-,pc=4,ot=9,ab=5,pc-,pc=6,ot=7\"<br>    facility = LavaProductionFacility()<br>    sum_hash = facility.get_sequence_hash(sequence)<br>    assert sum_hash == 1320, f\"Expected 1320, but got {sum_hash}\"<br>    print(\"\u2705 test_process_sequence Passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_get_sequence_hash()<br>    part_one()<br><br>    test_hashmap()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=0597f87f340e\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["coding","advent-of-code","advent-of-code-2023","christmas","python"]},{"title":"[Day 14] Parabolic Reflector Dish // Advent of Code 2023 (Python)","pubDate":"2023-12-21 21:01:16","link":"https://medium.com/@jatinkrmalik/day-14-parabolic-reflector-dish-advent-of-code-2023-python-10760f12f5a5?source=rss-ec576e4b06b0------2","guid":"https://medium.com/p/10760f12f5a5","author":"Jatin K Malik","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*zkAVIfrKih2TgfjK\"><figcaption>Parabolic Reflector Dish (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/14\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You reach the place where all of the mirrors were pointing: a massive <a href=\"https://en.wikipedia.org/wiki/Parabolic_reflector\">parabolic reflector dish</a> attached to the side of another large mountain.</blockquote>\n<blockquote>The dish is made up of many small mirrors, but while the mirrors themselves are roughly in the shape of a parabolic reflector dish, each individual mirror seems to be pointing in slightly the wrong direction. If the dish is meant to focus light, all it\u2019s doing right now is sending it in a vague direction.</blockquote>\n<blockquote>This system must be what provides the energy for the lava! If you focus the reflector dish, maybe you can go where it\u2019s pointing and use the light to fix the lava production.</blockquote>\n<blockquote>Upon closer inspection, the individual mirrors each appear to be connected via an elaborate system of ropes and pulleys to a large metal platform below the dish. The platform is covered in large rocks of various shapes. Depending on their position, the weight of the rocks deforms the platform, and the shape of the platform controls which ropes move and ultimately the focus of the\u00a0dish.</blockquote>\n<blockquote>In short: if you move the rocks, you can focus the dish. The platform even has a control panel on the side that lets you tilt it in one of four directions! The rounded rocks (O) will roll when the platform is tilted, while the cube-shaped rocks (#) will stay in place. You note the positions of all of the empty spaces (.) and rocks (your puzzle input). For\u00a0example:</blockquote>\n<blockquote>O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....</blockquote>\n<blockquote>Start by tilting the lever so all of the rocks will slide north as far as they will\u00a0go:</blockquote>\n<blockquote>OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....</blockquote>\n<blockquote>You notice that the support beams along the north side of the platform are damaged; to ensure the platform doesn\u2019t collapse, you should calculate the total load on the north support\u00a0beams.</blockquote>\n<blockquote>The amount of load caused by a single rounded rock (O) is equal to the number of rows from the rock to the south edge of the platform, including the row the rock is on. (Cube-shaped rocks (#) don't contribute to load.) So, the amount of load caused by each rock in each row is as\u00a0follows:</blockquote>\n<blockquote>OOOO.#.O.. 10<br>OO..#....# 9<br>OO..O##..O 8<br>O..#.OO... 7<br>........#. 6<br>..#....#.# 5<br>..O..#.O.O 4<br>..O....... 3<br>#....###.. 2<br>#....#.... 1</blockquote>\n<blockquote>The total load is the sum of the load caused by all of the rounded rocks. In this example, the total load is\u00a0136.</blockquote>\n<blockquote>Tilt the platform so that the rounded rocks all roll north. Afterward, what is the total load on the north support\u00a0beams?</blockquote>\n<p>Cool! Let\u2019s review the problem in terms of <strong><em>chronology</em></strong> and we shall break down what needs to be done to get our\u00a0answer?</p>\n<p>We have <strong>2 types of\u00a0rocks</strong>:</p>\n<ul>\n<li># <strong>Cube shape rocks</strong>, that stay in\u00a0place</li>\n<li>O <strong>Rounded rocks</strong>, that\u00a0rolls!</li>\n</ul>\n<p>Given an initial state of platform represented by a 2D matrix, we need to ensure that the north side beam <strong>can handle the load</strong> if we start to tilt the platform, so we can need to <strong>calculate the state of platform</strong> when it is tilted towards North direction!</p>\n<p>Let\u2019s see a quick\u00a0viz:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/733/1*34Iz-l6OzH6JvCKvO1pHvw.png\"></figure><p>We can observe how all O rocks have <strong>moved along their columns towards North</strong> while # have stayed\u00a0put.</p>\n<p>And then, base case allows us to calculate the load bearing capacity of the north support beam by sum(number of \"O\u201d rocks * number of rows from the rock to the south edge of the platform), like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/852/1*z7xNWvYhuVnAf6N5fmV2xA.png\"></figure><p>So, we need to write code in 2\u00a0parts:</p>\n<ol>\n<li>To <strong>generate</strong> the north_tilted state</li>\n<li>To <strong>calculate</strong> the total load on north\u00a0beam</li>\n</ol>\n<p>But first, let\u2019s write the base test case along with some skelton code to structure our thought\u00a0process:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/817/1*dTdlYQQC_kV6EXaKXAOr4g.png\"></figure><p>Perfect, now let\u2019s implement our methods and do some debugging!</p>\n<p>Now for <em>tilting </em>our platform, we can just go through our platform and then for each instance of O we can try to move it upward in column till we get another O or # and then move on the next\u00a0one!</p>\n<p>Here, some code for that with an Tile(Enum) to keep code\u00a0tidy!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/913/1*fWqLKIbBKhFVktMvw-91yA.png\"></figure><p>Let\u2019s debug and see if it is working correctly, and actually we can write a test case just to verify the tilt_platform function:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*U9TuX8mNBSaOOsBuB6blYg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u2705 tilt_platform passed<br><br>[Done] exited with code=0 in 0.087 seconds</pre>\n<p>Let\u2019s see a beautiful visualisation of platform tilting to north as we h\u0336u\u0336m\u0336a\u0336n\u0336s\u0336 coders can appreciate:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/904/1*gsgUbXWQEr5EphznMC5EZA.gif\"><figcaption>Beautiful! \ud83e\udd29</figcaption></figure><p>Now, let\u2019s implement our load calculation function, as it\u2019s clear from our visualization above, all we need to do is to sum(number of \"O\u201d rocks * number of rows from the rock to the south edge of the platform)</p>\n<p>Let\u2019s write some code, seems pretty\u00a0simple:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/714/1*iLx15Och0NPYHbtj8_lScA.png\"></figure><p>And let\u2019s run both of our test\u00a0cases?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u2705 tilt_platform passed<br>\u2705 calculate_load_on_north_beam passed<br><br>[Done] exited with code=0 in 0.056 seconds</pre>\n<p>Noice! Pretty quick as well. Let\u2019s load up our puzzle input and run this\u00a0code?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/864/1*X3PIZqqBOkUklyqIjKRwhg.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u2757\ufe0f Total load on the north beam is XXXXXX<br><br>[Done] exited with code=0 in 0.07 seconds</pre>\n<p>We get an answer, let\u2019s input this in our answer box, I have a good feeling about this\u00a0one!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/837/1*dnPq69m0hHyjHP_HYBP5WA.png\"><figcaption>Ez! \ud83d\udd76</figcaption></figure><p>Here\u2019s our code till now, we will optimise it in next part, as preoptimization is\u00a0futile:</p>\n<pre># Day 14 - Parabolic Reflector Dish<br><br>from enum import Enum<br><br><br>class TiltDirection(Enum):<br>    North = 1<br>    South = 2<br>    East = 3<br>    West = 4<br><br><br>class Tile(Enum):<br>    Empty = \".\"<br>    CubeRock = \"#\"<br>    RoundRock = \"O\"<br><br><br>def tilt_platform(platform_state, direction=TiltDirection.North):<br>    # well, we only care about north for now<br>    if direction != TiltDirection.North:<br>        NotImplementedError(\"Only TiltDirection.North is supported for now\")<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    for i, row in enumerate(platform_state):<br>        for j, tile in enumerate(row):<br>            if tile == Tile.RoundRock.value:<br>                # move this rock upwards in column<br>                row_idx, col_idx = i, j<br>                while (<br>                    row_idx - 1 &gt;= 0<br>                    and platform_state[row_idx - 1][col_idx] == Tile.Empty.value<br>                ):<br>                    platform_state[row_idx][col_idx] = Tile.Empty.value<br>                    platform_state[row_idx - 1][col_idx] = Tile.RoundRock.value<br>                    row_idx -= 1<br><br>    return platform_state<br><br><br>def calculate_load_on_north_beam(tilted_platform_state):<br>    total_load = 0<br>    load_factor = len(tilted_platform_state)<br><br>    for row in tilted_platform_state:<br>        total_load += load_factor * row.count(Tile.RoundRock.value)<br>        load_factor -= 1<br><br>    return total_load<br><br><br>def part_one():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"\u2757\ufe0f Total load on the north beam is {total_load}\")<br><br><br>def test_tilt_platform():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state = \"\"\"OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....\"\"\"<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    assert tilted_platform_state == [<br>        list(row) for row in expected_platform_state.split(\"\\n\")<br>    ], f\"Expected {expected_platform_state}, got {tilted_platform_state}\"<br>    print(\"\u2705 tilt_platform passed\")<br><br><br>def test_calculate_load_on_north_beam():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 136, f\"Expected 136, got {total_load}\"<br>    print(\"\u2705 calculate_load_on_north_beam passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_tilt_platform()<br>    test_calculate_load_on_north_beam()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>The parabolic reflector dish deforms, but not in a way that focuses the beam. To do that, you\u2019ll need to move the rocks to the edges of the platform. Fortunately, a button on the side of the control panel labeled \u201cspin cycle\u201d attempts to do just\u00a0that!</blockquote>\n<blockquote>Each cycle tilts the platform four times so that the rounded rocks roll north, then west, then south, then east. After each tilt, the rounded rocks roll as far as they can before the platform tilts in the next direction. After one cycle, the platform will have finished rolling the rounded rocks in those four directions in that\u00a0order.</blockquote>\n<blockquote>Here\u2019s what happens in the example above after each of the first few\u00a0cycles:</blockquote>\n<blockquote>After 1 cycle:<br>.....#....<br>....#...O#<br>...OO##...<br>.OO#......<br>.....OOO#.<br>.O#...O#.#<br>....O#....<br>......OOOO<br>#...O###..<br>#..OO#....</blockquote>\n<blockquote>After 2 cycles:<br>.....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#..OO###..<br>#.OOO#...O</blockquote>\n<blockquote>After 3 cycles:<br>.....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#...O###.O<br>#.OOO#...O</blockquote>\n<blockquote>This process should work if you leave it running long enough, but you\u2019re still worried about the north support beams. To make sure they\u2019ll survive for a while, you need to calculate the total load on the north support beams after 1000000000 cycles.</blockquote>\n<blockquote>In the above example, after 1000000000 cycles, the total load on the north support beams is\u00a064.</blockquote>\n<blockquote>Run the spin cycle for 1000000000 cycles. Afterward, what is the total load on the north support\u00a0beams?</blockquote>\n<p>Well, haven\u2019t we got used to <strong><em>ever increasing exponential scale</em></strong> of Part Two!\u00a0\ud83d\udc40</p>\n<blockquote>Let\u2019s dive\u00a0in\u2026</blockquote>\n<p>Our foresight of using TiltDirection(Enum) was correct, we do need to tilt in other directions, but thankfully we still only care about north support\u00a0beams!</p>\n<p>So, seems like we can to do 1000000000<em>\u200a\u2014\u200a</em>one billion cycles where each cycle\u00a0means:</p>\n<ul><li>tilts the platform four times so that the rounded rocks roll north, then west, then south, then\u00a0east.</li></ul>\n<p>Before thinking how we can optimise without doing 1000000000<em> </em>repeatitions, let\u2019s just implement and test tilt_platform for other 3 directions:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/855/1*MZ2Rq0CVPdg4W7wUW6EUXQ.png\"><figcaption>I know, I know, a lot of dup code, we will fix this in final\u00a0code!</figcaption></figure><p>And we can modify our tilt_platform to basically use a switch case to call relevant method. Also, introducing tilt_platform_cycle where we can pass num_cycles where each cycle is defined\u00a0as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/821/1*fWJS_MwVZqSzcUk7LrUnhQ.png\"></figure><p>Let\u2019s test our tilt code for the base case given in the part 2 of the\u00a0puzzle:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/945/1*RZdLZKigWqm_uU7xm6zLPQ.png\"></figure><p>Let\u2019s run\u00a0this?</p>\n<p>And\u2026.nope! It\u00a0failed!</p>\n<blockquote>\ud83d\udca1 Edge case: Well, when we go to tilt_platform_south since it\u2019s traversing from (0,0) -&gt; (i,j) (from top left to bottom right), it won\u2019t be able to move a O rock if it has another O rock below it, but later in iteration, if we move the bottom most rock of the group, the rocks above it should also\u00a0follow!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OCBi2aYBL7f_-u0WPttdQA.png\"></figure><p>This will never be a problem when we do tilt_platform_north and tilt_platform_west since we are starting from top left aka (0,0) in our\u00a0loop.</p>\n<blockquote>\ud83d\udcad An easy way to fix this is to, for tilt_platform_south and tilt_platform_east, just iterate from bottom right (i,j) to top left (0,0) and it should automatically take care of the edge cases without having to make our code too complicated!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/340/1*x8Vcicu4SxwSbmynIgbV2w.png\"><figcaption>This shall ensure our group won\u2019t be blocked by neighbours while tilting east or\u00a0south.</figcaption></figure><p>After a few debugging sessions! It works!\u00a0\ud83e\udd13</p>\n<p>Here\u2019s a quick visuzliation of 1 cycle, with our platform_state</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/490/1*bwmLqr7lfRMuRQL75ORm6Q.gif\"><figcaption>roll north, then west, then south, then\u00a0east.</figcaption></figure><p>Let\u2019s see if our test cases\u00a0work?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u2705 tilt_platform_cycle with 1 cycle passed<br>\u2705 tilt_platform_cycle with 2 cycles passed<br>\u2705 tilt_platform_cycle with 3 cycles passed<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>How about checking our testcase\u200a\u2014\u200a1 billion times and see if we get <strong>64 </strong>load as given in the\u00a0puzzle!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/875/1*c26l8wk3mlidRmkLDsKczQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u2705 test_calculate_load_on_north_beam passed<br><br>[Done] exited with code=0 in 0.075 seconds</pre>\n<p><strong>0.075 seconds</strong> // Looking at this fast runtime, I am just tempted to run it for <strong>A billion cycles </strong>for the puzzle input as it is just <strong>100x100</strong> and our runtime is just\u00a0O(n\u00b2)!</p>\n<p>Are you game? Yes? Let\u2019s do\u00a0it!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/890/1*sQ0JUQVJAGh92wVpvW_yag.png\"><figcaption>\ud83e\udd1e</figcaption></figure><p>Well, 3 minutes later, doesn\u2019t seem likely!\u00a0\ud83e\udd72</p>\n<p>I should have had put some std::out just to know which cycle our code is on currently! So, added some logging in parallel, just to gauge the\u00a0speed:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/811/1*FJ_U2UbP7PiDaX8Jhmf6xw.png\"></figure><p>Let\u2019s see how many cycles we do for puzzle input in 10 seconds for\u00a0fun:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/811/1*FJ_U2UbP7PiDaX8Jhmf6xw.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/922/1*DYYGxjZrRaCwo6PurAc0fw.gif\"><figcaption>~300 cycles in 10\u00a0seconds</figcaption></figure><blockquote>So, it should just take us <strong>33,333,333.33</strong> seconds ~ <strong>555,555.56</strong> minutes ~ <strong>9,259.26</strong> hours ~ <strong>385.80</strong> days, which is just over 1 year!\u00a0\ud83e\udd2f</blockquote>\n<p>Yep! It\u2019s difficult for human brain to estimate large numbers! Let\u2019s optimise\u00a0now?!</p>\n<p>One of my early hypothesis is that we are spending so much time tilting our platform_state that we are bound to get repeated inputs for multiple directions! We can probably make it faster by just introducing a cache to track input and output for tilt_platform function!</p>\n<p>Let\u2019s test that, using our same unscientific test above (it will be interesting to see how memory size grows as these are 4 computations per cycle, totalling to <strong>4 billion computations</strong>!):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*shey_5pM8zAz9jdVQeP5Yg.png\"><figcaption>Added cache!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wNLS1z6SOaAlXaFYAsUl2g.gif\"><figcaption>~300 / 10 seconds, no\u00a0avail!</figcaption></figure><p>Let\u2019s rethink now! Brute force won\u2019t work\u00a0clearly!</p>\n<p>I still firmly beleive there has to be some kind of a repeatition after a while and we just need to find the cycle\u00a0here!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/889/1*7vZuAx0YRT2j69W9IVPM5A.png\"></figure><p>Added some logging, let\u2019s see our test\u00a0input:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/721/1*1tgBP55O98m1dM-VYS2vrQ.png\"></figure><p>Clearly we can see, there is <strong>some cycle going</strong> on\u00a0here!</p>\n<blockquote>\ud83d\udca1Now, all we need to do is, <strong>find the cycle length</strong> and <strong>find the cycle elements</strong>, and then by the <strong>magic of modulus</strong> % we can directly find the platform_state, as if what it will be after 1000000000 cycles!</blockquote>\n<p>.</p>\n<p>.</p>\n<blockquote>30 minutes and some debugging later!</blockquote>\n<p>.</p>\n<p>.</p>\n<p>Whipped up this <strong>spaghetti</strong> code (I promise, <strong>I will fix</strong>\u00a0this):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yfPl8wqtUZiv9icCAo884g.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u2705 tilt_platform_cycle with 1 cycle passed<br>\u2705 tilt_platform_cycle with 2 cycles passed<br>\u2705 tilt_platform_cycle with 3 cycles passed<br>\u2705 test_calculate_load_on_north_beam_1000000000_cycles passed<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>Finally! \ud83d\ude4f</p>\n<p>Now, let\u2019s run for our puzzle\u00a0input?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u203c\ufe0f Total load on the north beam after 1000000000 cycles is XXXXX<br><br>[Done] exited with code=0 in 4.166 seconds</pre>\n<p>We have an answer in <strong>4.166 seconds</strong>, let\u2019s put this in the answer box\u00a0and\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/957/1*ElrQjU_yhrwuoxyIGDQFWg.png\"><figcaption>Finally \ud83d\ude4f</figcaption></figure><p>Here\u2019s our pythonic and optimized code:</p>\n<pre># Day 14 - Parabolic Reflector Dish<br><br>from enum import Enum<br><br><br>class TiltDirection(Enum):<br>    North = \"NORTH\"<br>    South = \"SOUTH\"<br>    East = \"EAST\"<br>    West = \"WEST\"<br><br><br>class Tile(Enum):<br>    Empty = \".\"<br>    CubeRock = \"#\"<br>    RoundRock = \"O\"<br><br><br>def tilt_platform(platform_state, direction):<br>    rows, cols = len(platform_state), len(platform_state[0])<br>    delta = {<br>        TiltDirection.North: (0, -1),<br>        TiltDirection.South: (0, 1),<br>        TiltDirection.East: (1, 0),<br>        TiltDirection.West: (-1, 0)<br>    }[direction]<br><br>    def is_valid_position(row, col):<br>        return 0 &lt;= row &lt; rows and 0 &lt;= col &lt; cols<br><br>    def move_rock(start_row, start_col):<br>        row, col = start_row, start_col<br>        while is_valid_position(row + delta[1], col + delta[0]) and \\<br>                platform_state[row + delta[1]][col + delta[0]] == Tile.Empty.value:<br>            platform_state[row][col] = Tile.Empty.value<br>            row, col = row + delta[1], col + delta[0]<br>            platform_state[row][col] = Tile.RoundRock.value<br><br>    if direction in [TiltDirection.North, TiltDirection.West]:<br>        range_func = range<br>    else:<br>        range_func = lambda start, end: range(end - 1, start - 1, -1)<br><br>    for i in range_func(0, rows):<br>        for j in range_func(0, cols):<br>            if platform_state[i][j] == Tile.RoundRock.value:<br>                move_rock(i, j)<br><br>    return platform_state<br><br><br>def tilt_platform_cycle(platform_state, num_cycles=1):    <br>    platform_cache = {}  # Cache for storing seen platform states<br>    cycle_patterns = []  # List to store unique states forming a cycle<br>    cycle_start_point = None<br><br><br>    for idx in range(1, num_cycles+1):<br>        # Tilt platform in all directions<br>        for direction in [TiltDirection.North, TiltDirection.West, TiltDirection.South, TiltDirection.East]:<br>            platform_state = tilt_platform(platform_state, direction)<br><br>        # Generate a key for the current state<br>        platform_state_key = \"\\n\".join([\" \".join(map(str, row)) for row in platform_state])<br><br>        # Check if the current state has been seen before<br>        if platform_state_key in platform_cache:<br>            if cycle_start_point is None:<br>                cycle_start_point = platform_cache[platform_state_key]<br>                cycle_patterns.append(platform_state_key)<br>                continue<br><br>            # Start of the cycle found, calculate the index in the cycle pattern<br>            if platform_state_key == cycle_patterns[0]:<br>                cycle_length = len(cycle_patterns)<br>                cycle_index = (num_cycles - cycle_start_point) % cycle_length<br>                return [list(row) for row in cycle_patterns[cycle_index].split(\"\\n\")]<br><br>            # New state in the cycle<br>            if platform_state_key not in cycle_patterns:<br>                cycle_patterns.append(platform_state_key)<br>            continue<br><br>        # Store the new state in the cache<br>        platform_cache[platform_state_key] = idx<br>        if cycle_start_point is not None and platform_state_key not in cycle_patterns:<br>            cycle_patterns.append(platform_state_key)<br><br>    return platform_state<br><br><br>def calculate_load_on_north_beam(tilted_platform_state):<br>    return sum((len(tilted_platform_state) - i) * row.count(Tile.RoundRock.value)<br>               for i, row in enumerate(tilted_platform_state))<br><br><br>def part_one():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"\u2757\ufe0f Total load on the north beam is {total_load}\")<br><br><br>def part_two():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1000000000)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"\u203c\ufe0f Total load on the north beam after 1000000000 cycles is {total_load}\")<br><br><br>def test_tilt_platform_cycle():<br>    platform_state_og = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state_with_1_cycle = \"\"\".....#....<br>....#...O#<br>...OO##...<br>.OO#......<br>.....OOO#.<br>.O#...O#.#<br>....O#....<br>......OOOO<br>#...O###..<br>#..OO#....\"\"\"<br><br>    expected_platform_state_with_2_cycles = \"\"\".....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#..OO###..<br>#.OOO#...O\"\"\"<br><br>    expected_platform_state_with_3_cycles = \"\"\".....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#...O###.O<br>#.OOO#...O\"\"\"<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_1_cycle = [<br>        list(row) for row in expected_platform_state_with_1_cycle.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_1_cycle<br>    ), f\"Expected {expected_platform_state_with_1_cycle}, got {tilted_platform_state}\"<br>    print(\"\u2705 tilt_platform_cycle with 1 cycle passed\")<br><br>    # reseting platform_state<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_2_cycles = [<br>        list(row) for row in expected_platform_state_with_2_cycles.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 2)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_2_cycles<br>    ), f\"Expected {expected_platform_state_with_2_cycles}, got {tilted_platform_state}\"<br>    print(\"\u2705 tilt_platform_cycle with 2 cycles passed\")<br><br>    # reseting platform_state<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_3_cycles = [<br>        list(row) for row in expected_platform_state_with_3_cycles.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 3)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_3_cycles<br>    ), f\"Expected {expected_platform_state_with_3_cycles}, got {tilted_platform_state}\"<br>    print(\"\u2705 tilt_platform_cycle with 3 cycles passed\")<br><br><br>def test_tilt_platform():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state = \"\"\"OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    assert tilted_platform_state == [<br>        list(row) for row in expected_platform_state.split(\"\\n\")<br>    ], f\"Expected {expected_platform_state}, got {tilted_platform_state}\"<br>    print(\"\u2705 tilt_platform passed\")<br><br><br>def test_calculate_load_on_north_beam():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 136, f\"Expected 136, got {total_load}\"<br>    print(\"\u2705 test_calculate_load_on_north_beam passed\")<br><br><br>def test_calculate_load_on_north_beam_1000000000_cycles():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1000000000)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 64, f\"Expected 64, got {total_load}\"<br>    print(\"\u2705 test_calculate_load_on_north_beam_1000000000_cycles passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_tilt_platform()<br>    test_calculate_load_on_north_beam()<br>    part_one()<br><br>    test_tilt_platform_cycle()<br>    test_calculate_load_on_north_beam_1000000000_cycles()<br>    part_two()</pre>\n<p>I am sure there is more juice left to squeeze as we can further optimize this, but I am tired now! I will most likely <strong>come back</strong> during holidays to optimise this to atleast <strong>sub-second compute\u00a0time</strong>.</p>\n<p>Stay tuned!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=10760f12f5a5\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*zkAVIfrKih2TgfjK\"><figcaption>Parabolic Reflector Dish (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/14\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You reach the place where all of the mirrors were pointing: a massive <a href=\"https://en.wikipedia.org/wiki/Parabolic_reflector\">parabolic reflector dish</a> attached to the side of another large mountain.</blockquote>\n<blockquote>The dish is made up of many small mirrors, but while the mirrors themselves are roughly in the shape of a parabolic reflector dish, each individual mirror seems to be pointing in slightly the wrong direction. If the dish is meant to focus light, all it\u2019s doing right now is sending it in a vague direction.</blockquote>\n<blockquote>This system must be what provides the energy for the lava! If you focus the reflector dish, maybe you can go where it\u2019s pointing and use the light to fix the lava production.</blockquote>\n<blockquote>Upon closer inspection, the individual mirrors each appear to be connected via an elaborate system of ropes and pulleys to a large metal platform below the dish. The platform is covered in large rocks of various shapes. Depending on their position, the weight of the rocks deforms the platform, and the shape of the platform controls which ropes move and ultimately the focus of the\u00a0dish.</blockquote>\n<blockquote>In short: if you move the rocks, you can focus the dish. The platform even has a control panel on the side that lets you tilt it in one of four directions! The rounded rocks (O) will roll when the platform is tilted, while the cube-shaped rocks (#) will stay in place. You note the positions of all of the empty spaces (.) and rocks (your puzzle input). For\u00a0example:</blockquote>\n<blockquote>O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....</blockquote>\n<blockquote>Start by tilting the lever so all of the rocks will slide north as far as they will\u00a0go:</blockquote>\n<blockquote>OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....</blockquote>\n<blockquote>You notice that the support beams along the north side of the platform are damaged; to ensure the platform doesn\u2019t collapse, you should calculate the total load on the north support\u00a0beams.</blockquote>\n<blockquote>The amount of load caused by a single rounded rock (O) is equal to the number of rows from the rock to the south edge of the platform, including the row the rock is on. (Cube-shaped rocks (#) don't contribute to load.) So, the amount of load caused by each rock in each row is as\u00a0follows:</blockquote>\n<blockquote>OOOO.#.O.. 10<br>OO..#....# 9<br>OO..O##..O 8<br>O..#.OO... 7<br>........#. 6<br>..#....#.# 5<br>..O..#.O.O 4<br>..O....... 3<br>#....###.. 2<br>#....#.... 1</blockquote>\n<blockquote>The total load is the sum of the load caused by all of the rounded rocks. In this example, the total load is\u00a0136.</blockquote>\n<blockquote>Tilt the platform so that the rounded rocks all roll north. Afterward, what is the total load on the north support\u00a0beams?</blockquote>\n<p>Cool! Let\u2019s review the problem in terms of <strong><em>chronology</em></strong> and we shall break down what needs to be done to get our\u00a0answer?</p>\n<p>We have <strong>2 types of\u00a0rocks</strong>:</p>\n<ul>\n<li># <strong>Cube shape rocks</strong>, that stay in\u00a0place</li>\n<li>O <strong>Rounded rocks</strong>, that\u00a0rolls!</li>\n</ul>\n<p>Given an initial state of platform represented by a 2D matrix, we need to ensure that the north side beam <strong>can handle the load</strong> if we start to tilt the platform, so we can need to <strong>calculate the state of platform</strong> when it is tilted towards North direction!</p>\n<p>Let\u2019s see a quick\u00a0viz:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/733/1*34Iz-l6OzH6JvCKvO1pHvw.png\"></figure><p>We can observe how all O rocks have <strong>moved along their columns towards North</strong> while # have stayed\u00a0put.</p>\n<p>And then, base case allows us to calculate the load bearing capacity of the north support beam by sum(number of \"O\u201d rocks * number of rows from the rock to the south edge of the platform), like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/852/1*z7xNWvYhuVnAf6N5fmV2xA.png\"></figure><p>So, we need to write code in 2\u00a0parts:</p>\n<ol>\n<li>To <strong>generate</strong> the north_tilted state</li>\n<li>To <strong>calculate</strong> the total load on north\u00a0beam</li>\n</ol>\n<p>But first, let\u2019s write the base test case along with some skelton code to structure our thought\u00a0process:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/817/1*dTdlYQQC_kV6EXaKXAOr4g.png\"></figure><p>Perfect, now let\u2019s implement our methods and do some debugging!</p>\n<p>Now for <em>tilting </em>our platform, we can just go through our platform and then for each instance of O we can try to move it upward in column till we get another O or # and then move on the next\u00a0one!</p>\n<p>Here, some code for that with an Tile(Enum) to keep code\u00a0tidy!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/913/1*fWqLKIbBKhFVktMvw-91yA.png\"></figure><p>Let\u2019s debug and see if it is working correctly, and actually we can write a test case just to verify the tilt_platform function:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*U9TuX8mNBSaOOsBuB6blYg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u2705 tilt_platform passed<br><br>[Done] exited with code=0 in 0.087 seconds</pre>\n<p>Let\u2019s see a beautiful visualisation of platform tilting to north as we h\u0336u\u0336m\u0336a\u0336n\u0336s\u0336 coders can appreciate:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/904/1*gsgUbXWQEr5EphznMC5EZA.gif\"><figcaption>Beautiful! \ud83e\udd29</figcaption></figure><p>Now, let\u2019s implement our load calculation function, as it\u2019s clear from our visualization above, all we need to do is to sum(number of \"O\u201d rocks * number of rows from the rock to the south edge of the platform)</p>\n<p>Let\u2019s write some code, seems pretty\u00a0simple:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/714/1*iLx15Och0NPYHbtj8_lScA.png\"></figure><p>And let\u2019s run both of our test\u00a0cases?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u2705 tilt_platform passed<br>\u2705 calculate_load_on_north_beam passed<br><br>[Done] exited with code=0 in 0.056 seconds</pre>\n<p>Noice! Pretty quick as well. Let\u2019s load up our puzzle input and run this\u00a0code?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/864/1*X3PIZqqBOkUklyqIjKRwhg.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u2757\ufe0f Total load on the north beam is XXXXXX<br><br>[Done] exited with code=0 in 0.07 seconds</pre>\n<p>We get an answer, let\u2019s input this in our answer box, I have a good feeling about this\u00a0one!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/837/1*dnPq69m0hHyjHP_HYBP5WA.png\"><figcaption>Ez! \ud83d\udd76</figcaption></figure><p>Here\u2019s our code till now, we will optimise it in next part, as preoptimization is\u00a0futile:</p>\n<pre># Day 14 - Parabolic Reflector Dish<br><br>from enum import Enum<br><br><br>class TiltDirection(Enum):<br>    North = 1<br>    South = 2<br>    East = 3<br>    West = 4<br><br><br>class Tile(Enum):<br>    Empty = \".\"<br>    CubeRock = \"#\"<br>    RoundRock = \"O\"<br><br><br>def tilt_platform(platform_state, direction=TiltDirection.North):<br>    # well, we only care about north for now<br>    if direction != TiltDirection.North:<br>        NotImplementedError(\"Only TiltDirection.North is supported for now\")<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    for i, row in enumerate(platform_state):<br>        for j, tile in enumerate(row):<br>            if tile == Tile.RoundRock.value:<br>                # move this rock upwards in column<br>                row_idx, col_idx = i, j<br>                while (<br>                    row_idx - 1 &gt;= 0<br>                    and platform_state[row_idx - 1][col_idx] == Tile.Empty.value<br>                ):<br>                    platform_state[row_idx][col_idx] = Tile.Empty.value<br>                    platform_state[row_idx - 1][col_idx] = Tile.RoundRock.value<br>                    row_idx -= 1<br><br>    return platform_state<br><br><br>def calculate_load_on_north_beam(tilted_platform_state):<br>    total_load = 0<br>    load_factor = len(tilted_platform_state)<br><br>    for row in tilted_platform_state:<br>        total_load += load_factor * row.count(Tile.RoundRock.value)<br>        load_factor -= 1<br><br>    return total_load<br><br><br>def part_one():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"\u2757\ufe0f Total load on the north beam is {total_load}\")<br><br><br>def test_tilt_platform():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state = \"\"\"OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....\"\"\"<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    assert tilted_platform_state == [<br>        list(row) for row in expected_platform_state.split(\"\\n\")<br>    ], f\"Expected {expected_platform_state}, got {tilted_platform_state}\"<br>    print(\"\u2705 tilt_platform passed\")<br><br><br>def test_calculate_load_on_north_beam():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 136, f\"Expected 136, got {total_load}\"<br>    print(\"\u2705 calculate_load_on_north_beam passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_tilt_platform()<br>    test_calculate_load_on_north_beam()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>The parabolic reflector dish deforms, but not in a way that focuses the beam. To do that, you\u2019ll need to move the rocks to the edges of the platform. Fortunately, a button on the side of the control panel labeled \u201cspin cycle\u201d attempts to do just\u00a0that!</blockquote>\n<blockquote>Each cycle tilts the platform four times so that the rounded rocks roll north, then west, then south, then east. After each tilt, the rounded rocks roll as far as they can before the platform tilts in the next direction. After one cycle, the platform will have finished rolling the rounded rocks in those four directions in that\u00a0order.</blockquote>\n<blockquote>Here\u2019s what happens in the example above after each of the first few\u00a0cycles:</blockquote>\n<blockquote>After 1 cycle:<br>.....#....<br>....#...O#<br>...OO##...<br>.OO#......<br>.....OOO#.<br>.O#...O#.#<br>....O#....<br>......OOOO<br>#...O###..<br>#..OO#....</blockquote>\n<blockquote>After 2 cycles:<br>.....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#..OO###..<br>#.OOO#...O</blockquote>\n<blockquote>After 3 cycles:<br>.....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#...O###.O<br>#.OOO#...O</blockquote>\n<blockquote>This process should work if you leave it running long enough, but you\u2019re still worried about the north support beams. To make sure they\u2019ll survive for a while, you need to calculate the total load on the north support beams after 1000000000 cycles.</blockquote>\n<blockquote>In the above example, after 1000000000 cycles, the total load on the north support beams is\u00a064.</blockquote>\n<blockquote>Run the spin cycle for 1000000000 cycles. Afterward, what is the total load on the north support\u00a0beams?</blockquote>\n<p>Well, haven\u2019t we got used to <strong><em>ever increasing exponential scale</em></strong> of Part Two!\u00a0\ud83d\udc40</p>\n<blockquote>Let\u2019s dive\u00a0in\u2026</blockquote>\n<p>Our foresight of using TiltDirection(Enum) was correct, we do need to tilt in other directions, but thankfully we still only care about north support\u00a0beams!</p>\n<p>So, seems like we can to do 1000000000<em>\u200a\u2014\u200a</em>one billion cycles where each cycle\u00a0means:</p>\n<ul><li>tilts the platform four times so that the rounded rocks roll north, then west, then south, then\u00a0east.</li></ul>\n<p>Before thinking how we can optimise without doing 1000000000<em> </em>repeatitions, let\u2019s just implement and test tilt_platform for other 3 directions:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/855/1*MZ2Rq0CVPdg4W7wUW6EUXQ.png\"><figcaption>I know, I know, a lot of dup code, we will fix this in final\u00a0code!</figcaption></figure><p>And we can modify our tilt_platform to basically use a switch case to call relevant method. Also, introducing tilt_platform_cycle where we can pass num_cycles where each cycle is defined\u00a0as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/821/1*fWJS_MwVZqSzcUk7LrUnhQ.png\"></figure><p>Let\u2019s test our tilt code for the base case given in the part 2 of the\u00a0puzzle:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/945/1*RZdLZKigWqm_uU7xm6zLPQ.png\"></figure><p>Let\u2019s run\u00a0this?</p>\n<p>And\u2026.nope! It\u00a0failed!</p>\n<blockquote>\ud83d\udca1 Edge case: Well, when we go to tilt_platform_south since it\u2019s traversing from (0,0) -&gt; (i,j) (from top left to bottom right), it won\u2019t be able to move a O rock if it has another O rock below it, but later in iteration, if we move the bottom most rock of the group, the rocks above it should also\u00a0follow!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OCBi2aYBL7f_-u0WPttdQA.png\"></figure><p>This will never be a problem when we do tilt_platform_north and tilt_platform_west since we are starting from top left aka (0,0) in our\u00a0loop.</p>\n<blockquote>\ud83d\udcad An easy way to fix this is to, for tilt_platform_south and tilt_platform_east, just iterate from bottom right (i,j) to top left (0,0) and it should automatically take care of the edge cases without having to make our code too complicated!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/340/1*x8Vcicu4SxwSbmynIgbV2w.png\"><figcaption>This shall ensure our group won\u2019t be blocked by neighbours while tilting east or\u00a0south.</figcaption></figure><p>After a few debugging sessions! It works!\u00a0\ud83e\udd13</p>\n<p>Here\u2019s a quick visuzliation of 1 cycle, with our platform_state</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/490/1*bwmLqr7lfRMuRQL75ORm6Q.gif\"><figcaption>roll north, then west, then south, then\u00a0east.</figcaption></figure><p>Let\u2019s see if our test cases\u00a0work?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u2705 tilt_platform_cycle with 1 cycle passed<br>\u2705 tilt_platform_cycle with 2 cycles passed<br>\u2705 tilt_platform_cycle with 3 cycles passed<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>How about checking our testcase\u200a\u2014\u200a1 billion times and see if we get <strong>64 </strong>load as given in the\u00a0puzzle!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/875/1*c26l8wk3mlidRmkLDsKczQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u2705 test_calculate_load_on_north_beam passed<br><br>[Done] exited with code=0 in 0.075 seconds</pre>\n<p><strong>0.075 seconds</strong> // Looking at this fast runtime, I am just tempted to run it for <strong>A billion cycles </strong>for the puzzle input as it is just <strong>100x100</strong> and our runtime is just\u00a0O(n\u00b2)!</p>\n<p>Are you game? Yes? Let\u2019s do\u00a0it!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/890/1*sQ0JUQVJAGh92wVpvW_yag.png\"><figcaption>\ud83e\udd1e</figcaption></figure><p>Well, 3 minutes later, doesn\u2019t seem likely!\u00a0\ud83e\udd72</p>\n<p>I should have had put some std::out just to know which cycle our code is on currently! So, added some logging in parallel, just to gauge the\u00a0speed:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/811/1*FJ_U2UbP7PiDaX8Jhmf6xw.png\"></figure><p>Let\u2019s see how many cycles we do for puzzle input in 10 seconds for\u00a0fun:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/811/1*FJ_U2UbP7PiDaX8Jhmf6xw.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/922/1*DYYGxjZrRaCwo6PurAc0fw.gif\"><figcaption>~300 cycles in 10\u00a0seconds</figcaption></figure><blockquote>So, it should just take us <strong>33,333,333.33</strong> seconds ~ <strong>555,555.56</strong> minutes ~ <strong>9,259.26</strong> hours ~ <strong>385.80</strong> days, which is just over 1 year!\u00a0\ud83e\udd2f</blockquote>\n<p>Yep! It\u2019s difficult for human brain to estimate large numbers! Let\u2019s optimise\u00a0now?!</p>\n<p>One of my early hypothesis is that we are spending so much time tilting our platform_state that we are bound to get repeated inputs for multiple directions! We can probably make it faster by just introducing a cache to track input and output for tilt_platform function!</p>\n<p>Let\u2019s test that, using our same unscientific test above (it will be interesting to see how memory size grows as these are 4 computations per cycle, totalling to <strong>4 billion computations</strong>!):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*shey_5pM8zAz9jdVQeP5Yg.png\"><figcaption>Added cache!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wNLS1z6SOaAlXaFYAsUl2g.gif\"><figcaption>~300 / 10 seconds, no\u00a0avail!</figcaption></figure><p>Let\u2019s rethink now! Brute force won\u2019t work\u00a0clearly!</p>\n<p>I still firmly beleive there has to be some kind of a repeatition after a while and we just need to find the cycle\u00a0here!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/889/1*7vZuAx0YRT2j69W9IVPM5A.png\"></figure><p>Added some logging, let\u2019s see our test\u00a0input:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/721/1*1tgBP55O98m1dM-VYS2vrQ.png\"></figure><p>Clearly we can see, there is <strong>some cycle going</strong> on\u00a0here!</p>\n<blockquote>\ud83d\udca1Now, all we need to do is, <strong>find the cycle length</strong> and <strong>find the cycle elements</strong>, and then by the <strong>magic of modulus</strong> % we can directly find the platform_state, as if what it will be after 1000000000 cycles!</blockquote>\n<p>.</p>\n<p>.</p>\n<blockquote>30 minutes and some debugging later!</blockquote>\n<p>.</p>\n<p>.</p>\n<p>Whipped up this <strong>spaghetti</strong> code (I promise, <strong>I will fix</strong>\u00a0this):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yfPl8wqtUZiv9icCAo884g.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u2705 tilt_platform_cycle with 1 cycle passed<br>\u2705 tilt_platform_cycle with 2 cycles passed<br>\u2705 tilt_platform_cycle with 3 cycles passed<br>\u2705 test_calculate_load_on_north_beam_1000000000_cycles passed<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>Finally! \ud83d\ude4f</p>\n<p>Now, let\u2019s run for our puzzle\u00a0input?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>\u203c\ufe0f Total load on the north beam after 1000000000 cycles is XXXXX<br><br>[Done] exited with code=0 in 4.166 seconds</pre>\n<p>We have an answer in <strong>4.166 seconds</strong>, let\u2019s put this in the answer box\u00a0and\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/957/1*ElrQjU_yhrwuoxyIGDQFWg.png\"><figcaption>Finally \ud83d\ude4f</figcaption></figure><p>Here\u2019s our pythonic and optimized code:</p>\n<pre># Day 14 - Parabolic Reflector Dish<br><br>from enum import Enum<br><br><br>class TiltDirection(Enum):<br>    North = \"NORTH\"<br>    South = \"SOUTH\"<br>    East = \"EAST\"<br>    West = \"WEST\"<br><br><br>class Tile(Enum):<br>    Empty = \".\"<br>    CubeRock = \"#\"<br>    RoundRock = \"O\"<br><br><br>def tilt_platform(platform_state, direction):<br>    rows, cols = len(platform_state), len(platform_state[0])<br>    delta = {<br>        TiltDirection.North: (0, -1),<br>        TiltDirection.South: (0, 1),<br>        TiltDirection.East: (1, 0),<br>        TiltDirection.West: (-1, 0)<br>    }[direction]<br><br>    def is_valid_position(row, col):<br>        return 0 &lt;= row &lt; rows and 0 &lt;= col &lt; cols<br><br>    def move_rock(start_row, start_col):<br>        row, col = start_row, start_col<br>        while is_valid_position(row + delta[1], col + delta[0]) and \\<br>                platform_state[row + delta[1]][col + delta[0]] == Tile.Empty.value:<br>            platform_state[row][col] = Tile.Empty.value<br>            row, col = row + delta[1], col + delta[0]<br>            platform_state[row][col] = Tile.RoundRock.value<br><br>    if direction in [TiltDirection.North, TiltDirection.West]:<br>        range_func = range<br>    else:<br>        range_func = lambda start, end: range(end - 1, start - 1, -1)<br><br>    for i in range_func(0, rows):<br>        for j in range_func(0, cols):<br>            if platform_state[i][j] == Tile.RoundRock.value:<br>                move_rock(i, j)<br><br>    return platform_state<br><br><br>def tilt_platform_cycle(platform_state, num_cycles=1):    <br>    platform_cache = {}  # Cache for storing seen platform states<br>    cycle_patterns = []  # List to store unique states forming a cycle<br>    cycle_start_point = None<br><br><br>    for idx in range(1, num_cycles+1):<br>        # Tilt platform in all directions<br>        for direction in [TiltDirection.North, TiltDirection.West, TiltDirection.South, TiltDirection.East]:<br>            platform_state = tilt_platform(platform_state, direction)<br><br>        # Generate a key for the current state<br>        platform_state_key = \"\\n\".join([\" \".join(map(str, row)) for row in platform_state])<br><br>        # Check if the current state has been seen before<br>        if platform_state_key in platform_cache:<br>            if cycle_start_point is None:<br>                cycle_start_point = platform_cache[platform_state_key]<br>                cycle_patterns.append(platform_state_key)<br>                continue<br><br>            # Start of the cycle found, calculate the index in the cycle pattern<br>            if platform_state_key == cycle_patterns[0]:<br>                cycle_length = len(cycle_patterns)<br>                cycle_index = (num_cycles - cycle_start_point) % cycle_length<br>                return [list(row) for row in cycle_patterns[cycle_index].split(\"\\n\")]<br><br>            # New state in the cycle<br>            if platform_state_key not in cycle_patterns:<br>                cycle_patterns.append(platform_state_key)<br>            continue<br><br>        # Store the new state in the cache<br>        platform_cache[platform_state_key] = idx<br>        if cycle_start_point is not None and platform_state_key not in cycle_patterns:<br>            cycle_patterns.append(platform_state_key)<br><br>    return platform_state<br><br><br>def calculate_load_on_north_beam(tilted_platform_state):<br>    return sum((len(tilted_platform_state) - i) * row.count(Tile.RoundRock.value)<br>               for i, row in enumerate(tilted_platform_state))<br><br><br>def part_one():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"\u2757\ufe0f Total load on the north beam is {total_load}\")<br><br><br>def part_two():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1000000000)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"\u203c\ufe0f Total load on the north beam after 1000000000 cycles is {total_load}\")<br><br><br>def test_tilt_platform_cycle():<br>    platform_state_og = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state_with_1_cycle = \"\"\".....#....<br>....#...O#<br>...OO##...<br>.OO#......<br>.....OOO#.<br>.O#...O#.#<br>....O#....<br>......OOOO<br>#...O###..<br>#..OO#....\"\"\"<br><br>    expected_platform_state_with_2_cycles = \"\"\".....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#..OO###..<br>#.OOO#...O\"\"\"<br><br>    expected_platform_state_with_3_cycles = \"\"\".....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#...O###.O<br>#.OOO#...O\"\"\"<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_1_cycle = [<br>        list(row) for row in expected_platform_state_with_1_cycle.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_1_cycle<br>    ), f\"Expected {expected_platform_state_with_1_cycle}, got {tilted_platform_state}\"<br>    print(\"\u2705 tilt_platform_cycle with 1 cycle passed\")<br><br>    # reseting platform_state<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_2_cycles = [<br>        list(row) for row in expected_platform_state_with_2_cycles.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 2)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_2_cycles<br>    ), f\"Expected {expected_platform_state_with_2_cycles}, got {tilted_platform_state}\"<br>    print(\"\u2705 tilt_platform_cycle with 2 cycles passed\")<br><br>    # reseting platform_state<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_3_cycles = [<br>        list(row) for row in expected_platform_state_with_3_cycles.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 3)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_3_cycles<br>    ), f\"Expected {expected_platform_state_with_3_cycles}, got {tilted_platform_state}\"<br>    print(\"\u2705 tilt_platform_cycle with 3 cycles passed\")<br><br><br>def test_tilt_platform():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state = \"\"\"OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    assert tilted_platform_state == [<br>        list(row) for row in expected_platform_state.split(\"\\n\")<br>    ], f\"Expected {expected_platform_state}, got {tilted_platform_state}\"<br>    print(\"\u2705 tilt_platform passed\")<br><br><br>def test_calculate_load_on_north_beam():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 136, f\"Expected 136, got {total_load}\"<br>    print(\"\u2705 test_calculate_load_on_north_beam passed\")<br><br><br>def test_calculate_load_on_north_beam_1000000000_cycles():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1000000000)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 64, f\"Expected 64, got {total_load}\"<br>    print(\"\u2705 test_calculate_load_on_north_beam_1000000000_cycles passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_tilt_platform()<br>    test_calculate_load_on_north_beam()<br>    part_one()<br><br>    test_tilt_platform_cycle()<br>    test_calculate_load_on_north_beam_1000000000_cycles()<br>    part_two()</pre>\n<p>I am sure there is more juice left to squeeze as we can further optimize this, but I am tired now! I will most likely <strong>come back</strong> during holidays to optimise this to atleast <strong>sub-second compute\u00a0time</strong>.</p>\n<p>Stay tuned!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=10760f12f5a5\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["python","christmas","advent-of-code","problem-solving","advent-of-code-2023"]},{"title":"[Day 13] Point of Incidence // Advent of Code 2023 (Python)","pubDate":"2023-12-20 19:03:57","link":"https://medium.com/@jatinkrmalik/day-13-point-of-incidence-advent-of-code-2023-python-4fea00eb98fb?source=rss-ec576e4b06b0------2","guid":"https://medium.com/p/4fea00eb98fb","author":"Jatin K Malik","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*rfUmh-2ouPC2eg70\"><figcaption>Point of Incidence</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/13\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>With your help, the hot springs team locates an appropriate spring which launches you neatly and precisely up to the edge of Lava\u00a0Island.</blockquote>\n<blockquote>There\u2019s just one problem: you don\u2019t see any\u00a0lava.</blockquote>\n<blockquote>You do see a lot of ash and igneous rock; there are even what look like gray mountains scattered around. After a while, you make your way to a nearby cluster of mountains only to discover that the valley between them is completely full of large mirrors. Most of the mirrors seem to be aligned in a consistent way; perhaps you should head in that direction?</blockquote>\n<blockquote>As you move through the valley of mirrors, you find that several of them have fallen from the large metal frames keeping them in place. The mirrors are extremely flat and shiny, and many of the fallen mirrors have lodged into the ash at strange angles. Because the terrain is all one color, it\u2019s hard to tell where it\u2019s safe to walk or where you\u2019re about to run into a\u00a0mirror.</blockquote>\n<blockquote>You note down the patterns of ash (.) and rocks (#) that you see as you walk (your puzzle input); perhaps by carefully analyzing these patterns, you can figure out where the mirrors\u00a0are!</blockquote>\n<blockquote>For example:</blockquote>\n<blockquote>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</blockquote>\n<blockquote>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</blockquote>\n<blockquote>To find the reflection in each pattern, you need to find a perfect reflection across either a horizontal line between two rows or across a vertical line between two\u00a0columns.</blockquote>\n<blockquote>In the first pattern, the reflection is across a vertical line between two columns; arrows on each of the two columns point at the line between the\u00a0columns:</blockquote>\n<blockquote>123456789<br> &gt;&lt; <br>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br> &gt;&lt; <br>123456789</blockquote>\n<blockquote>In this pattern, the line of reflection is the vertical line between columns 5 and 6. Because the vertical line is not perfectly in the middle of the pattern, part of the pattern (column 1) has nowhere to reflect onto and can be ignored; every other column has a reflected column within the pattern and must match exactly: column 2 matches column 9, column 3 matches 8, 4 matches 7, and 5 matches\u00a06.</blockquote>\n<blockquote>The second pattern reflects across a horizontal line\u00a0instead:</blockquote>\n<blockquote>1 #...##..# 1<br>2 #....#..# 2<br>3\u00a0..##..### 3<br>4v#####.##.v4<br>5^#####.##.^5<br>6\u00a0..##..### 6<br>7 #....#..# 7</blockquote>\n<blockquote>This pattern reflects across the horizontal line between rows 4 and 5. Row 1 would reflect with a hypothetical row 8, but since that\u2019s not in the pattern, row 1 doesn\u2019t need to match anything. The remaining rows match: row 2 matches row 7, row 3 matches row 6, and row 4 matches row\u00a05.</blockquote>\n<blockquote>To summarize your pattern notes, add up the number of columns to the left of each vertical line of reflection; to that, also add 100 multiplied by the number of rows above each horizontal line of reflection. In the above example, the first pattern\u2019s vertical line has 5 columns to its left and the second pattern's horizontal line has 4 rows above it, a total of\u00a0405.</blockquote>\n<blockquote>Find the line of reflection in each of the patterns in your notes. What number do you get after summarizing all of your\u00a0notes?</blockquote>\n<blockquote>A mirror maze?! I have always loved them since childhood!</blockquote>\n<p>Let\u2019s understand the problem! We are given a pattern of ash (.) and rocks (#) and we need to figure out a line of mirrors which can be either be in between rows or columns casting a perfect reflection in our\u00a0pattern!</p>\n<p>Let\u2019s study the example with a visualization, for the given\u00a0input:</p>\n<pre>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</pre>\n<p>We can observe that the line of reflection is in b/w 5th and 6th column and our 1st column can be\u00a0ignored!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/858/1*w9RqnyQzNe7fby2oGhrycw.png\"><figcaption>Pattern 1</figcaption></figure><p>Similarly, for another\u00a0example:</p>\n<pre>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</pre>\n<p>We can see that line of reflection is in b/w 4th and 5th row and our 1st row can be\u00a0ignored!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/523/1*OpsohpC1DbR87xeu16gqMw.png\"><figcaption>Pattern 2</figcaption></figure><p>Now, the puzzle wants us to summarize these patterns and add\u00a0up:</p>\n<ul>\n<li>the <strong>number of columns</strong> to the <strong>left of each vertical line of reflection</strong>\n</li>\n<li>add <strong>100 multiplied</strong> by the number of <strong>rows</strong> <strong>above each horizontal line of reflection</strong>\n</li>\n</ul>\n<p>So, for the given example, the answer\u00a0becomes:</p>\n<blockquote>5 (pattern 1) + 4 (pattern 2) * 100 =\u00a0405</blockquote>\n<p>This is pretty interesting! My mind is trying to wander toward the Palindrome approach, especially for even numbers, but let me first write some test code for the base case given\u00a0above!</p>\n<blockquote>\ud83d\udca1 A quick analysis of puzzle input shows that we will have multiple patterns to process, so we will structure our code accordingly!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/543/1*e2OU1KdkRb9On0B06VUUQQ.png\"></figure><p>Let\u2019s write code now, as mentioned, my initial idea is to just follow the naive palindrome approach, where I will try to compare ch[i] == ch[i-1] and will do a fan out approach to go both ways till we run out of\u00a0bounds:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/583/1*OV0bZhDBM5J44Ujz5284JA.png\"></figure><p>Now we can adapt the same approach to go <strong>row by row</strong>, and then if not found, we go <strong>column by column </strong>and then return the point as per the calculation for horizontal line v/s vertical line as per the\u00a0puzzle.</p>\n<p>.</p>\n<p>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*kwZ5gQR1bAGMWsA00gb9ow.png\"></figure><p>Few debugging sessions\u00a0later!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>\u2705 summarize_pattern passed<br><br>[Done] exited with code=0 in 0.065 seconds</pre>\n<p>This is a bit bruteforce approach, but seems pretty fast for 2 patterns, 0.065 seconds, let\u2019s load up our puzzle input and see how it runs as we seem to only have 100 patterns!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iAnwZ7o1zY1wgny3evWzyQ.png\"><figcaption>I am sure there will be a nutty edge case somewhere in\u00a0here!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/682/1*tysBMJDX-Q6_Mfq1wSeY4Q.png\"><figcaption>Let\u2019s run this!\u00a0\ud83e\udd1e</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>\u2757\ufe0f Summarizing all patterns in Part 1: XXXXXX<br><br>[Done] exited with code=0 in 0.051 seconds</pre>\n<p>Woah! We have an answer in just <strong>0.051</strong> seconds!\u00a0\ud83e\udd2f</p>\n<p>Let\u2019s input this in the answer box\u00a0and\u2026.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/879/1*H4vBV50RauNGTNK_qEO3aA.png\"><figcaption>\ud83d\udc6f\u200d\u2640\ufe0f\ud83d\udc6f\u200d\u2640\ufe0f\ud83d\udc6f\u200d\u2640\ufe0f</figcaption></figure><p>Correct in first try and with an amazing runtime! Though I am sure as soon as I click on Part Two, it\u2019s going to wreck our code!\u00a0\ud83e\udd13</p>\n<p>Here\u2019s our raw code till now, we will optimise it in Part 2, like\u00a0always:</p>\n<pre># Day 13 - Point of Incidence<br><br>from enum import Enum<br><br>class Mode(Enum):<br>    ROW = \"row\"<br>    COLUMN = \"column\"<br><br>def is_perfect_reflection(prev, next, pattern, mode):<br>    if mode == Mode.ROW:<br>        while prev &gt;= 0 and next &lt; len(pattern):<br>            if pattern[prev] != pattern[next]:<br>                return False<br>            prev -= 1<br>            next += 1<br><br>        return True<br><br>    elif mode == Mode.COLUMN:<br>        while prev &gt;= 0 and next &lt; len(pattern[0]):<br>            for i in range(len(pattern)):<br>                if pattern[i][prev] != pattern[i][next]:<br>                    return False<br>            prev -= 1<br>            next += 1<br><br>        return True<br><br>    raise Exception(\"Invalid mode\")<br><br>def find_point_of_reflection(pattern, mode):<br>    if mode == Mode.ROW:<br>        for i in range(1, len(pattern)):<br>            if pattern[i-1] == pattern[i]:<br>                if is_perfect_reflection(i-1, i, pattern, Mode.ROW):<br>                    return i<br><br>    if mode == Mode.COLUMN:<br>        for j in range(1, len(pattern[0])):<br>            prev_col, next_col = [], []<br>            for i in range(0, len(pattern)):<br>                prev_col.append(pattern[i][j-1])<br>                next_col.append(pattern[i][j])<br>            if prev_col == next_col:<br>                if is_perfect_reflection(j-1, j, pattern, Mode.COLUMN):<br>                    return j<br><br>def analyze_pattern(pattern):<br>    pattern_grid = [list(row) for row in pattern.strip().split(\"\\n\")]<br><br>    # Find the point of reflection row by row<br>    point = find_point_of_reflection(pattern_grid, Mode.ROW)<br>    if point:<br>        return point * 100<br><br>    # Find the point of reflection column by column<br>    point = find_point_of_reflection(pattern_grid, Mode.COLUMN)<br>    if point:<br>        return point<br><br>    raise Exception(\"No point of reflection found\")<br><br>def summarize_patterns(patterns):<br>    sum = 0<br>    for pattern in patterns.split(\"\\n\\n\"):<br>        sum += analyze_pattern(pattern)<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns)<br><br>    print(f\"\u2757\ufe0f Summarizing all patterns in Part 1: {sum}\")<br><br>def test_summarize_patterns():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br>    sum = summarize_patterns(patterns)<br>    assert sum == 405, f\"Expected 405, got {sum}\"<br>    print(\"\u2705 summarize_pattern passed\")<br><br>if __name__ == \"__main__\":<br>    test_summarize_patterns()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>You resume walking through the valley of mirrors and\u200a\u2014\u200aSMACK!\u200a\u2014\u200arun directly into one. Hopefully nobody was watching, because that must have been pretty embarrassing.</blockquote>\n<blockquote>Upon closer inspection, you discover that every mirror has exactly one smudge: exactly one\u00a0. or # should be the opposite\u00a0type.</blockquote>\n<blockquote>In each pattern, you\u2019ll need to locate and fix the smudge that causes a different reflection line to be valid. (The old reflection line won\u2019t necessarily continue being valid after the smudge is\u00a0fixed.)</blockquote>\n<blockquote>Here\u2019s the above example\u00a0again:</blockquote>\n<blockquote>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</blockquote>\n<blockquote>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</blockquote>\n<blockquote>The first pattern\u2019s smudge is in the top-left corner. If the top-left #were instead\u00a0., it would have a different, horizontal line of reflection:</blockquote>\n<blockquote>1\u00a0..##..##. 1<br>2\u00a0..#.##.#. 2<br>3v##......#v3<br>4^##......#^4<br>5\u00a0..#.##.#. 5<br>6\u00a0..##..##. 6<br>7 #.#.##.#. 7</blockquote>\n<blockquote>With the smudge in the top-left corner repaired, a new horizontal line of reflection between rows 3 and 4 now exists. Row 7 has no corresponding reflected row and can be ignored, but every other row matches exactly: row 1 matches row 6, row 2 matches row 5, and row 3 matches row\u00a04.</blockquote>\n<blockquote>In the second pattern, the smudge can be fixed by changing the fifth symbol on row 2 from\u00a0. to\u00a0#:</blockquote>\n<blockquote>1v#...##..#v1<br>2^#...##..#^2<br>3\u00a0..##..### 3<br>4 #####.##. 4<br>5 #####.##. 5<br>6\u00a0..##..### 6<br>7 #....#..# 7</blockquote>\n<blockquote>Now, the pattern has a different horizontal line of reflection between rows 1 and\u00a02.</blockquote>\n<blockquote>Summarize your notes as before, but instead use the new different reflection lines. In this example, the first pattern\u2019s new horizontal line has 3 rows above it and the second pattern\u2019s new horizontal line has 1 row above it, summarizing to the value\u00a0400.</blockquote>\n<blockquote>In each pattern, fix the smudge and find the different line of reflection. What number do you get after summarizing the new reflection line in each pattern in your\u00a0notes?</blockquote>\n<p>And\u2026</p>\n<blockquote>every mirror has exactly one smudge: exactly one\u00a0. or # should be the opposite\u00a0type.</blockquote>\n<p>We are back to permutations and combinations! \ud83e\udea6</p>\n<p>\ud83d\udcad Carrying on with our brute force approach, since our code was pretty blazing fast, we can extend our solution by adding some extra steps and\u00a0loops.</p>\n<p>Introducing \u2018smudges\u2019, where exactly one character in each pattern is incorrect and needs to be flipped to find a new line of reflection. We can follow these\u00a0steps:</p>\n<ol>\n<li>\n<strong>Identify the Smudge</strong>: Iterate through each cell of the pattern. <br> a. For each cell, flip its value (from\u00a0. to # or vice versa) <br> b. then check if this change results in a <strong>valid reflection line different from the original</strong>. <br> c. if <strong>yes</strong>, this is the <strong>smudge</strong> we need to fix, else <strong>continue</strong>\u00a0loop</li>\n<li>\n<strong>Summarize the Patterns</strong>: Calculate the summary based on the new reflection lines.</li>\n</ol>\n<p>Let\u2019s try\u00a0this?</p>\n<blockquote>\ud83d\udca1This approaches hinges upon the fact that puzzle states, there\u2019s exactly 1 smudge in each\u00a0pattern!</blockquote>\n<blockquote>\u2757\ufe0fEdge case: We need to ensure, that everytime we find a new reflection point, we need to compare it with original reflection point along with the mode, as sometimes the value can be same, but it can be for rows and columns respectively.<br>(new_reflection_point, mode)\u00a0!= (original_reflection_point, original_mode)</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IZm5QwQGOZ_qbTGbAbsJKg.png\"><figcaption>Tons of debugging later!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SB6a_qv-iqZ9-sSvoaGStw.png\"><figcaption>Masterpiece!</figcaption></figure><p>Let\u2019s see if it works for our new test\u00a0case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/579/1*ozPJTOamPgPqdVYvEUUHUQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>\u2705 summarize_pattern_with_smudges passed<br><br>[Done] exited with code=0 in 0.071 seconds</pre>\n<p>\u2705 in just <strong>0.071 seconds</strong>! This gives me\u00a0hope!</p>\n<p>Let\u2019s run it for the puzzle\u00a0input?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>\u203c\ufe0f Summarizing all patterns in Part 2: XXXXX<br><br>[Done] exited with code=0 in 0.281 seconds</pre>\n<p>Done! Let\u2019s see if our answer is correct?\u00a0\ud83d\udc40</p>\n<p>And\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*-GgwQaaV9TTLNX0awHsjbg.png\"><figcaption>\ud83e\udd41</figcaption></figure><p>Here\u2019s our code with a bruteforce approach, works pretty quick on my M1 Macbook Pro. I might come back later to solve this in a more novel way, but since I am already running behind in AdventOfCode, I will just move on!\u00a0\ud83d\ude03</p>\n<pre># Day 13 - Point of Incidence<br><br>from enum import Enum<br>import itertools<br><br><br>class Mode(Enum):<br>    ROW = \"row\"<br>    COLUMN = \"column\"<br><br><br>class MirrorPatternAnalyzer:<br>    def __init__(self, pattern):<br>        self.pattern = [list(row) for row in pattern.strip().split(\"\\n\")]<br><br>    @staticmethod<br>    def flip_char(char):<br>        return \"#\" if char == \".\" else \".\"<br><br>    def is_perfect_reflection(self, index, mode):<br>        if mode == Mode.ROW:<br>            prev, next = index - 1, index<br>            while prev &gt;= 0 and next &lt; len(self.pattern):<br>                if self.pattern[prev] != self.pattern[next]:<br>                    return False<br>                prev -= 1<br>                next += 1<br>            return True<br><br>        elif mode == Mode.COLUMN:<br>            prev, next = index - 1, index<br>            while prev &gt;= 0 and next &lt; len(self.pattern[0]):<br>                if any(<br>                    self.pattern[row][prev] != self.pattern[row][next]<br>                    for row in range(len(self.pattern))<br>                ):<br>                    return False<br>                prev -= 1<br>                next += 1<br>            return True<br><br>        raise ValueError(\"Invalid mode\")<br><br>    def find_point_of_reflection(self, mode):<br>        range_to_check = range(<br>            1, len(self.pattern) if mode == Mode.ROW else len(self.pattern[0])<br>        )<br>        for i in range_to_check:<br>            if self.is_perfect_reflection(i, mode):<br>                return i<br>        return None<br><br>    def try_fix_smudge_and_find_reflection(<br>        self, original_reflection_point, original_mode<br>    ):<br>        for i in range(len(self.pattern)):<br>            for j in range(len(self.pattern[i])):<br>                self.pattern[i][j] = MirrorPatternAnalyzer.flip_char(self.pattern[i][j])<br>                for mode in [Mode.ROW, Mode.COLUMN]:<br>                    new_reflection_point = self.find_point_of_reflection(mode)<br>                    if new_reflection_point and (new_reflection_point, mode) != (<br>                        original_reflection_point,<br>                        original_mode,<br>                    ):<br>                        return new_reflection_point, mode<br>                self.pattern[i][j] = MirrorPatternAnalyzer.flip_char(self.pattern[i][j])<br>        return original_reflection_point, original_mode<br><br>    def analyze(self, with_smudge=False):<br>        for mode in [Mode.ROW, Mode.COLUMN]:<br>            reflection_point = self.find_point_of_reflection(mode)<br>            if reflection_point is not None:<br>                if with_smudge:<br>                    (<br>                        new_reflection_point,<br>                        new_mode,<br>                    ) = self.try_fix_smudge_and_find_reflection(reflection_point, mode)<br>                    if new_mode == Mode.ROW:<br>                        return new_reflection_point * 100<br>                    else:<br>                        return new_reflection_point<br>                else:<br>                    return (<br>                        reflection_point * 100 if mode == Mode.ROW else reflection_point<br>                    )<br>        raise Exception(\"No valid reflection line found\")<br><br><br>def summarize_patterns(patterns, with_smudges=False):<br>    total_sum = 0<br>    for i, pattern in enumerate(patterns.split(\"\\n\\n\")):<br>        analyzer = MirrorPatternAnalyzer(pattern)<br>        total_sum += analyzer.analyze(with_smudge=with_smudges)<br>    return total_sum<br><br><br>def part_one():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns)<br><br>    print(f\"\u2757\ufe0f Summarizing all patterns in Part 1: {sum}\")<br><br><br>def test_summarize_patterns():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br>    sum = summarize_patterns(patterns)<br>    assert sum == 405, f\"Expected 405, got {sum}\"<br>    print(\"\u2705 summarize_pattern passed\")<br><br><br>def part_two():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns, with_smudges=True)<br>    print(f\"\u203c\ufe0f Summarizing all patterns in Part 2: {sum}\")<br><br><br>def test_summarize_patterns_with_smudges():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br><br>    sum = summarize_patterns(patterns, with_smudges=True)<br>    assert sum == 400, f\"Expected 400, got {sum}\"<br>    print(\"\u2705 summarize_pattern_with_smudges passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_summarize_patterns()<br>    part_one()<br><br>    test_summarize_patterns_with_smudges()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4fea00eb98fb\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*rfUmh-2ouPC2eg70\"><figcaption>Point of Incidence</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/13\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>With your help, the hot springs team locates an appropriate spring which launches you neatly and precisely up to the edge of Lava\u00a0Island.</blockquote>\n<blockquote>There\u2019s just one problem: you don\u2019t see any\u00a0lava.</blockquote>\n<blockquote>You do see a lot of ash and igneous rock; there are even what look like gray mountains scattered around. After a while, you make your way to a nearby cluster of mountains only to discover that the valley between them is completely full of large mirrors. Most of the mirrors seem to be aligned in a consistent way; perhaps you should head in that direction?</blockquote>\n<blockquote>As you move through the valley of mirrors, you find that several of them have fallen from the large metal frames keeping them in place. The mirrors are extremely flat and shiny, and many of the fallen mirrors have lodged into the ash at strange angles. Because the terrain is all one color, it\u2019s hard to tell where it\u2019s safe to walk or where you\u2019re about to run into a\u00a0mirror.</blockquote>\n<blockquote>You note down the patterns of ash (.) and rocks (#) that you see as you walk (your puzzle input); perhaps by carefully analyzing these patterns, you can figure out where the mirrors\u00a0are!</blockquote>\n<blockquote>For example:</blockquote>\n<blockquote>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</blockquote>\n<blockquote>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</blockquote>\n<blockquote>To find the reflection in each pattern, you need to find a perfect reflection across either a horizontal line between two rows or across a vertical line between two\u00a0columns.</blockquote>\n<blockquote>In the first pattern, the reflection is across a vertical line between two columns; arrows on each of the two columns point at the line between the\u00a0columns:</blockquote>\n<blockquote>123456789<br> &gt;&lt; <br>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br> &gt;&lt; <br>123456789</blockquote>\n<blockquote>In this pattern, the line of reflection is the vertical line between columns 5 and 6. Because the vertical line is not perfectly in the middle of the pattern, part of the pattern (column 1) has nowhere to reflect onto and can be ignored; every other column has a reflected column within the pattern and must match exactly: column 2 matches column 9, column 3 matches 8, 4 matches 7, and 5 matches\u00a06.</blockquote>\n<blockquote>The second pattern reflects across a horizontal line\u00a0instead:</blockquote>\n<blockquote>1 #...##..# 1<br>2 #....#..# 2<br>3\u00a0..##..### 3<br>4v#####.##.v4<br>5^#####.##.^5<br>6\u00a0..##..### 6<br>7 #....#..# 7</blockquote>\n<blockquote>This pattern reflects across the horizontal line between rows 4 and 5. Row 1 would reflect with a hypothetical row 8, but since that\u2019s not in the pattern, row 1 doesn\u2019t need to match anything. The remaining rows match: row 2 matches row 7, row 3 matches row 6, and row 4 matches row\u00a05.</blockquote>\n<blockquote>To summarize your pattern notes, add up the number of columns to the left of each vertical line of reflection; to that, also add 100 multiplied by the number of rows above each horizontal line of reflection. In the above example, the first pattern\u2019s vertical line has 5 columns to its left and the second pattern's horizontal line has 4 rows above it, a total of\u00a0405.</blockquote>\n<blockquote>Find the line of reflection in each of the patterns in your notes. What number do you get after summarizing all of your\u00a0notes?</blockquote>\n<blockquote>A mirror maze?! I have always loved them since childhood!</blockquote>\n<p>Let\u2019s understand the problem! We are given a pattern of ash (.) and rocks (#) and we need to figure out a line of mirrors which can be either be in between rows or columns casting a perfect reflection in our\u00a0pattern!</p>\n<p>Let\u2019s study the example with a visualization, for the given\u00a0input:</p>\n<pre>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</pre>\n<p>We can observe that the line of reflection is in b/w 5th and 6th column and our 1st column can be\u00a0ignored!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/858/1*w9RqnyQzNe7fby2oGhrycw.png\"><figcaption>Pattern 1</figcaption></figure><p>Similarly, for another\u00a0example:</p>\n<pre>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</pre>\n<p>We can see that line of reflection is in b/w 4th and 5th row and our 1st row can be\u00a0ignored!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/523/1*OpsohpC1DbR87xeu16gqMw.png\"><figcaption>Pattern 2</figcaption></figure><p>Now, the puzzle wants us to summarize these patterns and add\u00a0up:</p>\n<ul>\n<li>the <strong>number of columns</strong> to the <strong>left of each vertical line of reflection</strong>\n</li>\n<li>add <strong>100 multiplied</strong> by the number of <strong>rows</strong> <strong>above each horizontal line of reflection</strong>\n</li>\n</ul>\n<p>So, for the given example, the answer\u00a0becomes:</p>\n<blockquote>5 (pattern 1) + 4 (pattern 2) * 100 =\u00a0405</blockquote>\n<p>This is pretty interesting! My mind is trying to wander toward the Palindrome approach, especially for even numbers, but let me first write some test code for the base case given\u00a0above!</p>\n<blockquote>\ud83d\udca1 A quick analysis of puzzle input shows that we will have multiple patterns to process, so we will structure our code accordingly!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/543/1*e2OU1KdkRb9On0B06VUUQQ.png\"></figure><p>Let\u2019s write code now, as mentioned, my initial idea is to just follow the naive palindrome approach, where I will try to compare ch[i] == ch[i-1] and will do a fan out approach to go both ways till we run out of\u00a0bounds:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/583/1*OV0bZhDBM5J44Ujz5284JA.png\"></figure><p>Now we can adapt the same approach to go <strong>row by row</strong>, and then if not found, we go <strong>column by column </strong>and then return the point as per the calculation for horizontal line v/s vertical line as per the\u00a0puzzle.</p>\n<p>.</p>\n<p>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*kwZ5gQR1bAGMWsA00gb9ow.png\"></figure><p>Few debugging sessions\u00a0later!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>\u2705 summarize_pattern passed<br><br>[Done] exited with code=0 in 0.065 seconds</pre>\n<p>This is a bit bruteforce approach, but seems pretty fast for 2 patterns, 0.065 seconds, let\u2019s load up our puzzle input and see how it runs as we seem to only have 100 patterns!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iAnwZ7o1zY1wgny3evWzyQ.png\"><figcaption>I am sure there will be a nutty edge case somewhere in\u00a0here!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/682/1*tysBMJDX-Q6_Mfq1wSeY4Q.png\"><figcaption>Let\u2019s run this!\u00a0\ud83e\udd1e</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>\u2757\ufe0f Summarizing all patterns in Part 1: XXXXXX<br><br>[Done] exited with code=0 in 0.051 seconds</pre>\n<p>Woah! We have an answer in just <strong>0.051</strong> seconds!\u00a0\ud83e\udd2f</p>\n<p>Let\u2019s input this in the answer box\u00a0and\u2026.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/879/1*H4vBV50RauNGTNK_qEO3aA.png\"><figcaption>\ud83d\udc6f\u200d\u2640\ufe0f\ud83d\udc6f\u200d\u2640\ufe0f\ud83d\udc6f\u200d\u2640\ufe0f</figcaption></figure><p>Correct in first try and with an amazing runtime! Though I am sure as soon as I click on Part Two, it\u2019s going to wreck our code!\u00a0\ud83e\udd13</p>\n<p>Here\u2019s our raw code till now, we will optimise it in Part 2, like\u00a0always:</p>\n<pre># Day 13 - Point of Incidence<br><br>from enum import Enum<br><br>class Mode(Enum):<br>    ROW = \"row\"<br>    COLUMN = \"column\"<br><br>def is_perfect_reflection(prev, next, pattern, mode):<br>    if mode == Mode.ROW:<br>        while prev &gt;= 0 and next &lt; len(pattern):<br>            if pattern[prev] != pattern[next]:<br>                return False<br>            prev -= 1<br>            next += 1<br><br>        return True<br><br>    elif mode == Mode.COLUMN:<br>        while prev &gt;= 0 and next &lt; len(pattern[0]):<br>            for i in range(len(pattern)):<br>                if pattern[i][prev] != pattern[i][next]:<br>                    return False<br>            prev -= 1<br>            next += 1<br><br>        return True<br><br>    raise Exception(\"Invalid mode\")<br><br>def find_point_of_reflection(pattern, mode):<br>    if mode == Mode.ROW:<br>        for i in range(1, len(pattern)):<br>            if pattern[i-1] == pattern[i]:<br>                if is_perfect_reflection(i-1, i, pattern, Mode.ROW):<br>                    return i<br><br>    if mode == Mode.COLUMN:<br>        for j in range(1, len(pattern[0])):<br>            prev_col, next_col = [], []<br>            for i in range(0, len(pattern)):<br>                prev_col.append(pattern[i][j-1])<br>                next_col.append(pattern[i][j])<br>            if prev_col == next_col:<br>                if is_perfect_reflection(j-1, j, pattern, Mode.COLUMN):<br>                    return j<br><br>def analyze_pattern(pattern):<br>    pattern_grid = [list(row) for row in pattern.strip().split(\"\\n\")]<br><br>    # Find the point of reflection row by row<br>    point = find_point_of_reflection(pattern_grid, Mode.ROW)<br>    if point:<br>        return point * 100<br><br>    # Find the point of reflection column by column<br>    point = find_point_of_reflection(pattern_grid, Mode.COLUMN)<br>    if point:<br>        return point<br><br>    raise Exception(\"No point of reflection found\")<br><br>def summarize_patterns(patterns):<br>    sum = 0<br>    for pattern in patterns.split(\"\\n\\n\"):<br>        sum += analyze_pattern(pattern)<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns)<br><br>    print(f\"\u2757\ufe0f Summarizing all patterns in Part 1: {sum}\")<br><br>def test_summarize_patterns():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br>    sum = summarize_patterns(patterns)<br>    assert sum == 405, f\"Expected 405, got {sum}\"<br>    print(\"\u2705 summarize_pattern passed\")<br><br>if __name__ == \"__main__\":<br>    test_summarize_patterns()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>You resume walking through the valley of mirrors and\u200a\u2014\u200aSMACK!\u200a\u2014\u200arun directly into one. Hopefully nobody was watching, because that must have been pretty embarrassing.</blockquote>\n<blockquote>Upon closer inspection, you discover that every mirror has exactly one smudge: exactly one\u00a0. or # should be the opposite\u00a0type.</blockquote>\n<blockquote>In each pattern, you\u2019ll need to locate and fix the smudge that causes a different reflection line to be valid. (The old reflection line won\u2019t necessarily continue being valid after the smudge is\u00a0fixed.)</blockquote>\n<blockquote>Here\u2019s the above example\u00a0again:</blockquote>\n<blockquote>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</blockquote>\n<blockquote>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</blockquote>\n<blockquote>The first pattern\u2019s smudge is in the top-left corner. If the top-left #were instead\u00a0., it would have a different, horizontal line of reflection:</blockquote>\n<blockquote>1\u00a0..##..##. 1<br>2\u00a0..#.##.#. 2<br>3v##......#v3<br>4^##......#^4<br>5\u00a0..#.##.#. 5<br>6\u00a0..##..##. 6<br>7 #.#.##.#. 7</blockquote>\n<blockquote>With the smudge in the top-left corner repaired, a new horizontal line of reflection between rows 3 and 4 now exists. Row 7 has no corresponding reflected row and can be ignored, but every other row matches exactly: row 1 matches row 6, row 2 matches row 5, and row 3 matches row\u00a04.</blockquote>\n<blockquote>In the second pattern, the smudge can be fixed by changing the fifth symbol on row 2 from\u00a0. to\u00a0#:</blockquote>\n<blockquote>1v#...##..#v1<br>2^#...##..#^2<br>3\u00a0..##..### 3<br>4 #####.##. 4<br>5 #####.##. 5<br>6\u00a0..##..### 6<br>7 #....#..# 7</blockquote>\n<blockquote>Now, the pattern has a different horizontal line of reflection between rows 1 and\u00a02.</blockquote>\n<blockquote>Summarize your notes as before, but instead use the new different reflection lines. In this example, the first pattern\u2019s new horizontal line has 3 rows above it and the second pattern\u2019s new horizontal line has 1 row above it, summarizing to the value\u00a0400.</blockquote>\n<blockquote>In each pattern, fix the smudge and find the different line of reflection. What number do you get after summarizing the new reflection line in each pattern in your\u00a0notes?</blockquote>\n<p>And\u2026</p>\n<blockquote>every mirror has exactly one smudge: exactly one\u00a0. or # should be the opposite\u00a0type.</blockquote>\n<p>We are back to permutations and combinations! \ud83e\udea6</p>\n<p>\ud83d\udcad Carrying on with our brute force approach, since our code was pretty blazing fast, we can extend our solution by adding some extra steps and\u00a0loops.</p>\n<p>Introducing \u2018smudges\u2019, where exactly one character in each pattern is incorrect and needs to be flipped to find a new line of reflection. We can follow these\u00a0steps:</p>\n<ol>\n<li>\n<strong>Identify the Smudge</strong>: Iterate through each cell of the pattern. <br> a. For each cell, flip its value (from\u00a0. to # or vice versa) <br> b. then check if this change results in a <strong>valid reflection line different from the original</strong>. <br> c. if <strong>yes</strong>, this is the <strong>smudge</strong> we need to fix, else <strong>continue</strong>\u00a0loop</li>\n<li>\n<strong>Summarize the Patterns</strong>: Calculate the summary based on the new reflection lines.</li>\n</ol>\n<p>Let\u2019s try\u00a0this?</p>\n<blockquote>\ud83d\udca1This approaches hinges upon the fact that puzzle states, there\u2019s exactly 1 smudge in each\u00a0pattern!</blockquote>\n<blockquote>\u2757\ufe0fEdge case: We need to ensure, that everytime we find a new reflection point, we need to compare it with original reflection point along with the mode, as sometimes the value can be same, but it can be for rows and columns respectively.<br>(new_reflection_point, mode)\u00a0!= (original_reflection_point, original_mode)</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IZm5QwQGOZ_qbTGbAbsJKg.png\"><figcaption>Tons of debugging later!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SB6a_qv-iqZ9-sSvoaGStw.png\"><figcaption>Masterpiece!</figcaption></figure><p>Let\u2019s see if it works for our new test\u00a0case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/579/1*ozPJTOamPgPqdVYvEUUHUQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>\u2705 summarize_pattern_with_smudges passed<br><br>[Done] exited with code=0 in 0.071 seconds</pre>\n<p>\u2705 in just <strong>0.071 seconds</strong>! This gives me\u00a0hope!</p>\n<p>Let\u2019s run it for the puzzle\u00a0input?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>\u203c\ufe0f Summarizing all patterns in Part 2: XXXXX<br><br>[Done] exited with code=0 in 0.281 seconds</pre>\n<p>Done! Let\u2019s see if our answer is correct?\u00a0\ud83d\udc40</p>\n<p>And\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*-GgwQaaV9TTLNX0awHsjbg.png\"><figcaption>\ud83e\udd41</figcaption></figure><p>Here\u2019s our code with a bruteforce approach, works pretty quick on my M1 Macbook Pro. I might come back later to solve this in a more novel way, but since I am already running behind in AdventOfCode, I will just move on!\u00a0\ud83d\ude03</p>\n<pre># Day 13 - Point of Incidence<br><br>from enum import Enum<br>import itertools<br><br><br>class Mode(Enum):<br>    ROW = \"row\"<br>    COLUMN = \"column\"<br><br><br>class MirrorPatternAnalyzer:<br>    def __init__(self, pattern):<br>        self.pattern = [list(row) for row in pattern.strip().split(\"\\n\")]<br><br>    @staticmethod<br>    def flip_char(char):<br>        return \"#\" if char == \".\" else \".\"<br><br>    def is_perfect_reflection(self, index, mode):<br>        if mode == Mode.ROW:<br>            prev, next = index - 1, index<br>            while prev &gt;= 0 and next &lt; len(self.pattern):<br>                if self.pattern[prev] != self.pattern[next]:<br>                    return False<br>                prev -= 1<br>                next += 1<br>            return True<br><br>        elif mode == Mode.COLUMN:<br>            prev, next = index - 1, index<br>            while prev &gt;= 0 and next &lt; len(self.pattern[0]):<br>                if any(<br>                    self.pattern[row][prev] != self.pattern[row][next]<br>                    for row in range(len(self.pattern))<br>                ):<br>                    return False<br>                prev -= 1<br>                next += 1<br>            return True<br><br>        raise ValueError(\"Invalid mode\")<br><br>    def find_point_of_reflection(self, mode):<br>        range_to_check = range(<br>            1, len(self.pattern) if mode == Mode.ROW else len(self.pattern[0])<br>        )<br>        for i in range_to_check:<br>            if self.is_perfect_reflection(i, mode):<br>                return i<br>        return None<br><br>    def try_fix_smudge_and_find_reflection(<br>        self, original_reflection_point, original_mode<br>    ):<br>        for i in range(len(self.pattern)):<br>            for j in range(len(self.pattern[i])):<br>                self.pattern[i][j] = MirrorPatternAnalyzer.flip_char(self.pattern[i][j])<br>                for mode in [Mode.ROW, Mode.COLUMN]:<br>                    new_reflection_point = self.find_point_of_reflection(mode)<br>                    if new_reflection_point and (new_reflection_point, mode) != (<br>                        original_reflection_point,<br>                        original_mode,<br>                    ):<br>                        return new_reflection_point, mode<br>                self.pattern[i][j] = MirrorPatternAnalyzer.flip_char(self.pattern[i][j])<br>        return original_reflection_point, original_mode<br><br>    def analyze(self, with_smudge=False):<br>        for mode in [Mode.ROW, Mode.COLUMN]:<br>            reflection_point = self.find_point_of_reflection(mode)<br>            if reflection_point is not None:<br>                if with_smudge:<br>                    (<br>                        new_reflection_point,<br>                        new_mode,<br>                    ) = self.try_fix_smudge_and_find_reflection(reflection_point, mode)<br>                    if new_mode == Mode.ROW:<br>                        return new_reflection_point * 100<br>                    else:<br>                        return new_reflection_point<br>                else:<br>                    return (<br>                        reflection_point * 100 if mode == Mode.ROW else reflection_point<br>                    )<br>        raise Exception(\"No valid reflection line found\")<br><br><br>def summarize_patterns(patterns, with_smudges=False):<br>    total_sum = 0<br>    for i, pattern in enumerate(patterns.split(\"\\n\\n\")):<br>        analyzer = MirrorPatternAnalyzer(pattern)<br>        total_sum += analyzer.analyze(with_smudge=with_smudges)<br>    return total_sum<br><br><br>def part_one():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns)<br><br>    print(f\"\u2757\ufe0f Summarizing all patterns in Part 1: {sum}\")<br><br><br>def test_summarize_patterns():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br>    sum = summarize_patterns(patterns)<br>    assert sum == 405, f\"Expected 405, got {sum}\"<br>    print(\"\u2705 summarize_pattern passed\")<br><br><br>def part_two():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns, with_smudges=True)<br>    print(f\"\u203c\ufe0f Summarizing all patterns in Part 2: {sum}\")<br><br><br>def test_summarize_patterns_with_smudges():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br><br>    sum = summarize_patterns(patterns, with_smudges=True)<br>    assert sum == 400, f\"Expected 400, got {sum}\"<br>    print(\"\u2705 summarize_pattern_with_smudges passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_summarize_patterns()<br>    part_one()<br><br>    test_summarize_patterns_with_smudges()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4fea00eb98fb\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["python","advent-of-code-2023","advent-of-code","christmas"]},{"title":"[Day 12] Hot Springs // Advent of Code 2023 (Python)","pubDate":"2023-12-19 14:46:59","link":"https://medium.com/@jatinkrmalik/day-12-hot-springs-advent-of-code-2023-python-77506773abfb?source=rss-ec576e4b06b0------2","guid":"https://medium.com/p/77506773abfb","author":"Jatin K Malik","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*2qyq_T4PoQxHVYw9\"><figcaption>Hot Springs (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/12\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You finally reach the hot springs! You can see steam rising from secluded areas attached to the primary, ornate building.</blockquote>\n<blockquote>As you turn to enter, the <a href=\"https://adventofcode.com/2023/day/11\">researcher</a> stops you. \u201cWait\u200a\u2014\u200aI thought you were looking for the hot springs, weren\u2019t you?\u201d You indicate that this definitely looks like hot springs to\u00a0you.</blockquote>\n<blockquote>\u201cOh, sorry, common mistake! This is actually the <a href=\"https://en.wikipedia.org/wiki/Onsen\">onsen</a>! The hot springs are next\u00a0door.\u201d</blockquote>\n<blockquote>You look in the direction the researcher is pointing and suddenly notice the massive metal helixes towering overhead. \u201cThis\u00a0way!\u201d</blockquote>\n<blockquote>It only takes you a few more steps to reach the main gate of the massive fenced-off area containing the springs. You go through the gate and into a small administrative building.</blockquote>\n<blockquote>\u201cHello! What brings you to the hot springs today? Sorry they\u2019re not very hot right now; we\u2019re having a lava shortage at the moment.\u201d You ask about the missing machine parts for Desert\u00a0Island.</blockquote>\n<blockquote>\u201cOh, all of Gear Island is currently offline! Nothing is being manufactured at the moment, not until we get more lava to heat our forges. And our springs. The springs aren\u2019t very springy unless they\u2019re\u00a0hot!\u201d</blockquote>\n<blockquote>\u201cSay, could you go up and see why the lava stopped flowing? The springs are too cold for normal operation, but we should be able to find one springy enough to launch you up\u00a0there!\u201d</blockquote>\n<blockquote>There\u2019s just one problem\u200a\u2014\u200amany of the springs have fallen into disrepair, so they\u2019re not actually sure which springs would even be safe to use! Worse yet, their condition records of which springs are damaged (your puzzle input) are also damaged! You\u2019ll need to help them repair the damaged\u00a0records.</blockquote>\n<blockquote>In the giant field just outside, the springs are arranged into rows. For each row, the condition records show every spring and whether it is operational (.) or damaged (#). This is the part of the condition records that is itself damaged; for some springs, it is simply unknown (?) whether the spring is operational or\u00a0damaged.</blockquote>\n<blockquote>However, the engineer that produced the condition records also duplicated some of this information in a different format! After the list of springs for a given row, the size of each contiguous group of damaged springs is listed in the order those groups appear in the row. This list always accounts for every damaged spring, and each number is the entire size of its contiguous group (that is, groups are always separated by at least one operational spring: #### would always be 4, never\u00a02,2).</blockquote>\n<blockquote>So, condition records with no unknown spring conditions might look like\u00a0this:</blockquote>\n<blockquote>#.#.### 1,1,3<br>.#...#....###. 1,1,3<br>.#.###.#.###### 1,3,1,6<br>####.#...#... 4,1,1<br>#....######..#####. 1,6,5<br>.###.##....# 3,2,1</blockquote>\n<blockquote>However, the condition records are partially damaged; some of the springs\u2019 conditions are actually unknown (?). For\u00a0example:</blockquote>\n<blockquote>???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1</blockquote>\n<blockquote>Equipped with this information, it is your job to figure out how many different arrangements of operational and broken springs fit the given criteria in each\u00a0row.</blockquote>\n<blockquote>In the first line (???.### 1,1,3), there is exactly one way separate groups of one, one, and three broken springs (in that order) can appear in that row: the first three unknown springs must be broken, then operational, then broken (#.#), making the whole row\u00a0#.#.###.</blockquote>\n<blockquote>The second line is more interesting:\u00a0.??..??...?##. 1,1,3 could be a total of four different arrangements. The last\u00a0? must always be broken (to satisfy the final contiguous group of three broken springs), and each\u00a0??must hide exactly one of the two broken springs. (Neither\u00a0?? could be both broken springs or they would form a single contiguous group of two; if that were true, the numbers afterward would have been 2,3 instead.) Since each\u00a0?? can either be #. or\u00a0.#, there are four possible arrangements of\u00a0springs.</blockquote>\n<blockquote>The last line is actually consistent with ten different arrangements! Because the first number is 3, the first and second\u00a0? must both be\u00a0. (if either were #, the first number would have to be 4 or higher). However, the remaining run of unknown spring conditions have many different ways they could hold groups of two and one broken\u00a0springs:</blockquote>\n<blockquote>?###???????? 3,2,1<br>.###.##.#...<br>.###.##..#..<br>.###.##...#.<br>.###.##....#<br>.###..##.#..<br>.###..##..#.<br>.###..##...#<br>.###...##.#.<br>.###...##..#<br>.###....##.#</blockquote>\n<blockquote>In this example, the number of possible arrangements for each row\u00a0is:</blockquote>\n<blockquote>???.### 1,1,3 - 1 arrangement</blockquote>\n<blockquote>.??..??...?##. 1,1,3 - 4 arrangements</blockquote>\n<blockquote>?#?#?#?#?#?#?#? 1,3,1,6 - 1 arrangement</blockquote>\n<blockquote>????.#...#... 4,1,1 - 1 arrangement</blockquote>\n<blockquote>????.######..#####. 1,6,5 - 4 arrangements</blockquote>\n<blockquote>?###???????? 3,2,1 - 10 arrangements</blockquote>\n<blockquote>Adding all of the possible arrangement counts together produces a total of 21 arrangements.</blockquote>\n<blockquote>For each row, count all of the different arrangements of operational and broken springs that meet the given criteria. What is the sum of those\u00a0counts?</blockquote>\n<p>Man! Another permutation and combination problem! It seems like Santa knows what I used to hate during my engineering days!\u00a0\ud83e\udd13</p>\n<p>So..let\u2019s break the problem down, and try not to get ahead of ourself unlike <a href=\"https://medium.com/@jatinkrmalik/day-11-cosmic-expansion-advent-of-code-2023-python-6e545dad06bb\">Day\u00a011</a>!</p>\n<p>In an ideal world, our spring records look something like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HEfawkgl3UkaXOujYeYvhQ.png\"></figure><p>But, since the condition records are partially damaged, some of the springs\u2019 conditions are actually unknown\u00a0(?):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/988/1*msCo829KuU8oXkABUT8D0w.png\"><figcaption>where `?` denotes the unknown\u00a0state</figcaption></figure><p>\ud83d\udca1 So, before we start talking about combinations possible and all, I think we should assume the ideal case, and write a simple validator that validates the spring_state (left) with damaged_spring_record (right). And this case be our base\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*cs0D_12A8fOC34O7FBHgWg.png\"><figcaption>Quick prototying in\u00a0REPL</figcaption></figure><p>Here\u2019s our test\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/795/1*6xYRS2whEuMWeyeqQwio_Q.png\"></figure><p>And here\u2019s some shabby code just to validate the\u00a0idea:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/774/1*7IpkGhEBWW00mcYWRbWosQ.png\"></figure><p>Let\u2019s run this, and we can validate that it indeed\u00a0works!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>\u2705 OK: #.#.### 1,1,3<br>\u2705 OK: .#...#....###. 1,1,3<br>\u2705 OK: .#.###.#.###### 1,3,1,6<br>\u2705 OK: ####.#...#... 4,1,1<br>\u2705 OK: #....######..#####. 1,6,5<br>\u2705 OK: .###.##....# 3,2,1<br><br>[Done] exited with code=0 in 0.097 seconds</pre>\n<p>So, now that we know the records are not ideal, but indeed damaged and has a lot of unknowns, we will expand the scope of our thinking.</p>\n<p>Well, it\u2019s clear that our validate_spring_record(spring_record) bool function will play a pivotal role to solve the problem as for an example row from damaged\u00a0records:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/987/1*yPP9z0Et7UBNJgad-tIfBw.png\"><figcaption>We can use our validator function to help verify correct combinations</figcaption></figure><blockquote>Now, to get all possible combinations, we need to consider each\u00a0? as a place where 2 choices are possible: either\u00a0. or #. This is a classic problem of combinatorics where each\u00a0? represents a <strong>binary\u00a0choice</strong>.</blockquote>\n<p>In the example row taken above:\u00a0.??..??\u2026?##.\u00a0, we have a total of 5\u00a0? present, where each can be replaced by\u00a0. or # so, mathematically speaking, that yields: <strong><em>2\u2075 combinations ==\u00a032.</em></strong></p>\n<p>\ud83d\udcad We can write a function that replaces each\u00a0? in the record with either\u00a0. or #, and then calls itself recursively until all\u00a0? have been replaced, using that we can generate all the combinations!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zt0yeaKGXxSM6uAVI9KrNg.png\"></figure><p>Let\u2019s do a quick script\u00a0test?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*oszF9BgfE6OlziW0E3YOyA.png\"><figcaption>Looks good!</figcaption></figure><p>Now, all we need to do\u00a0is:</p>\n<ol>\n<li>For each spring_state record, generate all_combinations</li>\n<li>For each combination in all_combinations, count validate_spring_record(combination) ==\u00a0true</li>\n<li>sum(for each count of valid combination)</li>\n<li>???</li>\n<li>Profit!</li>\n</ol>\n<blockquote>\u2757\ufe0f Disclaimer: I know this is not the most efficient way, but as always, my first approach is to match a solution to a problem and then try to find optimisations! We will probably have to do that as well, as we are currently generating 2^n combinations where the valid combinations will be super\u00a0low!</blockquote>\n<p>So, let\u2019s write\u00a0\ud83d\udc46code:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/957/1*m_JTU9Mlkhm02vv22-ZzFw.png\"></figure><p>And let\u2019s run for our base test case as given in the question:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>Found 1 valid combinations for ???.### 1,1,3<br>Found 4 valid combinations for .??..??...?##. 1,1,3<br>Found 1 valid combinations for ?#?#?#?#?#?#?#? 1,3,1,6<br>Found 1 valid combinations for ????.#...#... 4,1,1<br>Found 4 valid combinations for ????.######..#####. 1,6,5<br>Found 10 valid combinations for ?###???????? 3,2,1<br>\u2705 OK - test_sum_spring_record_combinations<br><br>[Done] exited with code=0 in 0.066 seconds</pre>\n<p>Yes!!! Now, let\u2019s load up the puzzle input and try to get an answer?\u00a0\ud83e\udd1e</p>\n<p>Ah, well\u2026.this might take some time\u2026and\u2026</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>Found 4 valid combinations for .???#??????#. 6,1<br>Found 2 valid combinations for ???##???##?#??#?#..# 1,14,1<br>Found 2 valid combinations for #??????#????#?###?# 3,1,10,1<br>Found 13 valid combinations for .???????#????. 1,2,1,2<br>Found 4 valid combinations for ?##?.??.???.. 3,2,2<br>Found 1 valid combinations for #.?###?#??. 1,5<br>Found 12 valid combinations for ?#??#??????????.??.? 7,2,3,1<br>Found 1 valid combinations for ???###?#.##??? 8,3<br>...<br>1000 lines later<br>...<br>\u2757\ufe0f Total valid combinations: XXXX<br><br>[Done] exited with code=0 in 49.445 seconds</pre>\n<p>Not bad! An answer in 49.445 seconds shall be considered a win comapred to last few\u00a0days!</p>\n<p>Let\u2019s see if this is the corect\u00a0answers?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/830/1*a3NavRUiuC2ujHUK9wXbRw.png\"><figcaption>YASS!</figcaption></figure><p>Here\u2019s my code till\u00a0now:</p>\n<pre># Day 12: Hot Springs<br><br>from enum import Enum<br><br><br>class SpringState(Enum):<br>    OPERATIONAL = \".\"<br>    DAMAGED = \"#\"<br>    UNKNOWN = \"?\"<br><br><br>def generate_spring_record_combinations(spring_record, index=0):<br>    if index &gt;= len(spring_record):<br>        return [spring_record]<br><br>    if spring_record[index] == SpringState.UNKNOWN.value:<br>        # replace '?' with '.' and combine results<br>        with_operational = generate_spring_record_combinations(<br>            spring_record[:index]<br>            + SpringState.OPERATIONAL.value<br>            + spring_record[index + 1 :],<br>            index + 1,<br>        )<br>        # replace '?' with '#' and combine results<br>        with_damaged = generate_spring_record_combinations(<br>            spring_record[:index]<br>            + SpringState.DAMAGED.value<br>            + spring_record[index + 1 :],<br>            index + 1,<br>        )<br>        return with_operational + with_damaged<br>    else:<br>        # continue recursion for next index<br>        return generate_spring_record_combinations(spring_record, index + 1)<br><br><br>def validate_spring_record(spring_state, damaged_spring_record):<br>    damaged_spring_record = damaged_spring_record.split(\",\")<br>    spring_state = list(spring_state)<br><br>    replica_damaged_spring_record = []<br>    damaged_count = 0<br>    for spring in spring_state:<br>        if spring == SpringState.DAMAGED.value:<br>            damaged_count += 1<br>        else:<br>            if damaged_count &gt; 0:<br>                replica_damaged_spring_record.append(str(damaged_count))<br>                damaged_count = 0<br><br>    if damaged_count &gt; 0:<br>        replica_damaged_spring_record.append(str(damaged_count))<br><br>    return replica_damaged_spring_record == damaged_spring_record<br><br><br>def sum_spring_record_combinations(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        combinations = generate_spring_record_combinations(spring_state)<br>        valid_combinations_length = len(<br>            [<br>                c for c in combinations<br>                if validate_spring_record(c, damaged_spring_record)<br>            ]<br>        )<br>        print(f\"Found {valid_combinations_length} valid combinations for {spring_record}\")<br>        total_combinations += valid_combinations_length<br>    return total_combinations<br><br>def part_one():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    print(f\"\u2757\ufe0f Total valid combinations: {sum}\")<br><br>def test_sum_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    assert sum == 21, f\"\u274c Expected: 21, Actual: {sum}\"<br>    print(\"\u2705 OK - test_sum_spring_record_combinations\")<br><br><br>def test_validate_spring_record_ideal():<br>    ideal_spring_condition_records = \"\"\"#.#.### 1,1,3<br>.#...#....###. 1,1,3<br>.#.###.#.###### 1,3,1,6<br>####.#...#... 4,1,1<br>#....######..#####. 1,6,5<br>.###.##....# 3,2,1<br>\"\"\"<br>    for spring_record in ideal_spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        ok = validate_spring_record(spring_state, damaged_spring_record)<br>        assert ok, f\"\u274c Expected: True, Actual: {ok}\"<br>        print(f\"\u2705 OK: {spring_record}\")<br>    print(\"\u2705 OK - test_validate_spring_record_ideal\")<br><br><br><br>if __name__ == \"__main__\":<br>    # test_validate_spring_record_ideal()<br>    test_sum_spring_record_combinations()<br>    part_one()</pre>\n<blockquote>I am aware that we have a lot of wasted compute that we can optimise here, but let\u2019s move on to part 2 as that usually changes the requirements drastically and then we will combine refactor our\u00a0code.</blockquote>\n<h3>Part Two</h3>\n<blockquote>As you look out at the field of springs, you feel like there are way more springs than the condition records list. When you examine the records, you discover that they were actually folded up this whole\u00a0time!</blockquote>\n<blockquote>To unfold the records, on each row, replace the list of spring conditions with five copies of itself (separated by\u00a0?) and replace the list of contiguous groups of damaged springs with five copies of itself (separated by\u00a0,).</blockquote>\n<blockquote>So, this\u00a0row:</blockquote>\n<blockquote>.# 1</blockquote>\n<blockquote>Would become:</blockquote>\n<blockquote>.#?.#?.#?.#?.# 1,1,1,1,1</blockquote>\n<blockquote>The first line of the above example would\u00a0become:</blockquote>\n<blockquote>???.###????.###????.###????.###????.### 1,1,3,1,1,3,1,1,3,1,1,3,1,1,3</blockquote>\n<blockquote>In the above example, after unfolding, the number of possible arrangements for some rows is now much\u00a0larger:</blockquote>\n<blockquote>???.### 1,1,3 - 1 arrangement</blockquote>\n<blockquote>.??..??...?##. 1,1,3 - 16384 arrangements</blockquote>\n<blockquote>?#?#?#?#?#?#?#? 1,3,1,6 - 1 arrangement</blockquote>\n<blockquote>????.#...#... 4,1,1 - 16 arrangements</blockquote>\n<blockquote>????.######..#####. 1,6,5 - 2500 arrangements</blockquote>\n<blockquote>?###???????? 3,2,1 - 506250 arrangements</blockquote>\n<blockquote>After unfolding, adding all of the possible arrangement counts together produces\u00a0525152.</blockquote>\n<blockquote>Unfold your condition records; what is the new sum of possible arrangement counts?</blockquote>\n<p>Aha! Told you. So, now conviniently, springs were actually <strong>folded up </strong>this whole\u00a0time!</p>\n<p>To unfold the sequence, we just need to 5x each row of the record, for\u00a0example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/966/1*s4MTuZ3zRalGpICJhrhfJQ.png\"></figure><p>Clearly, our inefficient code will now not work, as our possible combinations will increase exponentially!</p>\n<blockquote>\ud83d\udca1Well, one simple way I can see to reduce computations is\u00a0to:</blockquote>\n<blockquote>- just integrate the validation logic directly into the combination generation process</blockquote>\n<blockquote>- instead of store all the combinations and then computing length, we can just return the <strong>valid</strong> number of combinations.</blockquote>\n<p>This way, we only generate valid combinations from the start, significantly reducing the number of combinations we need to\u00a0handle.</p>\n<p>Updating code for that, let\u2019s run\u00a0it!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>\u2705 OK - test_sum_spring_record_combinations<br>\u2757\ufe0f Total valid combinations: 7599<br><br>[Done] exited with code=0 in 48.915 seconds</pre>\n<p>And it saved us a grand total of 49.445\u201348.915 = <strong>~530 ms\u00a0\ud83d\ude02</strong></p>\n<a href=\"https://medium.com/media/05826d1b7bcf41e217ad095add326244/href\">https://medium.com/media/05826d1b7bcf41e217ad095add326244/href</a><p>Breaking down the computation, it\u2019s clear that we are <strong>spending a lot of time in</strong> generating \u201call\u201d the possible combinations of the record. Since we already have the damaged_spring_record, we should be able to use it to basically just generate correct combinations? Or at the least, do an <strong>early return</strong> for the all incorrect ones!\u00a0\ud83e\udd14</p>\n<blockquote>The complexity of this problem lies in correctly interpreting the \u2018?\u2019 characters while adhering to the constraints set by the <strong><em>damaged_spring_record</em></strong>.</blockquote>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>\ud83d\udca1 We need to find a way to <strong>prune of our search space early</strong> when a rule from damaged_spring_record is violated in our recursive process itself! Let\u2019s write our early return conditions using our record while navigating through all possible combinations in our recursive function:</p>\n<ul>\n<li>If the damaged_spring_record is empty, <br>- if any spring is damaged: return 0 <br>- else, return\u00a01.</li>\n<li>If the spring_state string is empty, <br>- if there are no damaged spring records left to process: return 1<br>- else, return\u00a00.</li>\n<li>recursively check each spring state and calculate the total number of valid combinations based on whether the current spring is operational, damaged, or\u00a0unknown.</li>\n</ul>\n<p>And since now alot of search space will have repeated calculations, we can use @cache decorator from functools to memoize the results of the recursive function get_valid_spring_record_combinations in an LRU cache with no size\u00a0limit!</p>\n<blockquote>Python does make caching absolutely simple with these nifty OOTB decorators! \ud83e\udd0c</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SOZFKjkeUP6fDZF42V4Ffw.png\"></figure><p>And here, our is_valid_condition would look\u00a0like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/882/1*9jeKFExvbHulJLyT9qmFQQ.png\"></figure><p>\u2757\ufe0f Here, _is_valid_condition returns a boolean value that indicates whether the given spring_state and damaged_spring_record meet the following conditions:</p>\n<ol>\n<li>The first element of damaged_spring_record (which represents the number of damaged springs in the first group) is less than or equal to the length of spring_state. This ensures that there are enough springs in spring_state to account for the first group of damaged\u00a0springs.</li>\n<li>All springs in spring_state up to the index equal to the first element of damaged_spring_record are not operational. This is checked by ensuring that the OPERATIONAL value of the SpringState Enum is not found in the substring of spring_state that ends at the index equal to the first element of damaged_spring_record.</li>\n<li>Either the first element of damaged_spring_record is equal to the length of spring_state (which means that all springs are damaged), or the spring at the index equal to the first element of damaged_spring_record is not damaged. This ensures that there is no damaged spring immediately after the first group of damaged\u00a0springs.</li>\n</ol>\n<p>Let\u2019s run this code for our base test case of part\u00a01:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/748/1*Hw9kB_F1vPM-PDxQxMNqwQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>\u2705 OK - test_sum_spring_record_combinations<br><br>[Done] exited with code=0 in 0.109 seconds</pre>\n<p>And puzzle input for part\u00a01:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*R7ko8-beeAmE7h8LOHK8ig.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>\u2757\ufe0f Total valid combinations: XXXX<br><br>[Done] exited with code=0 in 0.134 seconds</pre>\n<p>Wow! We get the correct answer in just <strong>0.134 seconds </strong>compare this to our previous brute force approach that took <strong>~49 seconds\u00a0\ud83d\ude2f</strong></p>\n<p>Now, let\u2019s also write our base test case for part 2, where all we need to do is, just increase our input per spring_record * 5\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/796/1*1tR0tV2M9F1FkhO9YmgEhg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>\u2705 OK - test_sum_unfolded_spring_record_combinations<br><br>[Done] exited with code=0 in 0.11 seconds</pre>\n<p>Phew! And now let\u2019s do it for part 2, puzzle\u00a0input:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*KwV2lKEhMMicGv2y4jS69Q.png\"><figcaption>* 5 for unfolding \uaa5c</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>\u2757\ufe0f Total valid combinations: XXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.693 seconds</pre>\n<p><strong>Yes! Look at that runtime!\u00a0\ud83d\ude80</strong></p>\n<p>Let\u2019s put this answer in the text box?\u00a0And\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/950/1*HfuXqBmUaJQdhPzx1YC98w.png\"><figcaption>\ud83d\udca5</figcaption></figure><p>Here\u2019s our super optimised code till now, I am not doing object oriented for this one!\u00a0:P</p>\n<pre>from enum import Enum<br>from functools import cache<br><br><br>class SpringState(Enum):<br>    OPERATIONAL = \".\"<br>    DAMAGED = \"#\"<br>    UNKNOWN = \"?\"<br><br><br>@cache<br>def get_valid_spring_record_combinations(spring_state, damaged_spring_record):<br>    if not damaged_spring_record:<br>        if SpringState.DAMAGED.value in spring_state:<br>            return 0<br>        else:<br>            return 1<br><br>    if not spring_state:<br>        if not damaged_spring_record:<br>            return 1<br>        else:<br>            return 0<br><br>    total_combinations = 0<br><br>    # if \".\" or \"?\"<br>    if spring_state[0] in [SpringState.OPERATIONAL.value, SpringState.UNKNOWN.value]:<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state[1:], damaged_spring_record<br>        )<br><br>    # if \"#\" or \"?\"<br>    if spring_state[0] in [SpringState.DAMAGED.value, SpringState.UNKNOWN.value]:<br>        if is_valid_condition(spring_state, damaged_spring_record):<br>            total_combinations += get_valid_spring_record_combinations(<br>                spring_state[damaged_spring_record[0] + 1 :], damaged_spring_record[1:]<br>            )<br><br>    return total_combinations<br><br><br>def is_valid_condition(spring_state, damaged_spring_record):<br>    return (<br>        damaged_spring_record[0] &lt;= len(spring_state)<br>        and SpringState.OPERATIONAL.value<br>        not in spring_state[: damaged_spring_record[0]]<br>        and (<br>            damaged_spring_record[0] == len(spring_state)<br>            or spring_state[damaged_spring_record[0]] != SpringState.DAMAGED.value<br>        )<br>    )<br><br><br>def sum_spring_record_combinations(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        damaged_spring_record = tuple(map(int, damaged_spring_record.split(\",\")))<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state, damaged_spring_record<br>        )<br><br>    return total_combinations<br><br><br>def part_one():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    print(f\"\u2757\ufe0f Total valid combinations: {sum}\")<br><br><br>def sum_spring_record_combinations_unfold(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        damaged_spring_record = tuple(map(int, damaged_spring_record.split(\",\")))<br>        spring_state = \"?\".join([spring_state] * 5)  # unfolding<br>        damaged_spring_record = damaged_spring_record * 5  # unfolding<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state, damaged_spring_record<br>        )<br><br>    return total_combinations<br><br><br>def part_two():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations_unfold(spring_condition_records)<br>    print(f\"\u2757\ufe0f Total valid combinations: {sum}\")<br><br><br>def test_sum_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    assert sum == 21, f\"\u274c Expected: 21, Actual: {sum}\"<br>    print(\"\u2705 OK - test_sum_spring_record_combinations\")<br><br><br>def test_sum_unfolded_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations_unfold(spring_condition_records)<br>    assert sum == 525152, f\"\u274c Expected: 525152, Actual: {sum}\"<br>    print(\"\u2705 OK - test_sum_unfolded_spring_record_combinations\")<br><br><br>if __name__ == \"__main__\":<br>    test_sum_spring_record_combinations()<br>    part_one()<br><br>    test_sum_unfolded_spring_record_combinations()<br>    part_two()</pre>\n<p>Man! I am learning so much with <strong>#AdventOfCode2023</strong>, it\u2019s beautiful that I am getting to revisit a lot of my engineering days concepts that I don\u2019t get to use in my day to day work while building CRUD apps!\u00a0\ud83e\udd13</p>\n<p>Onto the next day\u00a0then?!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=77506773abfb\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*2qyq_T4PoQxHVYw9\"><figcaption>Hot Springs (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/12\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You finally reach the hot springs! You can see steam rising from secluded areas attached to the primary, ornate building.</blockquote>\n<blockquote>As you turn to enter, the <a href=\"https://adventofcode.com/2023/day/11\">researcher</a> stops you. \u201cWait\u200a\u2014\u200aI thought you were looking for the hot springs, weren\u2019t you?\u201d You indicate that this definitely looks like hot springs to\u00a0you.</blockquote>\n<blockquote>\u201cOh, sorry, common mistake! This is actually the <a href=\"https://en.wikipedia.org/wiki/Onsen\">onsen</a>! The hot springs are next\u00a0door.\u201d</blockquote>\n<blockquote>You look in the direction the researcher is pointing and suddenly notice the massive metal helixes towering overhead. \u201cThis\u00a0way!\u201d</blockquote>\n<blockquote>It only takes you a few more steps to reach the main gate of the massive fenced-off area containing the springs. You go through the gate and into a small administrative building.</blockquote>\n<blockquote>\u201cHello! What brings you to the hot springs today? Sorry they\u2019re not very hot right now; we\u2019re having a lava shortage at the moment.\u201d You ask about the missing machine parts for Desert\u00a0Island.</blockquote>\n<blockquote>\u201cOh, all of Gear Island is currently offline! Nothing is being manufactured at the moment, not until we get more lava to heat our forges. And our springs. The springs aren\u2019t very springy unless they\u2019re\u00a0hot!\u201d</blockquote>\n<blockquote>\u201cSay, could you go up and see why the lava stopped flowing? The springs are too cold for normal operation, but we should be able to find one springy enough to launch you up\u00a0there!\u201d</blockquote>\n<blockquote>There\u2019s just one problem\u200a\u2014\u200amany of the springs have fallen into disrepair, so they\u2019re not actually sure which springs would even be safe to use! Worse yet, their condition records of which springs are damaged (your puzzle input) are also damaged! You\u2019ll need to help them repair the damaged\u00a0records.</blockquote>\n<blockquote>In the giant field just outside, the springs are arranged into rows. For each row, the condition records show every spring and whether it is operational (.) or damaged (#). This is the part of the condition records that is itself damaged; for some springs, it is simply unknown (?) whether the spring is operational or\u00a0damaged.</blockquote>\n<blockquote>However, the engineer that produced the condition records also duplicated some of this information in a different format! After the list of springs for a given row, the size of each contiguous group of damaged springs is listed in the order those groups appear in the row. This list always accounts for every damaged spring, and each number is the entire size of its contiguous group (that is, groups are always separated by at least one operational spring: #### would always be 4, never\u00a02,2).</blockquote>\n<blockquote>So, condition records with no unknown spring conditions might look like\u00a0this:</blockquote>\n<blockquote>#.#.### 1,1,3<br>.#...#....###. 1,1,3<br>.#.###.#.###### 1,3,1,6<br>####.#...#... 4,1,1<br>#....######..#####. 1,6,5<br>.###.##....# 3,2,1</blockquote>\n<blockquote>However, the condition records are partially damaged; some of the springs\u2019 conditions are actually unknown (?). For\u00a0example:</blockquote>\n<blockquote>???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1</blockquote>\n<blockquote>Equipped with this information, it is your job to figure out how many different arrangements of operational and broken springs fit the given criteria in each\u00a0row.</blockquote>\n<blockquote>In the first line (???.### 1,1,3), there is exactly one way separate groups of one, one, and three broken springs (in that order) can appear in that row: the first three unknown springs must be broken, then operational, then broken (#.#), making the whole row\u00a0#.#.###.</blockquote>\n<blockquote>The second line is more interesting:\u00a0.??..??...?##. 1,1,3 could be a total of four different arrangements. The last\u00a0? must always be broken (to satisfy the final contiguous group of three broken springs), and each\u00a0??must hide exactly one of the two broken springs. (Neither\u00a0?? could be both broken springs or they would form a single contiguous group of two; if that were true, the numbers afterward would have been 2,3 instead.) Since each\u00a0?? can either be #. or\u00a0.#, there are four possible arrangements of\u00a0springs.</blockquote>\n<blockquote>The last line is actually consistent with ten different arrangements! Because the first number is 3, the first and second\u00a0? must both be\u00a0. (if either were #, the first number would have to be 4 or higher). However, the remaining run of unknown spring conditions have many different ways they could hold groups of two and one broken\u00a0springs:</blockquote>\n<blockquote>?###???????? 3,2,1<br>.###.##.#...<br>.###.##..#..<br>.###.##...#.<br>.###.##....#<br>.###..##.#..<br>.###..##..#.<br>.###..##...#<br>.###...##.#.<br>.###...##..#<br>.###....##.#</blockquote>\n<blockquote>In this example, the number of possible arrangements for each row\u00a0is:</blockquote>\n<blockquote>???.### 1,1,3 - 1 arrangement</blockquote>\n<blockquote>.??..??...?##. 1,1,3 - 4 arrangements</blockquote>\n<blockquote>?#?#?#?#?#?#?#? 1,3,1,6 - 1 arrangement</blockquote>\n<blockquote>????.#...#... 4,1,1 - 1 arrangement</blockquote>\n<blockquote>????.######..#####. 1,6,5 - 4 arrangements</blockquote>\n<blockquote>?###???????? 3,2,1 - 10 arrangements</blockquote>\n<blockquote>Adding all of the possible arrangement counts together produces a total of 21 arrangements.</blockquote>\n<blockquote>For each row, count all of the different arrangements of operational and broken springs that meet the given criteria. What is the sum of those\u00a0counts?</blockquote>\n<p>Man! Another permutation and combination problem! It seems like Santa knows what I used to hate during my engineering days!\u00a0\ud83e\udd13</p>\n<p>So..let\u2019s break the problem down, and try not to get ahead of ourself unlike <a href=\"https://medium.com/@jatinkrmalik/day-11-cosmic-expansion-advent-of-code-2023-python-6e545dad06bb\">Day\u00a011</a>!</p>\n<p>In an ideal world, our spring records look something like\u00a0this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HEfawkgl3UkaXOujYeYvhQ.png\"></figure><p>But, since the condition records are partially damaged, some of the springs\u2019 conditions are actually unknown\u00a0(?):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/988/1*msCo829KuU8oXkABUT8D0w.png\"><figcaption>where `?` denotes the unknown\u00a0state</figcaption></figure><p>\ud83d\udca1 So, before we start talking about combinations possible and all, I think we should assume the ideal case, and write a simple validator that validates the spring_state (left) with damaged_spring_record (right). And this case be our base\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*cs0D_12A8fOC34O7FBHgWg.png\"><figcaption>Quick prototying in\u00a0REPL</figcaption></figure><p>Here\u2019s our test\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/795/1*6xYRS2whEuMWeyeqQwio_Q.png\"></figure><p>And here\u2019s some shabby code just to validate the\u00a0idea:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/774/1*7IpkGhEBWW00mcYWRbWosQ.png\"></figure><p>Let\u2019s run this, and we can validate that it indeed\u00a0works!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>\u2705 OK: #.#.### 1,1,3<br>\u2705 OK: .#...#....###. 1,1,3<br>\u2705 OK: .#.###.#.###### 1,3,1,6<br>\u2705 OK: ####.#...#... 4,1,1<br>\u2705 OK: #....######..#####. 1,6,5<br>\u2705 OK: .###.##....# 3,2,1<br><br>[Done] exited with code=0 in 0.097 seconds</pre>\n<p>So, now that we know the records are not ideal, but indeed damaged and has a lot of unknowns, we will expand the scope of our thinking.</p>\n<p>Well, it\u2019s clear that our validate_spring_record(spring_record) bool function will play a pivotal role to solve the problem as for an example row from damaged\u00a0records:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/987/1*yPP9z0Et7UBNJgad-tIfBw.png\"><figcaption>We can use our validator function to help verify correct combinations</figcaption></figure><blockquote>Now, to get all possible combinations, we need to consider each\u00a0? as a place where 2 choices are possible: either\u00a0. or #. This is a classic problem of combinatorics where each\u00a0? represents a <strong>binary\u00a0choice</strong>.</blockquote>\n<p>In the example row taken above:\u00a0.??..??\u2026?##.\u00a0, we have a total of 5\u00a0? present, where each can be replaced by\u00a0. or # so, mathematically speaking, that yields: <strong><em>2\u2075 combinations ==\u00a032.</em></strong></p>\n<p>\ud83d\udcad We can write a function that replaces each\u00a0? in the record with either\u00a0. or #, and then calls itself recursively until all\u00a0? have been replaced, using that we can generate all the combinations!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zt0yeaKGXxSM6uAVI9KrNg.png\"></figure><p>Let\u2019s do a quick script\u00a0test?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*oszF9BgfE6OlziW0E3YOyA.png\"><figcaption>Looks good!</figcaption></figure><p>Now, all we need to do\u00a0is:</p>\n<ol>\n<li>For each spring_state record, generate all_combinations</li>\n<li>For each combination in all_combinations, count validate_spring_record(combination) ==\u00a0true</li>\n<li>sum(for each count of valid combination)</li>\n<li>???</li>\n<li>Profit!</li>\n</ol>\n<blockquote>\u2757\ufe0f Disclaimer: I know this is not the most efficient way, but as always, my first approach is to match a solution to a problem and then try to find optimisations! We will probably have to do that as well, as we are currently generating 2^n combinations where the valid combinations will be super\u00a0low!</blockquote>\n<p>So, let\u2019s write\u00a0\ud83d\udc46code:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/957/1*m_JTU9Mlkhm02vv22-ZzFw.png\"></figure><p>And let\u2019s run for our base test case as given in the question:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>Found 1 valid combinations for ???.### 1,1,3<br>Found 4 valid combinations for .??..??...?##. 1,1,3<br>Found 1 valid combinations for ?#?#?#?#?#?#?#? 1,3,1,6<br>Found 1 valid combinations for ????.#...#... 4,1,1<br>Found 4 valid combinations for ????.######..#####. 1,6,5<br>Found 10 valid combinations for ?###???????? 3,2,1<br>\u2705 OK - test_sum_spring_record_combinations<br><br>[Done] exited with code=0 in 0.066 seconds</pre>\n<p>Yes!!! Now, let\u2019s load up the puzzle input and try to get an answer?\u00a0\ud83e\udd1e</p>\n<p>Ah, well\u2026.this might take some time\u2026and\u2026</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>Found 4 valid combinations for .???#??????#. 6,1<br>Found 2 valid combinations for ???##???##?#??#?#..# 1,14,1<br>Found 2 valid combinations for #??????#????#?###?# 3,1,10,1<br>Found 13 valid combinations for .???????#????. 1,2,1,2<br>Found 4 valid combinations for ?##?.??.???.. 3,2,2<br>Found 1 valid combinations for #.?###?#??. 1,5<br>Found 12 valid combinations for ?#??#??????????.??.? 7,2,3,1<br>Found 1 valid combinations for ???###?#.##??? 8,3<br>...<br>1000 lines later<br>...<br>\u2757\ufe0f Total valid combinations: XXXX<br><br>[Done] exited with code=0 in 49.445 seconds</pre>\n<p>Not bad! An answer in 49.445 seconds shall be considered a win comapred to last few\u00a0days!</p>\n<p>Let\u2019s see if this is the corect\u00a0answers?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/830/1*a3NavRUiuC2ujHUK9wXbRw.png\"><figcaption>YASS!</figcaption></figure><p>Here\u2019s my code till\u00a0now:</p>\n<pre># Day 12: Hot Springs<br><br>from enum import Enum<br><br><br>class SpringState(Enum):<br>    OPERATIONAL = \".\"<br>    DAMAGED = \"#\"<br>    UNKNOWN = \"?\"<br><br><br>def generate_spring_record_combinations(spring_record, index=0):<br>    if index &gt;= len(spring_record):<br>        return [spring_record]<br><br>    if spring_record[index] == SpringState.UNKNOWN.value:<br>        # replace '?' with '.' and combine results<br>        with_operational = generate_spring_record_combinations(<br>            spring_record[:index]<br>            + SpringState.OPERATIONAL.value<br>            + spring_record[index + 1 :],<br>            index + 1,<br>        )<br>        # replace '?' with '#' and combine results<br>        with_damaged = generate_spring_record_combinations(<br>            spring_record[:index]<br>            + SpringState.DAMAGED.value<br>            + spring_record[index + 1 :],<br>            index + 1,<br>        )<br>        return with_operational + with_damaged<br>    else:<br>        # continue recursion for next index<br>        return generate_spring_record_combinations(spring_record, index + 1)<br><br><br>def validate_spring_record(spring_state, damaged_spring_record):<br>    damaged_spring_record = damaged_spring_record.split(\",\")<br>    spring_state = list(spring_state)<br><br>    replica_damaged_spring_record = []<br>    damaged_count = 0<br>    for spring in spring_state:<br>        if spring == SpringState.DAMAGED.value:<br>            damaged_count += 1<br>        else:<br>            if damaged_count &gt; 0:<br>                replica_damaged_spring_record.append(str(damaged_count))<br>                damaged_count = 0<br><br>    if damaged_count &gt; 0:<br>        replica_damaged_spring_record.append(str(damaged_count))<br><br>    return replica_damaged_spring_record == damaged_spring_record<br><br><br>def sum_spring_record_combinations(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        combinations = generate_spring_record_combinations(spring_state)<br>        valid_combinations_length = len(<br>            [<br>                c for c in combinations<br>                if validate_spring_record(c, damaged_spring_record)<br>            ]<br>        )<br>        print(f\"Found {valid_combinations_length} valid combinations for {spring_record}\")<br>        total_combinations += valid_combinations_length<br>    return total_combinations<br><br>def part_one():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    print(f\"\u2757\ufe0f Total valid combinations: {sum}\")<br><br>def test_sum_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    assert sum == 21, f\"\u274c Expected: 21, Actual: {sum}\"<br>    print(\"\u2705 OK - test_sum_spring_record_combinations\")<br><br><br>def test_validate_spring_record_ideal():<br>    ideal_spring_condition_records = \"\"\"#.#.### 1,1,3<br>.#...#....###. 1,1,3<br>.#.###.#.###### 1,3,1,6<br>####.#...#... 4,1,1<br>#....######..#####. 1,6,5<br>.###.##....# 3,2,1<br>\"\"\"<br>    for spring_record in ideal_spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        ok = validate_spring_record(spring_state, damaged_spring_record)<br>        assert ok, f\"\u274c Expected: True, Actual: {ok}\"<br>        print(f\"\u2705 OK: {spring_record}\")<br>    print(\"\u2705 OK - test_validate_spring_record_ideal\")<br><br><br><br>if __name__ == \"__main__\":<br>    # test_validate_spring_record_ideal()<br>    test_sum_spring_record_combinations()<br>    part_one()</pre>\n<blockquote>I am aware that we have a lot of wasted compute that we can optimise here, but let\u2019s move on to part 2 as that usually changes the requirements drastically and then we will combine refactor our\u00a0code.</blockquote>\n<h3>Part Two</h3>\n<blockquote>As you look out at the field of springs, you feel like there are way more springs than the condition records list. When you examine the records, you discover that they were actually folded up this whole\u00a0time!</blockquote>\n<blockquote>To unfold the records, on each row, replace the list of spring conditions with five copies of itself (separated by\u00a0?) and replace the list of contiguous groups of damaged springs with five copies of itself (separated by\u00a0,).</blockquote>\n<blockquote>So, this\u00a0row:</blockquote>\n<blockquote>.# 1</blockquote>\n<blockquote>Would become:</blockquote>\n<blockquote>.#?.#?.#?.#?.# 1,1,1,1,1</blockquote>\n<blockquote>The first line of the above example would\u00a0become:</blockquote>\n<blockquote>???.###????.###????.###????.###????.### 1,1,3,1,1,3,1,1,3,1,1,3,1,1,3</blockquote>\n<blockquote>In the above example, after unfolding, the number of possible arrangements for some rows is now much\u00a0larger:</blockquote>\n<blockquote>???.### 1,1,3 - 1 arrangement</blockquote>\n<blockquote>.??..??...?##. 1,1,3 - 16384 arrangements</blockquote>\n<blockquote>?#?#?#?#?#?#?#? 1,3,1,6 - 1 arrangement</blockquote>\n<blockquote>????.#...#... 4,1,1 - 16 arrangements</blockquote>\n<blockquote>????.######..#####. 1,6,5 - 2500 arrangements</blockquote>\n<blockquote>?###???????? 3,2,1 - 506250 arrangements</blockquote>\n<blockquote>After unfolding, adding all of the possible arrangement counts together produces\u00a0525152.</blockquote>\n<blockquote>Unfold your condition records; what is the new sum of possible arrangement counts?</blockquote>\n<p>Aha! Told you. So, now conviniently, springs were actually <strong>folded up </strong>this whole\u00a0time!</p>\n<p>To unfold the sequence, we just need to 5x each row of the record, for\u00a0example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/966/1*s4MTuZ3zRalGpICJhrhfJQ.png\"></figure><p>Clearly, our inefficient code will now not work, as our possible combinations will increase exponentially!</p>\n<blockquote>\ud83d\udca1Well, one simple way I can see to reduce computations is\u00a0to:</blockquote>\n<blockquote>- just integrate the validation logic directly into the combination generation process</blockquote>\n<blockquote>- instead of store all the combinations and then computing length, we can just return the <strong>valid</strong> number of combinations.</blockquote>\n<p>This way, we only generate valid combinations from the start, significantly reducing the number of combinations we need to\u00a0handle.</p>\n<p>Updating code for that, let\u2019s run\u00a0it!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>\u2705 OK - test_sum_spring_record_combinations<br>\u2757\ufe0f Total valid combinations: 7599<br><br>[Done] exited with code=0 in 48.915 seconds</pre>\n<p>And it saved us a grand total of 49.445\u201348.915 = <strong>~530 ms\u00a0\ud83d\ude02</strong></p>\n<a href=\"https://medium.com/media/05826d1b7bcf41e217ad095add326244/href\">https://medium.com/media/05826d1b7bcf41e217ad095add326244/href</a><p>Breaking down the computation, it\u2019s clear that we are <strong>spending a lot of time in</strong> generating \u201call\u201d the possible combinations of the record. Since we already have the damaged_spring_record, we should be able to use it to basically just generate correct combinations? Or at the least, do an <strong>early return</strong> for the all incorrect ones!\u00a0\ud83e\udd14</p>\n<blockquote>The complexity of this problem lies in correctly interpreting the \u2018?\u2019 characters while adhering to the constraints set by the <strong><em>damaged_spring_record</em></strong>.</blockquote>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>\ud83d\udca1 We need to find a way to <strong>prune of our search space early</strong> when a rule from damaged_spring_record is violated in our recursive process itself! Let\u2019s write our early return conditions using our record while navigating through all possible combinations in our recursive function:</p>\n<ul>\n<li>If the damaged_spring_record is empty, <br>- if any spring is damaged: return 0 <br>- else, return\u00a01.</li>\n<li>If the spring_state string is empty, <br>- if there are no damaged spring records left to process: return 1<br>- else, return\u00a00.</li>\n<li>recursively check each spring state and calculate the total number of valid combinations based on whether the current spring is operational, damaged, or\u00a0unknown.</li>\n</ul>\n<p>And since now alot of search space will have repeated calculations, we can use @cache decorator from functools to memoize the results of the recursive function get_valid_spring_record_combinations in an LRU cache with no size\u00a0limit!</p>\n<blockquote>Python does make caching absolutely simple with these nifty OOTB decorators! \ud83e\udd0c</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SOZFKjkeUP6fDZF42V4Ffw.png\"></figure><p>And here, our is_valid_condition would look\u00a0like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/882/1*9jeKFExvbHulJLyT9qmFQQ.png\"></figure><p>\u2757\ufe0f Here, _is_valid_condition returns a boolean value that indicates whether the given spring_state and damaged_spring_record meet the following conditions:</p>\n<ol>\n<li>The first element of damaged_spring_record (which represents the number of damaged springs in the first group) is less than or equal to the length of spring_state. This ensures that there are enough springs in spring_state to account for the first group of damaged\u00a0springs.</li>\n<li>All springs in spring_state up to the index equal to the first element of damaged_spring_record are not operational. This is checked by ensuring that the OPERATIONAL value of the SpringState Enum is not found in the substring of spring_state that ends at the index equal to the first element of damaged_spring_record.</li>\n<li>Either the first element of damaged_spring_record is equal to the length of spring_state (which means that all springs are damaged), or the spring at the index equal to the first element of damaged_spring_record is not damaged. This ensures that there is no damaged spring immediately after the first group of damaged\u00a0springs.</li>\n</ol>\n<p>Let\u2019s run this code for our base test case of part\u00a01:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/748/1*Hw9kB_F1vPM-PDxQxMNqwQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>\u2705 OK - test_sum_spring_record_combinations<br><br>[Done] exited with code=0 in 0.109 seconds</pre>\n<p>And puzzle input for part\u00a01:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*R7ko8-beeAmE7h8LOHK8ig.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>\u2757\ufe0f Total valid combinations: XXXX<br><br>[Done] exited with code=0 in 0.134 seconds</pre>\n<p>Wow! We get the correct answer in just <strong>0.134 seconds </strong>compare this to our previous brute force approach that took <strong>~49 seconds\u00a0\ud83d\ude2f</strong></p>\n<p>Now, let\u2019s also write our base test case for part 2, where all we need to do is, just increase our input per spring_record * 5\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/796/1*1tR0tV2M9F1FkhO9YmgEhg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>\u2705 OK - test_sum_unfolded_spring_record_combinations<br><br>[Done] exited with code=0 in 0.11 seconds</pre>\n<p>Phew! And now let\u2019s do it for part 2, puzzle\u00a0input:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*KwV2lKEhMMicGv2y4jS69Q.png\"><figcaption>* 5 for unfolding \uaa5c</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>\u2757\ufe0f Total valid combinations: XXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.693 seconds</pre>\n<p><strong>Yes! Look at that runtime!\u00a0\ud83d\ude80</strong></p>\n<p>Let\u2019s put this answer in the text box?\u00a0And\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/950/1*HfuXqBmUaJQdhPzx1YC98w.png\"><figcaption>\ud83d\udca5</figcaption></figure><p>Here\u2019s our super optimised code till now, I am not doing object oriented for this one!\u00a0:P</p>\n<pre>from enum import Enum<br>from functools import cache<br><br><br>class SpringState(Enum):<br>    OPERATIONAL = \".\"<br>    DAMAGED = \"#\"<br>    UNKNOWN = \"?\"<br><br><br>@cache<br>def get_valid_spring_record_combinations(spring_state, damaged_spring_record):<br>    if not damaged_spring_record:<br>        if SpringState.DAMAGED.value in spring_state:<br>            return 0<br>        else:<br>            return 1<br><br>    if not spring_state:<br>        if not damaged_spring_record:<br>            return 1<br>        else:<br>            return 0<br><br>    total_combinations = 0<br><br>    # if \".\" or \"?\"<br>    if spring_state[0] in [SpringState.OPERATIONAL.value, SpringState.UNKNOWN.value]:<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state[1:], damaged_spring_record<br>        )<br><br>    # if \"#\" or \"?\"<br>    if spring_state[0] in [SpringState.DAMAGED.value, SpringState.UNKNOWN.value]:<br>        if is_valid_condition(spring_state, damaged_spring_record):<br>            total_combinations += get_valid_spring_record_combinations(<br>                spring_state[damaged_spring_record[0] + 1 :], damaged_spring_record[1:]<br>            )<br><br>    return total_combinations<br><br><br>def is_valid_condition(spring_state, damaged_spring_record):<br>    return (<br>        damaged_spring_record[0] &lt;= len(spring_state)<br>        and SpringState.OPERATIONAL.value<br>        not in spring_state[: damaged_spring_record[0]]<br>        and (<br>            damaged_spring_record[0] == len(spring_state)<br>            or spring_state[damaged_spring_record[0]] != SpringState.DAMAGED.value<br>        )<br>    )<br><br><br>def sum_spring_record_combinations(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        damaged_spring_record = tuple(map(int, damaged_spring_record.split(\",\")))<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state, damaged_spring_record<br>        )<br><br>    return total_combinations<br><br><br>def part_one():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    print(f\"\u2757\ufe0f Total valid combinations: {sum}\")<br><br><br>def sum_spring_record_combinations_unfold(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        damaged_spring_record = tuple(map(int, damaged_spring_record.split(\",\")))<br>        spring_state = \"?\".join([spring_state] * 5)  # unfolding<br>        damaged_spring_record = damaged_spring_record * 5  # unfolding<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state, damaged_spring_record<br>        )<br><br>    return total_combinations<br><br><br>def part_two():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations_unfold(spring_condition_records)<br>    print(f\"\u2757\ufe0f Total valid combinations: {sum}\")<br><br><br>def test_sum_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    assert sum == 21, f\"\u274c Expected: 21, Actual: {sum}\"<br>    print(\"\u2705 OK - test_sum_spring_record_combinations\")<br><br><br>def test_sum_unfolded_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations_unfold(spring_condition_records)<br>    assert sum == 525152, f\"\u274c Expected: 525152, Actual: {sum}\"<br>    print(\"\u2705 OK - test_sum_unfolded_spring_record_combinations\")<br><br><br>if __name__ == \"__main__\":<br>    test_sum_spring_record_combinations()<br>    part_one()<br><br>    test_sum_unfolded_spring_record_combinations()<br>    part_two()</pre>\n<p>Man! I am learning so much with <strong>#AdventOfCode2023</strong>, it\u2019s beautiful that I am getting to revisit a lot of my engineering days concepts that I don\u2019t get to use in my day to day work while building CRUD apps!\u00a0\ud83e\udd13</p>\n<p>Onto the next day\u00a0then?!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=77506773abfb\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["advent-of-code-2023","python","christmas","advent-of-code"]},{"title":"[Day 11] Cosmic Expansion // Advent of Code 2023 (Python)","pubDate":"2023-12-18 10:39:36","link":"https://medium.com/@jatinkrmalik/day-11-cosmic-expansion-advent-of-code-2023-python-6e545dad06bb?source=rss-ec576e4b06b0------2","guid":"https://medium.com/p/6e545dad06bb","author":"Jatin K Malik","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*WU-oHlsxWjavblYa\"><figcaption>Cosmic Expansion (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/11\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You continue following signs for \u201cHot Springs\u201d and eventually come across an <a href=\"https://en.wikipedia.org/wiki/Observatory\">observatory</a>. The Elf within turns out to be a researcher studying cosmic expansion using the giant telescope here.</blockquote>\n<blockquote>He doesn\u2019t know anything about the missing machine parts; he\u2019s only visiting for this research project. However, he confirms that the hot springs are the next-closest area likely to have people; he\u2019ll even take you straight there once he\u2019s done with today\u2019s observation analysis.</blockquote>\n<blockquote>Maybe you can help him with the analysis to speed things\u00a0up?</blockquote>\n<blockquote>The researcher has collected a bunch of data and compiled the data into a single giant image (your puzzle input). The image includes empty space (.) and galaxies (#). For\u00a0example:</blockquote>\n<blockquote>...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....</blockquote>\n<blockquote>The researcher is trying to figure out the sum of the lengths of the shortest path between every pair of galaxies. However, there\u2019s a catch: the universe expanded in the time it took the light from those galaxies to reach the observatory.</blockquote>\n<blockquote>Due to something involving gravitational effects, only some space expands. In fact, the result is that any rows or columns that contain no galaxiesshould all actually be twice as\u00a0big.</blockquote>\n<blockquote>In the above example, three columns and two rows contain no galaxies:</blockquote>\n<blockquote>v v v<br>\u00a0...#......<br>\u00a0.......#..<br> #.........<br>&gt;..........&lt;<br>\u00a0......#...<br>\u00a0.#........<br>\u00a0.........#<br>&gt;..........&lt;<br>\u00a0.......#..<br> #...#.....<br> ^ ^\u00a0^</blockquote>\n<blockquote>These rows and columns need to be twice as big; the result of cosmic expansion therefore looks like\u00a0this:</blockquote>\n<blockquote>....#........<br>.........#...<br>#............<br>.............<br>.............<br>........#....<br>.#...........<br>............#<br>.............<br>.............<br>.........#...<br>#....#.......</blockquote>\n<blockquote>Equipped with this expanded universe, the shortest path between every pair of galaxies can be found. It can help to assign every galaxy a unique\u00a0number:</blockquote>\n<blockquote>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>............6<br>.............<br>.............<br>.........7...<br>8....9.......</blockquote>\n<blockquote>In these 9 galaxies, there are 36 pairs. Only count each pair once; order within the pair doesn\u2019t matter. For each pair, find any shortest path between the two galaxies using only steps that move up, down, left, or right exactly one\u00a0. or # at a time. (The shortest path between two galaxies is allowed to pass through another\u00a0galaxy.)</blockquote>\n<blockquote>For example, here is one of the shortest paths between galaxies 5 and\u00a09:</blockquote>\n<blockquote>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>.##.........6<br>..##.........<br>...##........<br>....##...7...<br>8....9.......</blockquote>\n<blockquote>This path has length 9 because it takes a minimum of nine steps to get from galaxy 5 to galaxy 9 (the eight locations marked # plus the step onto galaxy 9 itself). Here are some other example shortest path\u00a0lengths:</blockquote>\n<blockquote>Between galaxy 1 and galaxy 7:\u00a015</blockquote>\n<blockquote>Between galaxy 3 and galaxy 6:\u00a017</blockquote>\n<blockquote>Between galaxy 8 and galaxy 9:\u00a05</blockquote>\n<blockquote>In this example, after expanding the universe, the sum of the shortest path between all 36 pairs of galaxies is\u00a0374.</blockquote>\n<blockquote>Expand the universe, then find the length of the shortest path between every pair of galaxies. What is the sum of these\u00a0lengths?</blockquote>\n<p><em>Finally! A space exploration problem. I am a sucker for\u00a0those!</em></p>\n<p>So, let\u2019s look at the problem, we have an image of space from the observatory and it looks something like\u00a0this:</p>\n<pre>...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....</pre>\n<p>And we need to compute the sum of the lengths of the shortest path between every pair of galaxies!</p>\n<blockquote>\u2757\ufe0fThe catch being, that by the time light reaches to us, the space expands due to ever expanding universe, but only some part, resulting in any <strong>rows or columns</strong> that contain <strong>no galaxies</strong> should all actually be <strong>twice as\u00a0big.</strong>\n</blockquote>\n<p>Let\u2019s visualise this?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lUFvdLG-8zW-7eo4Vvl74w.png\"><figcaption>This seems like a good first\u00a0step</figcaption></figure><p>Once we have the final image! We can just number the galaxies\u00a0like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*hZRn53JjHjOFcBspyvzYLA.png\"></figure><p>And then we can just find the shortest distance from each pair of galaxies!</p>\n<p>Seems pretty straight forward right? Let\u2019s\u00a0code!</p>\n<p>As usual, I will begin with writing our base case as the ultimate validator!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/528/1*wpLfzZ-B7q-gkt46Zka26A.png\"></figure><p>And now let\u2019s start expanding! It\u2019s clear we first need to <strong><em>expand</em></strong> space by finding empty rows and columns and doubling it. So, let\u2019s first just do\u00a0that.</p>\n<p>Here\u2019s a simple function expand_space that just does\u00a0that:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IvD01NKWBgQB3m5LNNoSOQ.png\"></figure><blockquote>\ud83d\udca1 Caught a bug, as if we modify the space_map while iterating through it, the empty_rows elements start to point to an incorrect index. To fix that, we can just introduce something like a mod_count which can help us keep a track of original index in modified space_map.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VoSoXFEiPUwgq5Kqi7hERw.png\"><figcaption>Fixed!</figcaption></figure><p>Now we can find all the galaxies locations in the expanded_space_map with a simple function:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/471/1*LszcXw2pLv5S_15-MqpBCQ.png\"></figure><p>\ud83d\udcad The last step is to now take 1 galaxy and find its shortest distance from all other galaxies and then repeat this process for all galaxies!</p>\n<p>Well, before even touching the code, I can already see a lot of steps to optimise this one! For example: If we have found the shortest distance from Galaxy_1 to Galaxy_2\u00a0, it will be same other way around, so we can save extra compute by just refering to a\u00a0cache.</p>\n<pre>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>............6<br>.............<br>.............<br>.........7...<br>8....9.......</pre>\n<p>So, in case of this example, where we have 9 galaxies can could have 81 combinations, since we can\u2019t repeat a pair, the formula\u00a0becomes:</p>\n<blockquote>Number of combinations= <em>n</em>! / <em>r</em>!(<em>n</em>\u2212<em>r</em>)!\u200b</blockquote>\n<p>Solving for our\u00a0case:</p>\n<blockquote>\n<em>9C</em>2\u200b = 9! / 2!(9\u22122)! \u200b=\u00a036</blockquote>\n<p><strong>36 combinations!</strong></p>\n<p>Let\u2019s write some code? I will be using good\u2019ol <strong>BFS (breadth first search)</strong> to find the shortest path for each pair of galaxies. <em>We may come back and optimise this to a more greedy approach for faster computation!</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fnAe9-H1FYiZRcnQHgc26Q.png\"><figcaption>Classic BFS!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*2_MOrRwleCiWT4-DMKLxNg.png\"><figcaption>Ofcourse, I forgot `list` is unhashable \ud83e\udd26\u200d\u2642\ufe0f</figcaption></figure><p>We can always hash a tupple though!\u00a0;)</p>\n<p>Finally after a lot of iterations:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HOtCjKwT6txXLOfaCZCd9w.png\"><figcaption>36!</figcaption></figure><p>Let\u2019s check our test case\u00a0now?</p>\n<p>Here\u2019s our MVP code till\u00a0now:</p>\n<pre># Day 11: Cosmic Expansion<br><br>from enum import Enum<br><br><br>EMPTY_SPACE = \".\"<br>GALAXY = \"#\"<br>DISTANCE_MAP = {}<br><br>class Direction(Enum):<br>        RIGHT = (0, 1)<br>        LEFT = (0, -1)<br>        DOWN = (1, 0)<br>        UP = (-1, 0)<br><br><br>def expand_space_map(space_map):<br>    empty_rows, empty_cols = [], []<br><br>    for i, row in enumerate(space_map):<br>        if GALAXY not in row:<br>            empty_rows.append(i)<br><br>    for i, col in enumerate(space_map[0]):<br>        if GALAXY not in [row[i] for row in space_map]:<br>            empty_cols.append(i)<br><br>    mod_count = 0<br>    for i in empty_rows:<br>        space_map.insert(i + mod_count, EMPTY_SPACE * len(space_map[i]))<br>        mod_count += 1<br><br>    mod_count = 0<br>    for i in empty_cols:<br>        for j, row in enumerate(space_map):<br>            space_map[j] = row[: i + mod_count] + EMPTY_SPACE + row[i + mod_count :]<br>        mod_count += 1<br><br>    return space_map<br><br><br>def find_shortest_distance(galaxy1, galaxy2, space_map):<br>    print(f\"Finding shortest distance between {galaxy1} and {galaxy2}\")<br>    # check if the distance between the two galaxies is already calculated<br>    distance = DISTANCE_MAP.get(galaxy1, {}).get(galaxy2) or DISTANCE_MAP.get(<br>        galaxy2, {}<br>    ).get(galaxy1)<br>    if distance:<br>        return distance<br><br>    # using BFS to find the shortest path between two galaxies<br>    queue = [galaxy1]  # initialize the queue with the starting galaxy<br>    visited = set()  # set to keep track of visited galaxies<br>    distance = 0  # initialize the distance to 0<br>    while queue:<br>        for _ in range(len(queue)):<br>            current = queue.pop(0)  # get the next galaxy from the queue<br>            if current == galaxy2:  # if we reach the destination galaxy<br>                if galaxy1 not in DISTANCE_MAP:<br>                    DISTANCE_MAP[galaxy1] = {}<br>                DISTANCE_MAP[galaxy1][galaxy2] = distance  # store the distance between the galaxies<br>                return distance<br>            visited.add(current)  # mark the current galaxy as visited<br><br>            for direction in Direction:  # explore all possible directions<br>                i, j = current[0] + direction.value[0], current[1] + direction.value[1]<br>                if (<br>                    0 &lt;= i &lt; len(space_map)<br>                    and 0 &lt;= j &lt; len(space_map[0])<br>                    and (i, j) not in visited<br>                ):<br>                    queue.append((i, j))  # add the neighboring galaxy to the queue<br>        distance += 1  # increment the distance after exploring all galaxies at the current level<br><br>    raise Exception(\"No path found between the two galaxies\")<br><br><br>def find_all_galaxies(space_map):<br>    galaxies = []<br>    for i, row in enumerate(space_map):<br>        for j, col in enumerate(row):<br>            if col == GALAXY:<br>                galaxies.append((i, j))<br>    return galaxies<br><br><br>def analyze_space(space_map):<br>    expanded_space_map = expand_space_map(space_map)<br>    print(f\"Expanded space map is {len(expanded_space_map)} x {len(expanded_space_map[0])}\")<br>    galaxies_locations = find_all_galaxies(expanded_space_map)<br>    print(f\"Number of galaxies: {len(galaxies_locations)}\")<br><br>    for galaxy1 in galaxies_locations:<br>        for galaxy2 in galaxies_locations:<br>            if galaxy1 != galaxy2:<br>                find_shortest_distance(galaxy1, galaxy2, expanded_space_map)<br><br>    sum = 0 <br>    for k,v in DISTANCE_MAP.items():<br>        for k1,v1 in v.items():<br>            sum += v1<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br>    sum =  analyze_space(space_map)<br>    print(f\"\u2757\ufe0f Sum of the lengths of the shortest path between every pair of galaxies: {sum}\")<br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br><br>    sum = analyze_space(space_map.splitlines())<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"\u2705 Passed test_analyze_observation()\")<br><br><br>if __name__ == \"__main__\":<br>    test_analyze_space()<br>    # part_one()</pre>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>\u2705 Passed test_analyze_observation()<br><br>[Done] exited with code=0 in 7.131 seconds</pre>\n<p>Well, it did took 7.131 seconds to compute for a simple testcase, let\u2019s see if it can do it for puzzle\u00a0input?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/991/1*qsb5pCVb9HnxVVOv7uzGzQ.png\"></figure><p>And compute!!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*NTrAEUF4t-HG-9FlN3uA6Q.png\"><figcaption>2 mins in, doesn\u2019t seem\u00a0likely!</figcaption></figure><p>Let\u2019s add some logging to understand the scale of the\u00a0problem?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/896/1*KatgSN7P3HCewqc06-gjLw.gif\"><figcaption>Yeah\u2026.this is not gonna\u00a0compute!</figcaption></figure><p>We have 426 Galaxies in a map of size 151 x 147 which gives us 426C2 combinations, equaling 90525 possible pairs! We need to make it more efficient!</p>\n<blockquote>While, I can take the easy path of just doings the <strong>Bi-directional BFS</strong> where I can look up from both Galaxy 1 and Galaxy 2, I feels it\u2019s better to take a peak into <strong>A* or Dijkstra\u2019s </strong>Algorithm for our shortest path finding to be more efficient!</blockquote>\n<p>I am bit rusty don\u2019t remember A* algo exactly but I do remember that A* is a type of <strong>greedy approch</strong> which does a <strong>smart search</strong> through a maze, where at each step it makes an <strong>informed guess</strong> about the best next step based on <em>how far it has already traveled</em> and <em>how far it still has to go</em>, according to the map. It\u2019s a blend of exploring and using what you know to make good guesses, which makes it efficient and effective for finding\u00a0paths.</p>\n<p>Let\u2019s use Github Copilot to quickly generate a A* method for searching and then refactor it to suit our galaxy and space_map problem:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YrmYmgoRwh7xZY6OUTjUHQ.png\"><figcaption>Looks good!</figcaption></figure><p>Now, let\u2019s run for the base test case with our logging\u00a0enabled?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>Expanded space map is 12 x 13<br>Number of galaxies: 9<br>Finding shortest distance between (0, 4) and (1, 9)<br>Finding shortest distance between (0, 4) and (2, 0)<br>Finding shortest distance between (0, 4) and (5, 8)<br>Finding shortest distance between (0, 4) and (6, 1)<br>Finding shortest distance between (0, 4) and (7, 12)<br>Finding shortest distance between (0, 4) and (10, 9)<br>Finding shortest distance between (0, 4) and (11, 0)<br>Finding shortest distance between (0, 4) and (11, 5)<br>Finding shortest distance between (1, 9) and (0, 4)<br>Finding shortest distance between (1, 9) and (2, 0)<br>Finding shortest distance between (1, 9) and (5, 8)<br>Finding shortest distance between (1, 9) and (6, 1)<br>Finding shortest distance between (1, 9) and (7, 12)<br>Finding shortest distance between (1, 9) and (10, 9)<br>Finding shortest distance between (1, 9) and (11, 0)<br>Finding shortest distance between (1, 9) and (11, 5)<br>Finding shortest distance between (2, 0) and (0, 4)<br>Finding shortest distance between (2, 0) and (1, 9)<br>Finding shortest distance between (2, 0) and (5, 8)<br>Finding shortest distance between (2, 0) and (6, 1)<br>Finding shortest distance between (2, 0) and (7, 12)<br>Finding shortest distance between (2, 0) and (10, 9)<br>Finding shortest distance between (2, 0) and (11, 0)<br>Finding shortest distance between (2, 0) and (11, 5)<br>Finding shortest distance between (5, 8) and (0, 4)<br>Finding shortest distance between (5, 8) and (1, 9)<br>Finding shortest distance between (5, 8) and (2, 0)<br>Finding shortest distance between (5, 8) and (6, 1)<br>Finding shortest distance between (5, 8) and (7, 12)<br>Finding shortest distance between (5, 8) and (10, 9)<br>Finding shortest distance between (5, 8) and (11, 0)<br>Finding shortest distance between (5, 8) and (11, 5)<br>Finding shortest distance between (6, 1) and (0, 4)<br>Finding shortest distance between (6, 1) and (1, 9)<br>Finding shortest distance between (6, 1) and (2, 0)<br>Finding shortest distance between (6, 1) and (5, 8)<br>Finding shortest distance between (6, 1) and (7, 12)<br>Finding shortest distance between (6, 1) and (10, 9)<br>Finding shortest distance between (6, 1) and (11, 0)<br>Finding shortest distance between (6, 1) and (11, 5)<br>Finding shortest distance between (7, 12) and (0, 4)<br>Finding shortest distance between (7, 12) and (1, 9)<br>Finding shortest distance between (7, 12) and (2, 0)<br>Finding shortest distance between (7, 12) and (5, 8)<br>Finding shortest distance between (7, 12) and (6, 1)<br>Finding shortest distance between (7, 12) and (10, 9)<br>Finding shortest distance between (7, 12) and (11, 0)<br>Finding shortest distance between (7, 12) and (11, 5)<br>Finding shortest distance between (10, 9) and (0, 4)<br>Finding shortest distance between (10, 9) and (1, 9)<br>Finding shortest distance between (10, 9) and (2, 0)<br>Finding shortest distance between (10, 9) and (5, 8)<br>Finding shortest distance between (10, 9) and (6, 1)<br>Finding shortest distance between (10, 9) and (7, 12)<br>Finding shortest distance between (10, 9) and (11, 0)<br>Finding shortest distance between (10, 9) and (11, 5)<br>Finding shortest distance between (11, 0) and (0, 4)<br>Finding shortest distance between (11, 0) and (1, 9)<br>Finding shortest distance between (11, 0) and (2, 0)<br>Finding shortest distance between (11, 0) and (5, 8)<br>Finding shortest distance between (11, 0) and (6, 1)<br>Finding shortest distance between (11, 0) and (7, 12)<br>Finding shortest distance between (11, 0) and (10, 9)<br>Finding shortest distance between (11, 0) and (11, 5)<br>Finding shortest distance between (11, 5) and (0, 4)<br>Finding shortest distance between (11, 5) and (1, 9)<br>Finding shortest distance between (11, 5) and (2, 0)<br>Finding shortest distance between (11, 5) and (5, 8)<br>Finding shortest distance between (11, 5) and (6, 1)<br>Finding shortest distance between (11, 5) and (7, 12)<br>Finding shortest distance between (11, 5) and (10, 9)<br>Finding shortest distance between (11, 5) and (11, 0)<br>\u2705 Passed test_analyze_observation()<br><br>[Done] exited with code=0 in 0.121 seconds</pre>\n<blockquote>Woah! <strong>0.121 seconds</strong> for the base test case. Comparing this to our previous <em>BFS</em> approach that took <strong>7.131 seconds </strong>to churn out the answers, <em>A*</em> approach is almost <strong>~59x faster!\u00a0\ud83d\ude80</strong>\n</blockquote>\n<p>Let\u2019s run for our puzzle input and go make a coffee!\u00a0\u2615\ufe0f</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br><br>\u2757\ufe0f Sum of the lengths of the shortest path between every pair of galaxies: XXXXX<br><br>[Done] exited with code=0 in 982.651 seconds</pre>\n<p>Well, this took only <strong>982.651 seconds ~ 16.377 minutes</strong> to run! And this happened because I just ran it and went to make coffee and when I came back, I was it was somewhere around 148th row. Since, I knew we have a total 151 rows only, I just let it\u00a0run!</p>\n<pre>Finding shortest distance between (148, 104) and (119, 66)<br>Finding shortest distance between (148, 104) and (119, 105)<br>Finding shortest distance between (148, 104) and (119, 116)</pre>\n<p>So, let\u2019s input our answer into the box\u00a0and\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/830/1*Nld_W8c57EDwOGkKVJHi_g.png\"><figcaption>Yay! \ud83d\ude4c</figcaption></figure><p>Here\u2019s our unpythonic code till now, I will optimise it in Part\u00a02:</p>\n<pre># Day 11: Cosmic Expansion<br><br>from enum import Enum<br>import heapq<br><br><br>EMPTY_SPACE = \".\"<br>GALAXY = \"#\"<br>DISTANCE_MAP = {}<br><br><br>class Direction(Enum):<br>    RIGHT = (0, 1)<br>    LEFT = (0, -1)<br>    DOWN = (1, 0)<br>    UP = (-1, 0)<br><br><br>def calculate_distance(a, b):<br>    return abs(a[0] - b[0]) + abs(a[1] - b[1])  # Manhattan distance<br><br><br>def get_adjacent_galaxies(space_map, galaxy):<br>    adjacent_galaxies = []<br>    for direction in Direction:<br>        i, j = galaxy[0] + direction.value[0], galaxy[1] + direction.value[1]<br>        if 0 &lt;= i &lt; len(space_map) and 0 &lt;= j &lt; len(space_map[0]):<br>            adjacent_galaxies.append((i, j))<br>    return adjacent_galaxies<br><br><br>def find_shortest_path(space_map, start_galaxy, end_galaxy):<br>    galaxies_to_visit = []<br>    heapq.heappush(galaxies_to_visit, (0, start_galaxy))<br>    previous_galaxy = {}<br>    cost_to_reach = {start_galaxy: 0}<br>    estimated_total_cost = {start_galaxy: calculate_distance(start_galaxy, end_galaxy)}<br><br>    while galaxies_to_visit:<br>        current_galaxy = heapq.heappop(galaxies_to_visit)[1]<br><br>        if current_galaxy == end_galaxy:<br>            return cost_to_reach[<br>                current_galaxy<br>            ]  # Return the cost to reach the end galaxy<br><br>        for adjacent_galaxy in get_adjacent_galaxies(space_map, current_galaxy):<br>            tentative_cost = cost_to_reach[current_galaxy] + 1  # assuming uniform cost<br>            if (<br>                adjacent_galaxy not in cost_to_reach<br>                or tentative_cost &lt; cost_to_reach[adjacent_galaxy]<br>            ):<br>                previous_galaxy[adjacent_galaxy] = current_galaxy<br>                cost_to_reach[adjacent_galaxy] = tentative_cost<br>                estimated_total_cost[<br>                    adjacent_galaxy<br>                ] = tentative_cost + calculate_distance(adjacent_galaxy, end_galaxy)<br>                heapq.heappush(<br>                    galaxies_to_visit,<br>                    (estimated_total_cost[adjacent_galaxy], adjacent_galaxy),<br>                )<br><br>    raise Exception(\"No path found between the two galaxies\")<br><br><br>def expand_space_map(space_map):<br>    empty_rows, empty_cols = [], []<br><br>    for i, row in enumerate(space_map):<br>        if GALAXY not in row:<br>            empty_rows.append(i)<br><br>    for i, col in enumerate(space_map[0]):<br>        if GALAXY not in [row[i] for row in space_map]:<br>            empty_cols.append(i)<br><br>    mod_count = 0<br>    for i in empty_rows:<br>        space_map.insert(i + mod_count, EMPTY_SPACE * len(space_map[i]))<br>        mod_count += 1<br><br>    mod_count = 0<br>    for i in empty_cols:<br>        for j, row in enumerate(space_map):<br>            space_map[j] = row[: i + mod_count] + EMPTY_SPACE + row[i + mod_count :]<br>        mod_count += 1<br><br>    return space_map<br><br><br>def find_shortest_distance(galaxy1, galaxy2, space_map):<br>    print(f\"Finding shortest distance between {galaxy1} and {galaxy2}\")<br><br>    distance = DISTANCE_MAP.get(galaxy1, {}).get(galaxy2) or DISTANCE_MAP.get(<br>        galaxy2, {}<br>    ).get(galaxy1)<br>    if distance:<br>        return distance<br><br>    distance = find_shortest_path(space_map, galaxy1, galaxy2)  # Use A* for pathfinding<br><br>    if galaxy1 not in DISTANCE_MAP:<br>        DISTANCE_MAP[galaxy1] = {}<br>    DISTANCE_MAP[galaxy1][galaxy2] = distance<br>    return distance<br><br><br>def find_all_galaxies(space_map):<br>    galaxies = []<br>    for i, row in enumerate(space_map):<br>        for j, col in enumerate(row):<br>            if col == GALAXY:<br>                galaxies.append((i, j))<br>    return galaxies<br><br><br>def analyze_space(space_map):<br>    expanded_space_map = expand_space_map(space_map)<br>    print(<br>        f\"Expanded space map is {len(expanded_space_map)} x {len(expanded_space_map[0])}\"<br>    )<br>    galaxies_locations = find_all_galaxies(expanded_space_map)<br>    print(f\"Number of galaxies: {len(galaxies_locations)}\")<br><br>    for galaxy1 in galaxies_locations:<br>        for galaxy2 in galaxies_locations:<br>            if galaxy1 != galaxy2:<br>                find_shortest_distance(galaxy1, galaxy2, expanded_space_map)<br><br>    sum = 0<br>    for k, v in DISTANCE_MAP.items():<br>        for k1, v1 in v.items():<br>            sum += v1<br><br>    return sum<br><br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br>    sum = analyze_space(space_map)<br>    print(<br>        f\"\u2757\ufe0f Sum of the lengths of the shortest path between every pair of galaxies: {sum}\"<br>    )<br><br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br><br>    sum = analyze_space(space_map.splitlines())<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"\u2705 Passed test_analyze_observation()\")<br><br><br>if __name__ == \"__main__\":<br>    # test_analyze_space()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>The galaxies are much older (and thus much farther apart) than the researcher initially estimated.</blockquote>\n<blockquote>Now, instead of the expansion you did before, make each empty row or column one million times larger. That is, each empty row should be replaced with 1000000 empty rows, and each empty column should be replaced with 1000000empty columns.</blockquote>\n<blockquote>(In the example above, if each empty row or column were merely 10 times larger, the sum of the shortest paths between every pair of galaxies would be 1030. If each empty row or column were merely 100 times larger, the sum of the shortest paths between every pair of galaxies would be 8410. However, your universe will need to expand far beyond these\u00a0values.)</blockquote>\n<blockquote>Starting with the same initial image, expand the universe according to these new rules, then find the length of the shortest path between every pair of galaxies. What is the sum of these\u00a0lengths?</blockquote>\n<p>Well, of course, the galaxies are much\u00a0<strong>older!</strong></p>\n<p>So, looks like we need to update how we expand our space map buy a factor of <strong>one million times, </strong>that is<strong>, 1000000x, </strong>for each empty row and\u00a0column!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*pwCxlg2tQmeeKVJebYZhTQ.png\"></figure><blockquote>Yep! Our current code will not scale at all. <strong>Probably</strong> our solar system sun will collapse into itself before our single threaded Python will be able to compute anything!</blockquote>\n<p>So\u2026let\u2019s rethink\u00a0this!</p>\n<p>.</p>\n<p>.</p>\n<blockquote>Well shit! Why do I even need any path finding algo here? Isn\u2019t this just simple matrix manipulation? I think I ended up doing over-engineering here! This is classic trap of being Principal Engineer, making problems look more complex than they actually\u00a0are!</blockquote>\n<h3>Revisting Part\u00a01</h3>\n<p>This problem required solving just <strong>Manhattan distance</strong> between 2 nodes. Here\u2019s an example to get distance between (Galaxy 1, Galaxy 4) and (Galaxy 5, Galaxy\u00a08):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/406/1*FeZ6DaSbYqtfO-B15zLeWg.png\"></figure><p>The formula to get this is absurdly simple as\u00a0well:</p>\n<blockquote>Manhattan Distance = |x1\u200a\u2014\u200ay1| + |x2\u200a\u2014\u200ay2|</blockquote>\n<p>Which makes my code as simple\u00a0as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/837/1*Ro92d-LT-I3LQGcqxirC3A.png\"></figure><p>Solving for part 1, testing with base test case and puzzle\u00a0input:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>Expanded space map is 12 x 13<br>Number of galaxies: 9<br>Number of possible pairs of galaxies: 36<br>\u2705 Passed test_analyze_observation()<br>Expanded space map is 151 x 147<br>Number of galaxies: 426<br>Number of possible pairs of galaxies: 90525<br>\u2757\ufe0f Sum of the lengths of the shortest path between every pair of galaxies: xxxxxx<br><br>[Done] exited with code=0 in 0.199 seconds</pre>\n<p>Yep, correct answer!\u00a0\ud83e\udd72</p>\n<h4>Back to Part\u00a02</h4>\n<p>Now, all that is changing is, the <strong>expansion distance</strong> between pairs of galaxies.</p>\n<p>\ud83d\udcad If we can somehow just find the number of rows + cols to be modified compared to initial galaxy, we can just do the computation on original space_map and then just increase the distance by a factor of\u00a01000000</p>\n<blockquote>\ud83d\udca1 We can further simplify our code by not having to do the expansion at all as per part\u00a01</blockquote>\n<p>We can introduce a new param\u200a\u2014\u200aexpansion_factor which we can pass as 2 for the part one, and 1000000 for part two to keep our code\u00a0modular.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*w3rB_I5L5KXzI1CY-AY8ow.png\"></figure><p>Let\u2019s update our base test\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/817/1*FgsL03tvwa3UA2ExhCPylg.png\"></figure><p>And let\u2019s run\u00a0this:</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>\u2705 Passed test_analyze_observation() for expansion_factor=2<br>\u2705 Passed test_analyze_observation() for expansion_factor=10<br>\u2705 Passed test_analyze_observation() for expansion_factor=100</pre>\n<p>Phew! We can now just load up our puzzle input and call for our 10\u2076 expansion_factor\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qbE8EN2SEYiGUYEuTEw2bA.png\"></figure><p>Let\u2019s run this\u00a0up!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>\u2705 Passed test_analyze_observation() for expansion_factor=2<br>\u2705 Passed test_analyze_observation() for expansion_factor=10<br>\u2705 Passed test_analyze_observation() for expansion_factor=100<br>\u2757\ufe0f Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=2: xxxx<br>\u203c\ufe0f Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=1000000: xxxxxxxxxx<br><br>[Done] exited with code=0 in 0.843 seconds</pre>\n<p>We get the answer in <strong>0.843 seconds\u2026.for BOTH the parts + 3 test cases</strong>!\u00a0\ud83d\ude39</p>\n<p>This is why I absolutely love\u00a0coding!</p>\n<p>Let\u2019s put this answer in the input box and\u2026.profit!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/821/1*Me6mzkKI4sceFKZRH8rVWg.png\"><figcaption>\ud83c\udf0c\ud83c\udf0c\ud83c\udf0c</figcaption></figure><p>Here\u2019s our final pythonic yet highly performant code:</p>\n<pre># Day 11: Cosmic Expansion<br><br>class CosmicGrid:<br>    def __init__(self, space_grid):<br>        # Initialize the cosmic grid with the provided space grid<br>        self.space_grid = space_grid<br>        self.grid_height = len(space_grid)<br>        self.grid_width = len(space_grid[0])<br>        # Find rows and columns that are entirely empty<br>        self.empty_rows = self._find_empty_rows()<br>        self.empty_columns = self._find_empty_columns()<br>        # Locate all galaxies within the grid<br>        self.galaxy_positions = self._find_galaxy_positions()<br><br>    def _find_empty_rows(self):<br>        # Identify rows that contain only empty space<br>        empty_rows = set()<br>        for row in range(self.grid_height):<br>            if all(cell == '.' for cell in self.space_grid[row]):<br>                empty_rows.add(row)<br>        return empty_rows<br><br>    def _find_empty_columns(self):<br>        # Identify columns that contain only empty space<br>        empty_columns = set()<br>        for col in range(self.grid_width):<br>            if all(self.space_grid[row][col] == '.' for row in range(self.grid_height)):<br>                empty_columns.add(col)<br>        return empty_columns<br><br>    def _find_galaxy_positions(self):<br>        # Record the positions of all galaxies in the grid<br>        galaxy_positions = []<br>        for row in range(self.grid_height):<br>            for col in range(self.grid_width):<br>                if self.space_grid[row][col] == '#':<br>                    galaxy_positions.append((row, col))<br>        return galaxy_positions<br><br>    def find_shortest_distance(self, galaxy1, galaxy2, expansion_factor):<br>        # Calculate the shortest distance between two galaxies, factoring in cosmic expansion<br>        row_distance = 0<br>        for r in range(min(galaxy1[0], galaxy2[0]), max(galaxy1[0], galaxy2[0]) + 1):<br>            if r in self.empty_rows:<br>                row_distance += 1<br><br>        col_distance = 0<br>        for c in range(min(galaxy1[1], galaxy2[1]), max(galaxy1[1], galaxy2[1]) + 1):<br>            if c in self.empty_columns:<br>                col_distance += 1<br><br>        # Expanded distance is calculated by multiplying empty distances by the expansion factor<br>        # Direct distance is the straight line distance, not through empty space<br>        expanded_row_distance = row_distance * expansion_factor<br>        expanded_col_distance = col_distance * expansion_factor<br>        direct_distance = abs(galaxy1[0] - galaxy2[0]) + abs(galaxy1[1] - galaxy2[1])<br><br>        return expanded_row_distance + expanded_col_distance + direct_distance - row_distance - col_distance<br><br>    def sum_of_shortest_paths(self, expansion_factor):<br>        # Sum the shortest paths between all pairs of galaxies<br>        total_distance = 0<br>        for i, galaxy1 in enumerate(self.galaxy_positions):<br>            for galaxy2 in self.galaxy_positions[i + 1:]:<br>                total_distance += self.find_shortest_distance(galaxy1, galaxy2, expansion_factor)<br>        return total_distance<br><br><br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br><br>    cosmic_grid = CosmicGrid(space_map)<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=2)<br>    print(<br>        f\"\u2757\ufe0f Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=2: {sum}\"<br>    )<br><br><br>def part_two():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br><br>    cosmic_grid = CosmicGrid(space_map)<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=1000000)<br>    print(<br>        f\"\u203c\ufe0f Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=1000000: {sum}\"<br>    )<br><br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br>    cosmic_grid = CosmicGrid(space_map.splitlines())<br>    # part one<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=2)<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"\u2705 Passed test_analyze_observation() for expansion_factor=2\")<br><br>    # part two<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=10)<br>    assert sum == 1030, f\"Expected 1030, got {sum}\"<br>    print(\"\u2705 Passed test_analyze_observation() for expansion_factor=10\")<br><br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=100)<br>    assert sum == 8410, f\"Expected 8410, got {sum}\"<br>    print(\"\u2705 Passed test_analyze_observation() for expansion_factor=100\")<br><br><br>if __name__ == \"__main__\":<br>    test_analyze_space()<br>    part_one()<br>    part_two()</pre>\n<p><strong>\u2618\ufe0f Moral of the story? </strong>As a Principal Engineer, I\u2019m wired to navigate complex problems, often defaulting to intricate solutions like BFS, DFS, Dijkstra, and\u00a0A*.</p>\n<p>Here, I overcomplicated a straightforward task that simply needed the Manhattan distance formula. This experience was a humbling reminder that sometimes, <strong>simplicity is key</strong>. It\u2019s easy to overlook the obvious when your mind is tuned to complexity. It\u2019s crucial to step back and reassess, as the simplest path often leads to the most elegant solution.</p>\n<blockquote><strong><em>This was a lesson in the beauty of simplicity in problem-solving.</em></strong></blockquote>\n<p>p.s: I am deliberating not adding answers here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6e545dad06bb\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*WU-oHlsxWjavblYa\"><figcaption>Cosmic Expansion (via DALL-E\u00a03)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/11\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You continue following signs for \u201cHot Springs\u201d and eventually come across an <a href=\"https://en.wikipedia.org/wiki/Observatory\">observatory</a>. The Elf within turns out to be a researcher studying cosmic expansion using the giant telescope here.</blockquote>\n<blockquote>He doesn\u2019t know anything about the missing machine parts; he\u2019s only visiting for this research project. However, he confirms that the hot springs are the next-closest area likely to have people; he\u2019ll even take you straight there once he\u2019s done with today\u2019s observation analysis.</blockquote>\n<blockquote>Maybe you can help him with the analysis to speed things\u00a0up?</blockquote>\n<blockquote>The researcher has collected a bunch of data and compiled the data into a single giant image (your puzzle input). The image includes empty space (.) and galaxies (#). For\u00a0example:</blockquote>\n<blockquote>...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....</blockquote>\n<blockquote>The researcher is trying to figure out the sum of the lengths of the shortest path between every pair of galaxies. However, there\u2019s a catch: the universe expanded in the time it took the light from those galaxies to reach the observatory.</blockquote>\n<blockquote>Due to something involving gravitational effects, only some space expands. In fact, the result is that any rows or columns that contain no galaxiesshould all actually be twice as\u00a0big.</blockquote>\n<blockquote>In the above example, three columns and two rows contain no galaxies:</blockquote>\n<blockquote>v v v<br>\u00a0...#......<br>\u00a0.......#..<br> #.........<br>&gt;..........&lt;<br>\u00a0......#...<br>\u00a0.#........<br>\u00a0.........#<br>&gt;..........&lt;<br>\u00a0.......#..<br> #...#.....<br> ^ ^\u00a0^</blockquote>\n<blockquote>These rows and columns need to be twice as big; the result of cosmic expansion therefore looks like\u00a0this:</blockquote>\n<blockquote>....#........<br>.........#...<br>#............<br>.............<br>.............<br>........#....<br>.#...........<br>............#<br>.............<br>.............<br>.........#...<br>#....#.......</blockquote>\n<blockquote>Equipped with this expanded universe, the shortest path between every pair of galaxies can be found. It can help to assign every galaxy a unique\u00a0number:</blockquote>\n<blockquote>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>............6<br>.............<br>.............<br>.........7...<br>8....9.......</blockquote>\n<blockquote>In these 9 galaxies, there are 36 pairs. Only count each pair once; order within the pair doesn\u2019t matter. For each pair, find any shortest path between the two galaxies using only steps that move up, down, left, or right exactly one\u00a0. or # at a time. (The shortest path between two galaxies is allowed to pass through another\u00a0galaxy.)</blockquote>\n<blockquote>For example, here is one of the shortest paths between galaxies 5 and\u00a09:</blockquote>\n<blockquote>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>.##.........6<br>..##.........<br>...##........<br>....##...7...<br>8....9.......</blockquote>\n<blockquote>This path has length 9 because it takes a minimum of nine steps to get from galaxy 5 to galaxy 9 (the eight locations marked # plus the step onto galaxy 9 itself). Here are some other example shortest path\u00a0lengths:</blockquote>\n<blockquote>Between galaxy 1 and galaxy 7:\u00a015</blockquote>\n<blockquote>Between galaxy 3 and galaxy 6:\u00a017</blockquote>\n<blockquote>Between galaxy 8 and galaxy 9:\u00a05</blockquote>\n<blockquote>In this example, after expanding the universe, the sum of the shortest path between all 36 pairs of galaxies is\u00a0374.</blockquote>\n<blockquote>Expand the universe, then find the length of the shortest path between every pair of galaxies. What is the sum of these\u00a0lengths?</blockquote>\n<p><em>Finally! A space exploration problem. I am a sucker for\u00a0those!</em></p>\n<p>So, let\u2019s look at the problem, we have an image of space from the observatory and it looks something like\u00a0this:</p>\n<pre>...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....</pre>\n<p>And we need to compute the sum of the lengths of the shortest path between every pair of galaxies!</p>\n<blockquote>\u2757\ufe0fThe catch being, that by the time light reaches to us, the space expands due to ever expanding universe, but only some part, resulting in any <strong>rows or columns</strong> that contain <strong>no galaxies</strong> should all actually be <strong>twice as\u00a0big.</strong>\n</blockquote>\n<p>Let\u2019s visualise this?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lUFvdLG-8zW-7eo4Vvl74w.png\"><figcaption>This seems like a good first\u00a0step</figcaption></figure><p>Once we have the final image! We can just number the galaxies\u00a0like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*hZRn53JjHjOFcBspyvzYLA.png\"></figure><p>And then we can just find the shortest distance from each pair of galaxies!</p>\n<p>Seems pretty straight forward right? Let\u2019s\u00a0code!</p>\n<p>As usual, I will begin with writing our base case as the ultimate validator!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/528/1*wpLfzZ-B7q-gkt46Zka26A.png\"></figure><p>And now let\u2019s start expanding! It\u2019s clear we first need to <strong><em>expand</em></strong> space by finding empty rows and columns and doubling it. So, let\u2019s first just do\u00a0that.</p>\n<p>Here\u2019s a simple function expand_space that just does\u00a0that:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IvD01NKWBgQB3m5LNNoSOQ.png\"></figure><blockquote>\ud83d\udca1 Caught a bug, as if we modify the space_map while iterating through it, the empty_rows elements start to point to an incorrect index. To fix that, we can just introduce something like a mod_count which can help us keep a track of original index in modified space_map.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VoSoXFEiPUwgq5Kqi7hERw.png\"><figcaption>Fixed!</figcaption></figure><p>Now we can find all the galaxies locations in the expanded_space_map with a simple function:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/471/1*LszcXw2pLv5S_15-MqpBCQ.png\"></figure><p>\ud83d\udcad The last step is to now take 1 galaxy and find its shortest distance from all other galaxies and then repeat this process for all galaxies!</p>\n<p>Well, before even touching the code, I can already see a lot of steps to optimise this one! For example: If we have found the shortest distance from Galaxy_1 to Galaxy_2\u00a0, it will be same other way around, so we can save extra compute by just refering to a\u00a0cache.</p>\n<pre>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>............6<br>.............<br>.............<br>.........7...<br>8....9.......</pre>\n<p>So, in case of this example, where we have 9 galaxies can could have 81 combinations, since we can\u2019t repeat a pair, the formula\u00a0becomes:</p>\n<blockquote>Number of combinations= <em>n</em>! / <em>r</em>!(<em>n</em>\u2212<em>r</em>)!\u200b</blockquote>\n<p>Solving for our\u00a0case:</p>\n<blockquote>\n<em>9C</em>2\u200b = 9! / 2!(9\u22122)! \u200b=\u00a036</blockquote>\n<p><strong>36 combinations!</strong></p>\n<p>Let\u2019s write some code? I will be using good\u2019ol <strong>BFS (breadth first search)</strong> to find the shortest path for each pair of galaxies. <em>We may come back and optimise this to a more greedy approach for faster computation!</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fnAe9-H1FYiZRcnQHgc26Q.png\"><figcaption>Classic BFS!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*2_MOrRwleCiWT4-DMKLxNg.png\"><figcaption>Ofcourse, I forgot `list` is unhashable \ud83e\udd26\u200d\u2642\ufe0f</figcaption></figure><p>We can always hash a tupple though!\u00a0;)</p>\n<p>Finally after a lot of iterations:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HOtCjKwT6txXLOfaCZCd9w.png\"><figcaption>36!</figcaption></figure><p>Let\u2019s check our test case\u00a0now?</p>\n<p>Here\u2019s our MVP code till\u00a0now:</p>\n<pre># Day 11: Cosmic Expansion<br><br>from enum import Enum<br><br><br>EMPTY_SPACE = \".\"<br>GALAXY = \"#\"<br>DISTANCE_MAP = {}<br><br>class Direction(Enum):<br>        RIGHT = (0, 1)<br>        LEFT = (0, -1)<br>        DOWN = (1, 0)<br>        UP = (-1, 0)<br><br><br>def expand_space_map(space_map):<br>    empty_rows, empty_cols = [], []<br><br>    for i, row in enumerate(space_map):<br>        if GALAXY not in row:<br>            empty_rows.append(i)<br><br>    for i, col in enumerate(space_map[0]):<br>        if GALAXY not in [row[i] for row in space_map]:<br>            empty_cols.append(i)<br><br>    mod_count = 0<br>    for i in empty_rows:<br>        space_map.insert(i + mod_count, EMPTY_SPACE * len(space_map[i]))<br>        mod_count += 1<br><br>    mod_count = 0<br>    for i in empty_cols:<br>        for j, row in enumerate(space_map):<br>            space_map[j] = row[: i + mod_count] + EMPTY_SPACE + row[i + mod_count :]<br>        mod_count += 1<br><br>    return space_map<br><br><br>def find_shortest_distance(galaxy1, galaxy2, space_map):<br>    print(f\"Finding shortest distance between {galaxy1} and {galaxy2}\")<br>    # check if the distance between the two galaxies is already calculated<br>    distance = DISTANCE_MAP.get(galaxy1, {}).get(galaxy2) or DISTANCE_MAP.get(<br>        galaxy2, {}<br>    ).get(galaxy1)<br>    if distance:<br>        return distance<br><br>    # using BFS to find the shortest path between two galaxies<br>    queue = [galaxy1]  # initialize the queue with the starting galaxy<br>    visited = set()  # set to keep track of visited galaxies<br>    distance = 0  # initialize the distance to 0<br>    while queue:<br>        for _ in range(len(queue)):<br>            current = queue.pop(0)  # get the next galaxy from the queue<br>            if current == galaxy2:  # if we reach the destination galaxy<br>                if galaxy1 not in DISTANCE_MAP:<br>                    DISTANCE_MAP[galaxy1] = {}<br>                DISTANCE_MAP[galaxy1][galaxy2] = distance  # store the distance between the galaxies<br>                return distance<br>            visited.add(current)  # mark the current galaxy as visited<br><br>            for direction in Direction:  # explore all possible directions<br>                i, j = current[0] + direction.value[0], current[1] + direction.value[1]<br>                if (<br>                    0 &lt;= i &lt; len(space_map)<br>                    and 0 &lt;= j &lt; len(space_map[0])<br>                    and (i, j) not in visited<br>                ):<br>                    queue.append((i, j))  # add the neighboring galaxy to the queue<br>        distance += 1  # increment the distance after exploring all galaxies at the current level<br><br>    raise Exception(\"No path found between the two galaxies\")<br><br><br>def find_all_galaxies(space_map):<br>    galaxies = []<br>    for i, row in enumerate(space_map):<br>        for j, col in enumerate(row):<br>            if col == GALAXY:<br>                galaxies.append((i, j))<br>    return galaxies<br><br><br>def analyze_space(space_map):<br>    expanded_space_map = expand_space_map(space_map)<br>    print(f\"Expanded space map is {len(expanded_space_map)} x {len(expanded_space_map[0])}\")<br>    galaxies_locations = find_all_galaxies(expanded_space_map)<br>    print(f\"Number of galaxies: {len(galaxies_locations)}\")<br><br>    for galaxy1 in galaxies_locations:<br>        for galaxy2 in galaxies_locations:<br>            if galaxy1 != galaxy2:<br>                find_shortest_distance(galaxy1, galaxy2, expanded_space_map)<br><br>    sum = 0 <br>    for k,v in DISTANCE_MAP.items():<br>        for k1,v1 in v.items():<br>            sum += v1<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br>    sum =  analyze_space(space_map)<br>    print(f\"\u2757\ufe0f Sum of the lengths of the shortest path between every pair of galaxies: {sum}\")<br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br><br>    sum = analyze_space(space_map.splitlines())<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"\u2705 Passed test_analyze_observation()\")<br><br><br>if __name__ == \"__main__\":<br>    test_analyze_space()<br>    # part_one()</pre>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>\u2705 Passed test_analyze_observation()<br><br>[Done] exited with code=0 in 7.131 seconds</pre>\n<p>Well, it did took 7.131 seconds to compute for a simple testcase, let\u2019s see if it can do it for puzzle\u00a0input?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/991/1*qsb5pCVb9HnxVVOv7uzGzQ.png\"></figure><p>And compute!!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*NTrAEUF4t-HG-9FlN3uA6Q.png\"><figcaption>2 mins in, doesn\u2019t seem\u00a0likely!</figcaption></figure><p>Let\u2019s add some logging to understand the scale of the\u00a0problem?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/896/1*KatgSN7P3HCewqc06-gjLw.gif\"><figcaption>Yeah\u2026.this is not gonna\u00a0compute!</figcaption></figure><p>We have 426 Galaxies in a map of size 151 x 147 which gives us 426C2 combinations, equaling 90525 possible pairs! We need to make it more efficient!</p>\n<blockquote>While, I can take the easy path of just doings the <strong>Bi-directional BFS</strong> where I can look up from both Galaxy 1 and Galaxy 2, I feels it\u2019s better to take a peak into <strong>A* or Dijkstra\u2019s </strong>Algorithm for our shortest path finding to be more efficient!</blockquote>\n<p>I am bit rusty don\u2019t remember A* algo exactly but I do remember that A* is a type of <strong>greedy approch</strong> which does a <strong>smart search</strong> through a maze, where at each step it makes an <strong>informed guess</strong> about the best next step based on <em>how far it has already traveled</em> and <em>how far it still has to go</em>, according to the map. It\u2019s a blend of exploring and using what you know to make good guesses, which makes it efficient and effective for finding\u00a0paths.</p>\n<p>Let\u2019s use Github Copilot to quickly generate a A* method for searching and then refactor it to suit our galaxy and space_map problem:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YrmYmgoRwh7xZY6OUTjUHQ.png\"><figcaption>Looks good!</figcaption></figure><p>Now, let\u2019s run for the base test case with our logging\u00a0enabled?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>Expanded space map is 12 x 13<br>Number of galaxies: 9<br>Finding shortest distance between (0, 4) and (1, 9)<br>Finding shortest distance between (0, 4) and (2, 0)<br>Finding shortest distance between (0, 4) and (5, 8)<br>Finding shortest distance between (0, 4) and (6, 1)<br>Finding shortest distance between (0, 4) and (7, 12)<br>Finding shortest distance between (0, 4) and (10, 9)<br>Finding shortest distance between (0, 4) and (11, 0)<br>Finding shortest distance between (0, 4) and (11, 5)<br>Finding shortest distance between (1, 9) and (0, 4)<br>Finding shortest distance between (1, 9) and (2, 0)<br>Finding shortest distance between (1, 9) and (5, 8)<br>Finding shortest distance between (1, 9) and (6, 1)<br>Finding shortest distance between (1, 9) and (7, 12)<br>Finding shortest distance between (1, 9) and (10, 9)<br>Finding shortest distance between (1, 9) and (11, 0)<br>Finding shortest distance between (1, 9) and (11, 5)<br>Finding shortest distance between (2, 0) and (0, 4)<br>Finding shortest distance between (2, 0) and (1, 9)<br>Finding shortest distance between (2, 0) and (5, 8)<br>Finding shortest distance between (2, 0) and (6, 1)<br>Finding shortest distance between (2, 0) and (7, 12)<br>Finding shortest distance between (2, 0) and (10, 9)<br>Finding shortest distance between (2, 0) and (11, 0)<br>Finding shortest distance between (2, 0) and (11, 5)<br>Finding shortest distance between (5, 8) and (0, 4)<br>Finding shortest distance between (5, 8) and (1, 9)<br>Finding shortest distance between (5, 8) and (2, 0)<br>Finding shortest distance between (5, 8) and (6, 1)<br>Finding shortest distance between (5, 8) and (7, 12)<br>Finding shortest distance between (5, 8) and (10, 9)<br>Finding shortest distance between (5, 8) and (11, 0)<br>Finding shortest distance between (5, 8) and (11, 5)<br>Finding shortest distance between (6, 1) and (0, 4)<br>Finding shortest distance between (6, 1) and (1, 9)<br>Finding shortest distance between (6, 1) and (2, 0)<br>Finding shortest distance between (6, 1) and (5, 8)<br>Finding shortest distance between (6, 1) and (7, 12)<br>Finding shortest distance between (6, 1) and (10, 9)<br>Finding shortest distance between (6, 1) and (11, 0)<br>Finding shortest distance between (6, 1) and (11, 5)<br>Finding shortest distance between (7, 12) and (0, 4)<br>Finding shortest distance between (7, 12) and (1, 9)<br>Finding shortest distance between (7, 12) and (2, 0)<br>Finding shortest distance between (7, 12) and (5, 8)<br>Finding shortest distance between (7, 12) and (6, 1)<br>Finding shortest distance between (7, 12) and (10, 9)<br>Finding shortest distance between (7, 12) and (11, 0)<br>Finding shortest distance between (7, 12) and (11, 5)<br>Finding shortest distance between (10, 9) and (0, 4)<br>Finding shortest distance between (10, 9) and (1, 9)<br>Finding shortest distance between (10, 9) and (2, 0)<br>Finding shortest distance between (10, 9) and (5, 8)<br>Finding shortest distance between (10, 9) and (6, 1)<br>Finding shortest distance between (10, 9) and (7, 12)<br>Finding shortest distance between (10, 9) and (11, 0)<br>Finding shortest distance between (10, 9) and (11, 5)<br>Finding shortest distance between (11, 0) and (0, 4)<br>Finding shortest distance between (11, 0) and (1, 9)<br>Finding shortest distance between (11, 0) and (2, 0)<br>Finding shortest distance between (11, 0) and (5, 8)<br>Finding shortest distance between (11, 0) and (6, 1)<br>Finding shortest distance between (11, 0) and (7, 12)<br>Finding shortest distance between (11, 0) and (10, 9)<br>Finding shortest distance between (11, 0) and (11, 5)<br>Finding shortest distance between (11, 5) and (0, 4)<br>Finding shortest distance between (11, 5) and (1, 9)<br>Finding shortest distance between (11, 5) and (2, 0)<br>Finding shortest distance between (11, 5) and (5, 8)<br>Finding shortest distance between (11, 5) and (6, 1)<br>Finding shortest distance between (11, 5) and (7, 12)<br>Finding shortest distance between (11, 5) and (10, 9)<br>Finding shortest distance between (11, 5) and (11, 0)<br>\u2705 Passed test_analyze_observation()<br><br>[Done] exited with code=0 in 0.121 seconds</pre>\n<blockquote>Woah! <strong>0.121 seconds</strong> for the base test case. Comparing this to our previous <em>BFS</em> approach that took <strong>7.131 seconds </strong>to churn out the answers, <em>A*</em> approach is almost <strong>~59x faster!\u00a0\ud83d\ude80</strong>\n</blockquote>\n<p>Let\u2019s run for our puzzle input and go make a coffee!\u00a0\u2615\ufe0f</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br><br>\u2757\ufe0f Sum of the lengths of the shortest path between every pair of galaxies: XXXXX<br><br>[Done] exited with code=0 in 982.651 seconds</pre>\n<p>Well, this took only <strong>982.651 seconds ~ 16.377 minutes</strong> to run! And this happened because I just ran it and went to make coffee and when I came back, I was it was somewhere around 148th row. Since, I knew we have a total 151 rows only, I just let it\u00a0run!</p>\n<pre>Finding shortest distance between (148, 104) and (119, 66)<br>Finding shortest distance between (148, 104) and (119, 105)<br>Finding shortest distance between (148, 104) and (119, 116)</pre>\n<p>So, let\u2019s input our answer into the box\u00a0and\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/830/1*Nld_W8c57EDwOGkKVJHi_g.png\"><figcaption>Yay! \ud83d\ude4c</figcaption></figure><p>Here\u2019s our unpythonic code till now, I will optimise it in Part\u00a02:</p>\n<pre># Day 11: Cosmic Expansion<br><br>from enum import Enum<br>import heapq<br><br><br>EMPTY_SPACE = \".\"<br>GALAXY = \"#\"<br>DISTANCE_MAP = {}<br><br><br>class Direction(Enum):<br>    RIGHT = (0, 1)<br>    LEFT = (0, -1)<br>    DOWN = (1, 0)<br>    UP = (-1, 0)<br><br><br>def calculate_distance(a, b):<br>    return abs(a[0] - b[0]) + abs(a[1] - b[1])  # Manhattan distance<br><br><br>def get_adjacent_galaxies(space_map, galaxy):<br>    adjacent_galaxies = []<br>    for direction in Direction:<br>        i, j = galaxy[0] + direction.value[0], galaxy[1] + direction.value[1]<br>        if 0 &lt;= i &lt; len(space_map) and 0 &lt;= j &lt; len(space_map[0]):<br>            adjacent_galaxies.append((i, j))<br>    return adjacent_galaxies<br><br><br>def find_shortest_path(space_map, start_galaxy, end_galaxy):<br>    galaxies_to_visit = []<br>    heapq.heappush(galaxies_to_visit, (0, start_galaxy))<br>    previous_galaxy = {}<br>    cost_to_reach = {start_galaxy: 0}<br>    estimated_total_cost = {start_galaxy: calculate_distance(start_galaxy, end_galaxy)}<br><br>    while galaxies_to_visit:<br>        current_galaxy = heapq.heappop(galaxies_to_visit)[1]<br><br>        if current_galaxy == end_galaxy:<br>            return cost_to_reach[<br>                current_galaxy<br>            ]  # Return the cost to reach the end galaxy<br><br>        for adjacent_galaxy in get_adjacent_galaxies(space_map, current_galaxy):<br>            tentative_cost = cost_to_reach[current_galaxy] + 1  # assuming uniform cost<br>            if (<br>                adjacent_galaxy not in cost_to_reach<br>                or tentative_cost &lt; cost_to_reach[adjacent_galaxy]<br>            ):<br>                previous_galaxy[adjacent_galaxy] = current_galaxy<br>                cost_to_reach[adjacent_galaxy] = tentative_cost<br>                estimated_total_cost[<br>                    adjacent_galaxy<br>                ] = tentative_cost + calculate_distance(adjacent_galaxy, end_galaxy)<br>                heapq.heappush(<br>                    galaxies_to_visit,<br>                    (estimated_total_cost[adjacent_galaxy], adjacent_galaxy),<br>                )<br><br>    raise Exception(\"No path found between the two galaxies\")<br><br><br>def expand_space_map(space_map):<br>    empty_rows, empty_cols = [], []<br><br>    for i, row in enumerate(space_map):<br>        if GALAXY not in row:<br>            empty_rows.append(i)<br><br>    for i, col in enumerate(space_map[0]):<br>        if GALAXY not in [row[i] for row in space_map]:<br>            empty_cols.append(i)<br><br>    mod_count = 0<br>    for i in empty_rows:<br>        space_map.insert(i + mod_count, EMPTY_SPACE * len(space_map[i]))<br>        mod_count += 1<br><br>    mod_count = 0<br>    for i in empty_cols:<br>        for j, row in enumerate(space_map):<br>            space_map[j] = row[: i + mod_count] + EMPTY_SPACE + row[i + mod_count :]<br>        mod_count += 1<br><br>    return space_map<br><br><br>def find_shortest_distance(galaxy1, galaxy2, space_map):<br>    print(f\"Finding shortest distance between {galaxy1} and {galaxy2}\")<br><br>    distance = DISTANCE_MAP.get(galaxy1, {}).get(galaxy2) or DISTANCE_MAP.get(<br>        galaxy2, {}<br>    ).get(galaxy1)<br>    if distance:<br>        return distance<br><br>    distance = find_shortest_path(space_map, galaxy1, galaxy2)  # Use A* for pathfinding<br><br>    if galaxy1 not in DISTANCE_MAP:<br>        DISTANCE_MAP[galaxy1] = {}<br>    DISTANCE_MAP[galaxy1][galaxy2] = distance<br>    return distance<br><br><br>def find_all_galaxies(space_map):<br>    galaxies = []<br>    for i, row in enumerate(space_map):<br>        for j, col in enumerate(row):<br>            if col == GALAXY:<br>                galaxies.append((i, j))<br>    return galaxies<br><br><br>def analyze_space(space_map):<br>    expanded_space_map = expand_space_map(space_map)<br>    print(<br>        f\"Expanded space map is {len(expanded_space_map)} x {len(expanded_space_map[0])}\"<br>    )<br>    galaxies_locations = find_all_galaxies(expanded_space_map)<br>    print(f\"Number of galaxies: {len(galaxies_locations)}\")<br><br>    for galaxy1 in galaxies_locations:<br>        for galaxy2 in galaxies_locations:<br>            if galaxy1 != galaxy2:<br>                find_shortest_distance(galaxy1, galaxy2, expanded_space_map)<br><br>    sum = 0<br>    for k, v in DISTANCE_MAP.items():<br>        for k1, v1 in v.items():<br>            sum += v1<br><br>    return sum<br><br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br>    sum = analyze_space(space_map)<br>    print(<br>        f\"\u2757\ufe0f Sum of the lengths of the shortest path between every pair of galaxies: {sum}\"<br>    )<br><br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br><br>    sum = analyze_space(space_map.splitlines())<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"\u2705 Passed test_analyze_observation()\")<br><br><br>if __name__ == \"__main__\":<br>    # test_analyze_space()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>The galaxies are much older (and thus much farther apart) than the researcher initially estimated.</blockquote>\n<blockquote>Now, instead of the expansion you did before, make each empty row or column one million times larger. That is, each empty row should be replaced with 1000000 empty rows, and each empty column should be replaced with 1000000empty columns.</blockquote>\n<blockquote>(In the example above, if each empty row or column were merely 10 times larger, the sum of the shortest paths between every pair of galaxies would be 1030. If each empty row or column were merely 100 times larger, the sum of the shortest paths between every pair of galaxies would be 8410. However, your universe will need to expand far beyond these\u00a0values.)</blockquote>\n<blockquote>Starting with the same initial image, expand the universe according to these new rules, then find the length of the shortest path between every pair of galaxies. What is the sum of these\u00a0lengths?</blockquote>\n<p>Well, of course, the galaxies are much\u00a0<strong>older!</strong></p>\n<p>So, looks like we need to update how we expand our space map buy a factor of <strong>one million times, </strong>that is<strong>, 1000000x, </strong>for each empty row and\u00a0column!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*pwCxlg2tQmeeKVJebYZhTQ.png\"></figure><blockquote>Yep! Our current code will not scale at all. <strong>Probably</strong> our solar system sun will collapse into itself before our single threaded Python will be able to compute anything!</blockquote>\n<p>So\u2026let\u2019s rethink\u00a0this!</p>\n<p>.</p>\n<p>.</p>\n<blockquote>Well shit! Why do I even need any path finding algo here? Isn\u2019t this just simple matrix manipulation? I think I ended up doing over-engineering here! This is classic trap of being Principal Engineer, making problems look more complex than they actually\u00a0are!</blockquote>\n<h3>Revisting Part\u00a01</h3>\n<p>This problem required solving just <strong>Manhattan distance</strong> between 2 nodes. Here\u2019s an example to get distance between (Galaxy 1, Galaxy 4) and (Galaxy 5, Galaxy\u00a08):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/406/1*FeZ6DaSbYqtfO-B15zLeWg.png\"></figure><p>The formula to get this is absurdly simple as\u00a0well:</p>\n<blockquote>Manhattan Distance = |x1\u200a\u2014\u200ay1| + |x2\u200a\u2014\u200ay2|</blockquote>\n<p>Which makes my code as simple\u00a0as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/837/1*Ro92d-LT-I3LQGcqxirC3A.png\"></figure><p>Solving for part 1, testing with base test case and puzzle\u00a0input:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>Expanded space map is 12 x 13<br>Number of galaxies: 9<br>Number of possible pairs of galaxies: 36<br>\u2705 Passed test_analyze_observation()<br>Expanded space map is 151 x 147<br>Number of galaxies: 426<br>Number of possible pairs of galaxies: 90525<br>\u2757\ufe0f Sum of the lengths of the shortest path between every pair of galaxies: xxxxxx<br><br>[Done] exited with code=0 in 0.199 seconds</pre>\n<p>Yep, correct answer!\u00a0\ud83e\udd72</p>\n<h4>Back to Part\u00a02</h4>\n<p>Now, all that is changing is, the <strong>expansion distance</strong> between pairs of galaxies.</p>\n<p>\ud83d\udcad If we can somehow just find the number of rows + cols to be modified compared to initial galaxy, we can just do the computation on original space_map and then just increase the distance by a factor of\u00a01000000</p>\n<blockquote>\ud83d\udca1 We can further simplify our code by not having to do the expansion at all as per part\u00a01</blockquote>\n<p>We can introduce a new param\u200a\u2014\u200aexpansion_factor which we can pass as 2 for the part one, and 1000000 for part two to keep our code\u00a0modular.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*w3rB_I5L5KXzI1CY-AY8ow.png\"></figure><p>Let\u2019s update our base test\u00a0case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/817/1*FgsL03tvwa3UA2ExhCPylg.png\"></figure><p>And let\u2019s run\u00a0this:</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>\u2705 Passed test_analyze_observation() for expansion_factor=2<br>\u2705 Passed test_analyze_observation() for expansion_factor=10<br>\u2705 Passed test_analyze_observation() for expansion_factor=100</pre>\n<p>Phew! We can now just load up our puzzle input and call for our 10\u2076 expansion_factor\u00a0:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qbE8EN2SEYiGUYEuTEw2bA.png\"></figure><p>Let\u2019s run this\u00a0up!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>\u2705 Passed test_analyze_observation() for expansion_factor=2<br>\u2705 Passed test_analyze_observation() for expansion_factor=10<br>\u2705 Passed test_analyze_observation() for expansion_factor=100<br>\u2757\ufe0f Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=2: xxxx<br>\u203c\ufe0f Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=1000000: xxxxxxxxxx<br><br>[Done] exited with code=0 in 0.843 seconds</pre>\n<p>We get the answer in <strong>0.843 seconds\u2026.for BOTH the parts + 3 test cases</strong>!\u00a0\ud83d\ude39</p>\n<p>This is why I absolutely love\u00a0coding!</p>\n<p>Let\u2019s put this answer in the input box and\u2026.profit!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/821/1*Me6mzkKI4sceFKZRH8rVWg.png\"><figcaption>\ud83c\udf0c\ud83c\udf0c\ud83c\udf0c</figcaption></figure><p>Here\u2019s our final pythonic yet highly performant code:</p>\n<pre># Day 11: Cosmic Expansion<br><br>class CosmicGrid:<br>    def __init__(self, space_grid):<br>        # Initialize the cosmic grid with the provided space grid<br>        self.space_grid = space_grid<br>        self.grid_height = len(space_grid)<br>        self.grid_width = len(space_grid[0])<br>        # Find rows and columns that are entirely empty<br>        self.empty_rows = self._find_empty_rows()<br>        self.empty_columns = self._find_empty_columns()<br>        # Locate all galaxies within the grid<br>        self.galaxy_positions = self._find_galaxy_positions()<br><br>    def _find_empty_rows(self):<br>        # Identify rows that contain only empty space<br>        empty_rows = set()<br>        for row in range(self.grid_height):<br>            if all(cell == '.' for cell in self.space_grid[row]):<br>                empty_rows.add(row)<br>        return empty_rows<br><br>    def _find_empty_columns(self):<br>        # Identify columns that contain only empty space<br>        empty_columns = set()<br>        for col in range(self.grid_width):<br>            if all(self.space_grid[row][col] == '.' for row in range(self.grid_height)):<br>                empty_columns.add(col)<br>        return empty_columns<br><br>    def _find_galaxy_positions(self):<br>        # Record the positions of all galaxies in the grid<br>        galaxy_positions = []<br>        for row in range(self.grid_height):<br>            for col in range(self.grid_width):<br>                if self.space_grid[row][col] == '#':<br>                    galaxy_positions.append((row, col))<br>        return galaxy_positions<br><br>    def find_shortest_distance(self, galaxy1, galaxy2, expansion_factor):<br>        # Calculate the shortest distance between two galaxies, factoring in cosmic expansion<br>        row_distance = 0<br>        for r in range(min(galaxy1[0], galaxy2[0]), max(galaxy1[0], galaxy2[0]) + 1):<br>            if r in self.empty_rows:<br>                row_distance += 1<br><br>        col_distance = 0<br>        for c in range(min(galaxy1[1], galaxy2[1]), max(galaxy1[1], galaxy2[1]) + 1):<br>            if c in self.empty_columns:<br>                col_distance += 1<br><br>        # Expanded distance is calculated by multiplying empty distances by the expansion factor<br>        # Direct distance is the straight line distance, not through empty space<br>        expanded_row_distance = row_distance * expansion_factor<br>        expanded_col_distance = col_distance * expansion_factor<br>        direct_distance = abs(galaxy1[0] - galaxy2[0]) + abs(galaxy1[1] - galaxy2[1])<br><br>        return expanded_row_distance + expanded_col_distance + direct_distance - row_distance - col_distance<br><br>    def sum_of_shortest_paths(self, expansion_factor):<br>        # Sum the shortest paths between all pairs of galaxies<br>        total_distance = 0<br>        for i, galaxy1 in enumerate(self.galaxy_positions):<br>            for galaxy2 in self.galaxy_positions[i + 1:]:<br>                total_distance += self.find_shortest_distance(galaxy1, galaxy2, expansion_factor)<br>        return total_distance<br><br><br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br><br>    cosmic_grid = CosmicGrid(space_map)<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=2)<br>    print(<br>        f\"\u2757\ufe0f Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=2: {sum}\"<br>    )<br><br><br>def part_two():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br><br>    cosmic_grid = CosmicGrid(space_map)<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=1000000)<br>    print(<br>        f\"\u203c\ufe0f Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=1000000: {sum}\"<br>    )<br><br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br>    cosmic_grid = CosmicGrid(space_map.splitlines())<br>    # part one<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=2)<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"\u2705 Passed test_analyze_observation() for expansion_factor=2\")<br><br>    # part two<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=10)<br>    assert sum == 1030, f\"Expected 1030, got {sum}\"<br>    print(\"\u2705 Passed test_analyze_observation() for expansion_factor=10\")<br><br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=100)<br>    assert sum == 8410, f\"Expected 8410, got {sum}\"<br>    print(\"\u2705 Passed test_analyze_observation() for expansion_factor=100\")<br><br><br>if __name__ == \"__main__\":<br>    test_analyze_space()<br>    part_one()<br>    part_two()</pre>\n<p><strong>\u2618\ufe0f Moral of the story? </strong>As a Principal Engineer, I\u2019m wired to navigate complex problems, often defaulting to intricate solutions like BFS, DFS, Dijkstra, and\u00a0A*.</p>\n<p>Here, I overcomplicated a straightforward task that simply needed the Manhattan distance formula. This experience was a humbling reminder that sometimes, <strong>simplicity is key</strong>. It\u2019s easy to overlook the obvious when your mind is tuned to complexity. It\u2019s crucial to step back and reassess, as the simplest path often leads to the most elegant solution.</p>\n<blockquote><strong><em>This was a lesson in the beauty of simplicity in problem-solving.</em></strong></blockquote>\n<p>p.s: I am deliberating not adding answers here so you can actually spend some time trying to understand how we solved the\u00a0problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine\u00a0\ud83d\udc47</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! \ud83c\udf84</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6e545dad06bb\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["christmas","python","advent-of-code-2023","advent-of-code"]}]}