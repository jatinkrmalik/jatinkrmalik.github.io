{
  "status": "ok",
  "feed": {
    "url": "https://medium.com/feed/@jatinkrmalik",
    "title": "Stories by Jatin K Malik on Medium",
    "link": "https://medium.com/@jatinkrmalik?source=rss-ec576e4b06b0------2",
    "author": "",
    "description": "Stories by Jatin K Malik on Medium",
    "image": "https://cdn-images-1.medium.com/fit/c/150/150/2*9w8uaQp8uqA5wtRu-DltrQ.png"
  },
  "items": [
    {
      "title": "[Day 20] Pulse Propagation // Advent of Code 2023 (Python)",
      "pubDate": "2023-12-29 12:31:13",
      "link": "https://medium.com/@jatinkrmalik/day-20-pulse-propagation-advent-of-code-2023-python-844ad63b515a?source=rss-ec576e4b06b0------2",
      "guid": "https://medium.com/p/844ad63b515a",
      "author": "Jatin K Malik",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*pXNUwjPLdDqRpZmE\"><figcaption>Pulse Propagation (via DALL-E 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/20\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>With your help, the Elves manage to find the right parts and fix all of the machines. Now, they just need to send the command to boot up the machines and get the sand flowing again.</blockquote>\n<blockquote>The machines are far apart and wired together with long cables. The cables don’t connect to the machines directly, but rather to communication modules attached to the machines that perform various initialization tasks and also act as communication relays.</blockquote>\n<blockquote>Modules communicate using pulses. Each pulse is either a high pulse or a low pulse. When a module sends a pulse, it sends that type of pulse to each module in its list of destination modules.</blockquote>\n<blockquote>There are several different types of modules:</blockquote>\n<blockquote>Flip-flop modules (prefix %) are either on or off; they are initially off. If a flip-flop module receives a high pulse, it is ignored and nothing happens. However, if a flip-flop module receives a low pulse, it flips between on and off. If it was off, it turns on and sends a high pulse. If it was on, it turns off and sends a low pulse.</blockquote>\n<blockquote>Conjunction modules (prefix &amp;) remember the type of the most recent pulse received from each of their connected input modules; they initially default to remembering a low pulse for each input. When a pulse is received, the conjunction module first updates its memory for that input. Then, if it remembers high pulses for all inputs, it sends a low pulse; otherwise, it sends a high pulse.</blockquote>\n<blockquote>There is a single broadcast module (named broadcaster). When it receives a pulse, it sends the same pulse to all of its destination modules.</blockquote>\n<blockquote>Here at Desert Machine Headquarters, there is a module with a single button on it called, aptly, the button module. When you push the button, a single low pulse is sent directly to the broadcaster module.</blockquote>\n<blockquote>After pushing the button, you must wait until all pulses have been delivered and fully handled before pushing it again. Never push the button if modules are still processing pulses.</blockquote>\n<blockquote>Pulses are always processed in the order they are sent. So, if a pulse is sent to modules a, b, and c, and then module a processes its pulse and sends more pulses, the pulses sent to modules b and c would have to be handled first.</blockquote>\n<blockquote>The module configuration (your puzzle input) lists each module. The name of the module is preceded by a symbol identifying its type, if any. The name is then followed by an arrow and a list of its destination modules. For example:</blockquote>\n<blockquote>broadcaster -&gt; a, b, c<br>%a -&gt; b<br>%b -&gt; c<br>%c -&gt; inv<br>&amp;inv -&gt; a</blockquote>\n<blockquote>In this module configuration, the broadcaster has three destination modules named a, b, and c. Each of these modules is a flip-flop module (as indicated by the % prefix). a outputs to b which outputs to c which outputs to another module named inv. inv is a conjunction module (as indicated by the &amp; prefix) which, because it has only one input, acts like an inverter(it sends the opposite of the pulse type it receives); it outputs to a.</blockquote>\n<blockquote>By pushing the button once, the following pulses are sent:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>broadcaster -low-&gt; b<br>broadcaster -low-&gt; c<br>a -high-&gt; b<br>b -high-&gt; c<br>c -high-&gt; inv<br>inv -low-&gt; a<br>a -low-&gt; b<br>b -low-&gt; c<br>c -low-&gt; inv<br>inv -high-&gt; a</blockquote>\n<blockquote>After this sequence, the flip-flop modules all end up off, so pushing the button again repeats the same sequence.</blockquote>\n<blockquote>Here’s a more interesting example:</blockquote>\n<blockquote>broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output</blockquote>\n<blockquote>This module configuration includes the broadcaster, two flip-flops (named aand b), a single-input conjunction module (inv), a multi-input conjunction module (con), and an untyped module named output (for testing purposes). The multi-input conjunction module con watches the two flip-flop modules and, if they're both on, sends a low pulse to the output module.</blockquote>\n<blockquote>Here’s what happens if you push the button once:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -high-&gt; output<br>b -high-&gt; con<br>con -low-&gt; output</blockquote>\n<blockquote>Both flip-flops turn on and a low pulse is sent to output! However, now that both flip-flops are on and con remembers a high pulse from each of its two inputs, pushing the button a second time does something different:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt; output</blockquote>\n<blockquote>Flip-flop a turns off! Now, con remembers a low pulse from module a, and so it sends only a high pulse to output.</blockquote>\n<blockquote>Push the button a third time:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -low-&gt; output<br>b -low-&gt; con<br>con -high-&gt; output</blockquote>\n<blockquote>This time, flip-flop a turns on, then flip-flop b turns off. However, before b can turn off, the pulse sent to con is handled first, so it briefly remembers all high pulses for its inputs and sends a low pulse to output. After that, flip-flop b turns off, which causes con to update its state and send a high pulse to output.</blockquote>\n<blockquote>Finally, with a on and b off, push the button a fourth time:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt; output</blockquote>\n<blockquote>This completes the cycle: a turns off, causing con to remember only low pulses and restoring all modules to their original states.</blockquote>\n<blockquote>To get the cables warmed up, the Elves have pushed the button 1000 times. How many pulses got sent as a result (including the pulses sent by the button itself)?</blockquote>\n<blockquote>In the first example, the same thing happens every time the button is pushed: 8 low pulses and 4 high pulses are sent. So, after pushing the button 1000 times, 8000 low pulses and 4000 high pulses are sent. Multiplying these together gives 32000000.</blockquote>\n<blockquote>In the second example, after pushing the button 1000 times, 4250 low pulses and 2750 high pulses are sent. Multiplying these together gives 11687500.</blockquote>\n<blockquote>Consult your module configuration; determine the number of low pulses and high pulses that would be sent after pushing the button 1000 times, waiting for all pulses to be fully handled after each push of the button. What do you get if you multiply the total number of low pulses sent by the total number of high pulses sent?</blockquote>\n<p>So, let’s begin with a simple visualization of a case with just 2 machines connected:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Y70DVIH19S3lfweAYNLiAw.png\"></figure><p>CM aka Communication modules are attached to machines that perform various initialization tasks and also act as communication relays.</p>\n<p><strong>Types:</strong></p>\n<ul>\n<li>\n<strong>Flip-flop</strong> (%) — ON | <em>OFF (Default)<br></em> * High Pulse: Ignore<br> * Low Pulse: Flips state<br> — if Off: flips to ON + returns High Pulse<br> — if ON: flips to OFF + returns Low Pulse</li>\n<li>\n<strong>Conjunction</strong> (&amp;) — <em>Low pulse (Default)<br></em> * Remembers the most recent pulse for each input module<br> * for input pulse: updates memory, return High or Low</li>\n<li>\n<strong>Broadcast</strong> (broadcaster)<br> * input pulse -&gt; sends the same pulse to all destination modules</li>\n</ul>\n<blockquote>Now, at Desert Machine Headquarters, there is a module with a single button on it called, <strong>aptly</strong>, the button module. <strong>When you push the button</strong>, a single <strong>low pulse</strong> is sent directly to the broadcaster module.</blockquote>\n<p>Once we push aptly we must wait until all pulses have been processed for all modules in our network.</p>\n<blockquote>Pulses are <strong>always processed in the order</strong> they are sent.</blockquote>\n<blockquote>So, if a pulse is sent to modules a, b, and c, and then module a processes its pulse and sends more pulses, the pulses sent to modules b and c would have to be handled first.</blockquote>\n<p>So, we can see that the system in a way is “<strong><em>queueing</em></strong>” the requests!</p>\n<p>Now, we are given a <strong><em>module configuration</em></strong> (input)<strong><em> </em></strong>which is something like this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/661/1*1ONY5Hc4KshvHMd3nfVXmg.png\"></figure><blockquote>where, the <strong>broadcaster</strong> has <strong>three destination modules</strong> named a, b, and c. Each of these modules is a <strong>flip-flop module</strong> (as indicated by the % prefix).</blockquote>\n<blockquote>- a outputs to b which outputs to c which outputs to another module named inv.</blockquote>\n<blockquote>- inv is a <strong>conjunction</strong> module (as indicated by the &amp; prefix) which, because it has only one input, acts like an <strong>inverter</strong>(it sends the opposite of the pulse type it receives); it outputs to a.</blockquote>\n<p>By pushing the aptly button once, the following pulses are sent:</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>broadcaster -low-&gt; b<br>broadcaster -low-&gt; c<br>a -high-&gt; b<br>b -high-&gt; c<br>c -high-&gt; inv<br>inv -low-&gt; a<br>a -low-&gt; b<br>b -low-&gt; c<br>c -low-&gt; inv<br>inv -high-&gt; a</pre>\n<p>Let’s understand this with a visualization:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*_6D9nF-fllU8iipiJcCUGQ.png\"><figcaption>Starting from 1 → 12</figcaption></figure><p>After this sequence, the flip-flop modules all end up <strong>OFF</strong>, so pushing the button again <strong>repeats the same sequence</strong>.</p>\n<p>We are given another example:</p>\n<pre>broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output</pre>\n<p>Here’s what happens if you push the button <strong>once</strong>:</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -high-&gt; output<br>b -high-&gt; con<br>con -low-&gt; output</pre>\n<blockquote>Both flip-flops turn on and a low pulse is sent to output! However, now that both flip-flops are on and con remembers a high pulse from each of its two inputs</blockquote>\n<p>Pushing the button <strong>second</strong> time?</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt; output</pre>\n<blockquote>Flip-flop a turns off! Now, con remembers a low pulse from module a, and so it sends only a high pulse to output.</blockquote>\n<p>And <strong>third</strong> time?</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -low-&gt; output<br>b -low-&gt; con<br>con -high-&gt; output</pre>\n<blockquote>This time, flip-flop a turns on, then flip-flop b turns off. However, before b can turn off, the pulse sent to con is handled first, so it briefly remembers all high pulses for its inputs and sends a low pulse to output. After that, flip-flop b turns off, which causes con to update its state and send a high pulse to output.</blockquote>\n<p>Finally, with a on and b off, push the button a <strong>fourth</strong> time:</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt; output</pre>\n<blockquote>This completes the cycle: a turns off, causing con to remember only low pulses and restoring all modules to their original states.</blockquote>\n<p>Now, the problem states that:</p>\n<blockquote>To get the cables warmed up, the Elves have pushed the button <strong>1000</strong> times. <strong>How many pulses got sent as a result (including the pulses sent by the button itself)?</strong>\n</blockquote>\n<p>— — —</p>\n<p>Phew! This one is going to be intense! I can feel it. We need to simulate the circuit and remember the states. Seems like OOP might be the perfect way to solve this one! ;)</p>\n<p>Let’s first write our base case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/990/1*HlVJcsTXqVz26jf_ZTL1Tw.png\"><figcaption>Skelton code, a good point to start!</figcaption></figure><p>As mentioned, I am heavily leaning towards an object-oriented approach here as it will allow us to simulate the behavior of the different types of modules and their interactions when the button is pressed!</p>\n<p>The key components on top of my mind are:</p>\n<ol>\n<li>\n<strong>Module Classes</strong>: Representing different types of modules (Flip-flop, Conjunction, Broadcaster and Untyped</li>\n<li>\n<strong>Pulse Management</strong>: Handling the sending and processing of pulses.</li>\n<li>\n<strong>Simulation Logic</strong>: To simulate the process of pushing the button and propagating the pulses.</li>\n</ol>\n<p>Let’s start by defining the classes and their methods:</p>\n<p><strong>Module Classes</strong></p>\n<ul>\n<li>BaseModule: An abstract class for common module functionality.</li>\n<li>FlipFlopModule: Represents a flip-flop module.</li>\n<li>ConjunctionModule: Represents a conjunction module.</li>\n<li>BroadcasterModule: Represents the broadcaster module.</li>\n<li>Untyped: Represents the untyped module.</li>\n</ul>\n<p>Also, to keep track of Pulse Type and Module State, we can just define enum classes to make the code cleaner?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/255/1*I1c-BOKWFnoccuWn6NbX3w.png\"></figure><p>Let’s see our base class for Module ?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/886/1*ofTrW1MllkJJg9fGL2VyYg.png\"><figcaption>We are leaving receive_pulse to be implemented by it’s derived classes</figcaption></figure><p>Now let’s implement:</p>\n<h4><strong>FlipFlopModule</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/880/1*Cn5YlWI4wpCzvgEkW0INrg.png\"></figure><p>The FlipFlopModule class initialises the object with State.OFF. We implement the receive_pulse method that changes the state of the module based on the received pulse.</p>\n<ul>\n<li>If the received pulse is LOW, the state of the module is toggled.</li>\n<li>If the current state is OFF, it is changed to ON, and vice versa.</li>\n</ul>\n<p>After changing the state, the module sends a pulse.</p>\n<ul><li>If the new state is ON, it sends a HIGH pulse, otherwise it sends a LOW pulse.</li></ul>\n<h4><strong>ConjunctionModule</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/912/1*VfOa_n3I5GJbnitIfEuiPw.png\"></figure><p>The ConjunctionModule class has a __init__ method that sets the name of the module and initializes a list of input states. The number of input states is determined by the inputs parameter, which is a list of input module names. Initially, all input states are set to LOW.</p>\n<p>The receive_pulse method is used to receive a pulse at a specific input. The pulse can be either HIGH or LOW, and the corresponding input state is updated accordingly. After updating the input state, the method checks if all input states are HIGH. If they are, it sends a LOW pulse; otherwise, it sends a HIGH pulse. This behavior is the opposite of a typical AND gate, which would output HIGH when all inputs are HIGH.</p>\n<h4>BroadcasterModule</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/391/1*3EtOqzJ_62qm0hIiS8KtLQ.png\"></figure><p>This represents a broadcaster module, which is a type of digital circuit that broadcasts the same pulse to all of its destination modules.</p>\n<p>The BroadcasterModule class has a receive_pulse method that immediately sends the received pulse to all destination modules. The pulse can be either HIGH or LOW. This behavior is implemented by calling the send_pulse method with the received pulse as the argument.</p>\n<h4>UntypedModule</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/520/1*RVfi_3TB_awl3Kb7j1cmCg.png\"></figure><p>It represents a module that can receive pulses but does not have a specific type.</p>\n<p>The receive_pulse method is used to receive a pulse and the name of the input module. The pulse can be either HIGH or LOW. The method appends the received pulse to the list of received pulses and then do nothing!</p>\n<h4>ModuleFactory</h4>\n<blockquote>💭 I think this is a cookie-cutter case for <a href=\"https://refactoring.guru/design-patterns/factory-method\">Factory Pattern</a> as we can create module instances based on their types as indicated by their names or prefixes.</blockquote>\n<p>We can define a<strong>ModuleFactory</strong> class responsible for creating module instances based on the input string.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/780/1*UGX9EiIMNauksqNmN5npMA.png\"></figure><p>This is pretty much self explanatory!</p>\n<h3>Simulation</h3>\n<p>Once all our pieces are set up! We are good to go to implement our simulation class that will orchestrate a pulse run for each button press and track everything we need!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/784/1*2IqQGmpd_CmjD7yWctpobw.png\"></figure><p>Now to orchestrate all of this, one of the most important parts is to parse the config_lines and set up our modules correctly with the type, state and destination so when they receive a Pulse, they can send it forward correctly!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VMVnpRAsA7fWBIccMghhng.png\"><figcaption>Here, we are setting up both modules and their respective connections in the destinations.</figcaption></figure><p>Let’s now run our first base test case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/804/1*1zKsJ-qF1GJEwNP9-phpIg.png\"></figure><p>And it failed! Let’s debug?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*hIXwdJ3DA1z9hz4mrFqyNw.png\"></figure><p>And after some debugging and back and forth, we can see it is counting <strong>LOW_PULSE_COUNT</strong> and <strong>HIGH_PULSE_COUNT</strong> correctly for the first run, now we just need to let it run <strong>1000</strong> times and return the product of both counts!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>✅ test_count_pulses_in_the_circuit() passed<br><br>[Done] exited with code=0 in 0.237 seconds</pre>\n<p>Perfect! Now, let’s test our code for thesecond example in the problem? This way we will be able to ensure we are covering all the edge cases!</p>\n<pre>broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/799/1*UOljqE7Ol8Pi9zI7TrJzdQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>✅ test_count_pulses_in_the_circuit() passed<br>Traceback (most recent call last):<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\", line 195, in &lt;module&gt;<br>    test_count_pulses_in_the_circuit_b()<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\", line 185, in test_count_pulses_in_the_circuit_b<br>    modules = setup_modules(input_str.splitlines())<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\", line 158, in setup_modules<br>    modules[source_name].add_destination(modules[dest_name])<br>KeyError: 'output'<br><br>[Done] exited with code=1 in 0.244 seconds</pre>\n<p>Whoops! We got stuck in an error as we are not initiating Modules for destinations, which is leading to an error for Output which should be an UntypedModule.</p>\n<p>We can update our setup_modules() code to handle that once we create all modules for the source part of the config:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/879/1*VXdtM5pVeItvdWbDGgdY-g.png\"></figure><p>Let’s run the test case again? And voila!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>✅ test_count_pulses_in_the_circuit_b() passed<br><br>[Done] exited with code=0 in 0.231 seconds</pre>\n<p>I feel pretty good about this code as it has a good runtime and has quite a clean code making it easy to debug.</p>\n<p>Let’s load up our puzzle input and see if we get an answer?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*q3AM8ioIDVERo9qxGvIlkw.png\"></figure><p>And…executing the code…</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>❗️ Product of total number of low pulses sent by the total number of high pulses sent: XXXXXXXXX<br><br>[Done] exited with code=0 in 0.248 seconds</pre>\n<p>We get an answer! Let’s input this in our answer box?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Vwpxsur1qGWQ8e3b8g6ErQ.png\"><figcaption>⭐️</figcaption></figure><p>Boom! Let me paste our well-structured object-oriented code till now:</p>\n<pre># Day 20 - Pulse Propagation<br><br>from enum import Enum<br>from collections import deque<br><br># Constants<br><br># dict to hold the count of inputs for each module<br>INPUT_TRACKER = {}<br># global queue to hold pulses<br>PULSE_QUEUE = deque()<br># to hold the count of low and high pulses<br>LOW_PULSE_COUNT, HIGH_PULSE_COUNT = 0, 0<br><br># Enums<br><br>class State(Enum):<br>    ON = 1<br>    OFF = 0<br><br><br>class Pulse(Enum):<br>    HIGH = 1<br>    LOW = 0<br><br><br>class ModuleType(Enum):<br>    FLIP_FLOP = \"%\"<br>    CONJUNCTION = \"&amp;\"<br>    BROADCASTER = \"broadcaster\"<br><br># Classes<br><br>class Module:<br>    def __init__(self, name):<br>        self.name = name<br>        self.destinations = []<br><br>    def add_destination(self, module):<br>        self.destinations.append(module)<br><br>    def send_pulse(self, pulse):<br>        for dest_module in self.destinations:<br>            PULSE_QUEUE.append((pulse, dest_module.name, self.name))<br>            update_pulse_count(pulse)<br><br>    def receive_pulse(self, pulse, input_name):<br>        raise NotImplementedError(\"Subclass must implement receive_pulse method\")<br><br><br>class FlipFlopModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.state = State.OFF<br><br>    def receive_pulse(self, pulse, src_module):<br>        if pulse == Pulse.LOW:<br>            self.state = State.ON if self.state == State.OFF else State.OFF<br>            self.send_pulse(Pulse.HIGH if self.state == State.ON else Pulse.LOW)<br><br><br>class ConjunctionModule(Module):<br>    def __init__(self, name, inputs):<br>        super().__init__(name)<br>        self.inputs = inputs  # List of input module names<br>        self.input_states = {input_name: Pulse.LOW for input_name in inputs}<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.input_states[src_module] = pulse<br><br>        if all(state == Pulse.HIGH for state in self.input_states.values()):<br>            self.send_pulse(Pulse.LOW)<br>        else:<br>            self.send_pulse(Pulse.HIGH)<br><br><br>class BroadcasterModule(Module):<br>    def receive_pulse(self, pulse, src_module):<br>        self.send_pulse(pulse)<br><br><br>class UntypedModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.received_pulses = []<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.received_pulses.append(pulse)<br><br><br>class ModuleFactory:<br>    @staticmethod<br>    def create_module(module_identifier):<br>        if module_identifier.startswith(ModuleType.FLIP_FLOP.value):<br>            return FlipFlopModule(module_identifier[1:])<br>        elif module_identifier.startswith(ModuleType.CONJUNCTION.value):<br>            # Determine the number of inputs for the conjunction module<br>            name = module_identifier[1:]<br>            module_inputs = INPUT_TRACKER[name]<br>            return ConjunctionModule(name, module_inputs)<br>        elif module_identifier == ModuleType.BROADCASTER.value:<br>            return BroadcasterModule(module_identifier)<br>        else:<br>            return UntypedModule(module_identifier)<br><br><br>class Simulation:<br>    def __init__(self, modules):<br>        self.modules = modules<br><br>    def run_simulation(self, button_presses):<br>        for _ in range(button_presses):<br>            # Simulate button press - send a low pulse to broadcaster<br>            update_pulse_count(Pulse.LOW)<br>            self.modules[\"broadcaster\"].receive_pulse(Pulse.LOW, \"button\")<br><br>            # Process pulses in the queue<br>            while PULSE_QUEUE:<br>                pulse, dest_module, src_module = PULSE_QUEUE.popleft()<br>                self.modules[dest_module].receive_pulse(pulse, src_module)<br><br># Util functions<br><br>def update_pulse_count(pulse):<br>    global LOW_PULSE_COUNT, HIGH_PULSE_COUNT<br>    if pulse == Pulse.LOW:<br>        LOW_PULSE_COUNT += 1<br>    elif pulse == Pulse.HIGH:<br>        HIGH_PULSE_COUNT += 1<br><br><br>def process_input_count(config_lines):<br>    global INPUT_TRACKER<br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source = parts[0].strip()<br>        if len(parts) &gt; 1:<br>            destinations = [dest.strip() for dest in parts[1].split(\",\")]<br><br>            for dest in destinations:<br>                # Remove any prefix from the destination name<br>                dest = dest.lstrip(\"%&amp;\")<br>                source = source.lstrip(\"%&amp;\")<br>                if dest not in INPUT_TRACKER:<br>                    INPUT_TRACKER[dest] = set()<br>                INPUT_TRACKER[dest].add(source)<br><br><br>def setup_modules(config_lines):<br>    modules = {}<br>    connections = {}<br><br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source_name = parts[0].strip()<br>        dest_names = parts[1].split(\",\") if len(parts) &gt; 1 else []<br>        clean_source_name = source_name.lstrip(\"%&amp; \")<br><br>        if clean_source_name not in modules:<br>            modules[clean_source_name] = ModuleFactory.create_module(source_name)<br><br>        for dest_name in dest_names:<br>            if clean_source_name not in connections:<br>                connections[clean_source_name] = []<br>            connections[clean_source_name].append(dest_name)<br><br>    # Set up connections<br>    for source_name, dest_names in connections.items():<br>        for dest_name in dest_names:<br>            dest_name = dest_name.strip()<br>            if dest_name not in modules:<br>                # Create module if it doesn't exist for destination<br>                modules[dest_name] = ModuleFactory.create_module(dest_name)<br>            modules[source_name].add_destination(modules[dest_name])<br><br>    return modules<br><br># Tests<br><br>def test_count_pulses_in_the_circuit_a():<br>    input_str = \"\"\"broadcaster -&gt; a, b, c<br>%a -&gt; b<br>%b -&gt; c<br>%c -&gt; inv<br>&amp;inv -&gt; a\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 32000000, f\"Expected 32000000, got {num_pulses}\"<br>    print(\"✅ test_count_pulses_in_the_circuit_a() passed\")<br><br><br>def test_count_pulses_in_the_circuit_b():<br>    input_str = \"\"\"broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 11687500, f\"Expected 11687500, got {num_pulses}\"<br>    print(\"✅ test_count_pulses_in_the_circuit_b() passed\")<br><br># Main<br><br>def part_one():<br>    with open(\"day_20/input.txt\") as f:<br>        config_lines = f.readlines()<br>    process_input_count(config_lines)<br>    modules = setup_modules(config_lines)<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    print(<br>        f\"❗️ Product of total number of low pulses sent by the \\<br>total number of high pulses sent: {num_pulses}\"<br>    )<br><br><br><br>if __name__ == \"__main__\":<br>    # test_count_pulses_in_the_circuit_a()<br>    # test_count_pulses_in_the_circuit_b()<br>    part_one()</pre>\n<blockquote>❗️The one limitation of our code here is that, we can only run 1 simulation at a time as we are using global variables to keep pulse count and queue. We shall address this in part 2.</blockquote>\n<h3>Part Two</h3>\n<blockquote>The final machine responsible for moving the sand down to Island Island has a module attached named rx. The machine turns on when a single low pulse is sent to rx.</blockquote>\n<blockquote>Reset all modules to their default states. Waiting for all pulses to be fully handled after each button press, what is the fewest number of button presses required to deliver a single low pulse to the module named rx?</blockquote>\n<p>Well, this seems simple?! All we need to do is track the <strong>min_num_of_button_press</strong> to send a <strong>Pulse.LOW</strong> to <strong>rx</strong> module!</p>\n<p>We can define a new function <strong>run_simulation_until_rx</strong>() that will basically keep pressing the button to go through the circuit till we recieve a <strong>Pulse.LOW</strong> headed towards <strong>rx</strong> module:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*cf_sJv7kTPgj_HYq4tuPkA.png\"></figure><p>.</p>\n<p>.</p>\n<p>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e0DWVRgnAIaEdnyiKrwc4g.png\"></figure><p>.</p>\n<p>.</p>\n<p>Well, it may not be as simple as we thought first! ~6 mins later, we are at <strong>521553 button presses</strong> with no sight of <strong>Pulse.LOW</strong> to <strong>rx</strong>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*9vzN6PdVdi0UQD-J2r6tIg.png\"></figure><p>I knew it was too good to be this simple! First things first, let’s add a __repr__ method to our base Module class so we don’t have to deal with this in our debugger:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/689/1*5WYArCFYmp5oTXaeRr1-Sg.png\"></figure><p>Let’s make it human readable without having to click through each object to see it’s properties:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/831/1*lAsyzzp01PExQ5Br2sx4tw.png\"><figcaption>Much better!</figcaption></figure><p>Now, looking at our puzzle input, the only module that has rx as a destination is &amp;dn (<em>ConjunctionModule</em>).</p>\n<pre>&amp;dn -&gt; rx</pre>\n<p>Let’s add that to our watch list to see how it changes the input_states as it can’t send a Pulse.LOW to rx until all its input_states are set to Pulse.HIGH!</p>\n<p>We can see that &amp;dn has 4 callers -&gt; xp, fh, dd, fc and they all are initiated as Pulse.LOW :</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/965/1*PyvjzT0ylkr0_stFW2zIDQ.png\"><figcaption>`dn` state as of initialization!</figcaption></figure><p>After 1 cycle complete (i.e. button_presses == 1), here’s how&amp;dn looks like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/953/1*Sy-valqJbyw2o9VD_P4stQ.png\"><figcaption>We got 4 pulses to `rx` but all of them were HIGH.</figcaption></figure><p>We basically need to find a case where all 4 of xp, fh, dd, fc become Pulse.HIGH . I am inclined to think that all 4 of these states may have some cycles and we might need to find a common point where these cycles will co-incide?</p>\n<p>Let’s create a breakpoint to see if we ever get a Pulse.HIGH for either of these 4?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*dIRug3xC7pgkv4sLPy2kKA.png\"><figcaption>conditional breakpoint</figcaption></figure><p>So, at <strong>3917</strong> we found our first call to fc with Pulse.HIGH :</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/935/1*7GaNuBsjjfTcCchRib16Fw.png\"></figure><p>which will then modify our dn <strong><em>input_states</em></strong> to:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/941/1*gFecxOnyS1VMSgyeOqoGaw.png\"></figure><p>And similarly, on <strong>3919</strong> button press, we get Pulse.HIGH for xp</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/941/1*OCZiRwypqnfCOMLWcWQ_lA.png\"></figure><p>changing our dn input_states to:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/969/1*xDDWxfqkikoYpVEzIGHmJQ.png\"></figure><p>Then for <strong>4003</strong> time, we get one for dd</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/949/1*0zttMxeT1CgVMs4Y38WqHw.png\"></figure><p>making our dn input_states:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/947/1*cJI65wFsXn3b3NxRLstwIw.png\"></figure><p>Lastly, we get Pulse.HIGH for fh at <strong>4027</strong> button press:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/897/1*lMbzrDmOwMUwe2pL0KhQhw.png\"></figure><p>making our dn to be:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/977/1*oe5AHnPrFKqAEvCTMFPgXg.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/930/1*cKbg0KwNmUnUexBhC5-VTQ.png\"></figure><blockquote>❗️Now! Moving on! We can see that the next event comes at <strong>7834th time </strong>for fc and if you scroll up, the last event came at <strong>3917 </strong>i.e: <strong>7834/2</strong>\n</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/930/1*cKbg0KwNmUnUexBhC5-VTQ.png\"></figure><p>This helps us establish that each of these input modules has its own cycle! And now this helps us deduce this down an <a href=\"https://en.wikipedia.org/wiki/Least_common_multiple\">LCM (Lowest common multiple)</a> problem, where all we need to find is what will be the first time in our button press cycle when all 4 xp, fh, dd, fc will receive Pulse.HIGH that will emit a Pulse.LOW to rx !</p>\n<p>This is now a simple mathematical problem!</p>\n<p>We can find the LCM for 3917, 3919, 4003 and 4027 i.e:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/156/0*-P0cFbDuOcFe89ES\"></figure><p>We can whip up a quick python script to find that:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/489/1*bL5iyR6GjNY6YnnIIfTwkQ.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>XXXXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.218 seconds</pre>\n<p>Let’s put this in our answer box and….yes! Our hunch was absolutely correct.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YBMYkpHVMeQoSp9dzh-dWQ.png\"><figcaption>YESSS!!</figcaption></figure><p>Well, since it is not physically possible for us to keep running our code for 200 Trillions+ (answer in some ballpark) times, we need to just update our code to find the first occurence for each xp, fh, dd, fc and then just find the LCM and exit:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*foKEVUYnle6qfKqKKICyEQ.png\"><figcaption>Some debugging steps later</figcaption></figure><p>Here’s our updated run_simulation_until_rx() that will iterate till:</p>\n<pre>all(idx &gt; 0 for idx in rx_callers_high_pulse_idx.values())</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wbwgKvxtCDalX9lonbfBmQ.png\"></figure><p>Let’s run it and see if we are getting the correct answer as we calculated mathematically before?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>❗️❗️ Number of button presses required to activate the Rx: XXXXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.412 seconds</pre>\n<p>Yep! XXXXXXXXXXXXXXX == XXXXXXXXXXXXXXX 🤓</p>\n<p>Here’s our full code for both Part 1 and 2:</p>\n<pre># Day 20 - Pulse Propagation<br><br>from enum import Enum<br>from collections import deque<br>from math import gcd<br>from functools import reduce<br><br># Constants<br><br># dict to hold the count of inputs for each module<br>INPUT_TRACKER = {}<br># global queue to hold pulses<br>PULSE_QUEUE = deque()<br># to hold the count of low and high pulses<br>LOW_PULSE_COUNT, HIGH_PULSE_COUNT = 0, 0<br><br># Enums<br><br>class State(Enum):<br>    ON = 1<br>    OFF = 0<br><br><br>class Pulse(Enum):<br>    HIGH = 1<br>    LOW = 0<br><br><br>class ModuleType(Enum):<br>    FLIP_FLOP = \"%\"<br>    CONJUNCTION = \"&amp;\"<br>    BROADCASTER = \"broadcaster\"<br><br># Classes<br><br>class Module:<br>    def __init__(self, name):<br>        self.name = name<br>        self.destinations = []<br><br>    def add_destination(self, module):<br>        self.destinations.append(module)<br><br>    def send_pulse(self, pulse):<br>        for dest_module in self.destinations:<br>            PULSE_QUEUE.append((pulse, dest_module.name, self.name))<br>            update_pulse_count(pulse)<br><br>    def receive_pulse(self, pulse, input_name):<br>        raise NotImplementedError(\"Subclass must implement receive_pulse method\")<br><br><br>class FlipFlopModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.state = State.OFF<br><br>    def __repr__(self) -&gt; str:<br>        return f\"Module({self.name} - {self.state})\"<br><br>    def receive_pulse(self, pulse, src_module):<br>        if pulse == Pulse.LOW:<br>            self.state = State.ON if self.state == State.OFF else State.OFF<br>            self.send_pulse(Pulse.HIGH if self.state == State.ON else Pulse.LOW)<br><br><br>class ConjunctionModule(Module):<br>    def __init__(self, name, inputs):<br>        super().__init__(name)<br>        self.inputs = inputs  # List of input module names<br>        self.input_states = {input_name: Pulse.LOW for input_name in inputs}<br><br>    def __repr__(self) -&gt; str:<br>        return f\"Module({self.name} - {self.input_states})\"<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.input_states[src_module] = pulse<br><br>        if all(state == Pulse.HIGH for state in self.input_states.values()):<br>            self.send_pulse(Pulse.LOW)<br>        else:<br>            self.send_pulse(Pulse.HIGH)<br><br><br>class BroadcasterModule(Module):<br>    def receive_pulse(self, pulse, src_module):<br>        self.send_pulse(pulse)<br><br><br>class UntypedModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.received_pulses = {Pulse.LOW: 0, Pulse.HIGH: 0}<br><br>    def __repr__(self) -&gt; str:<br>        return f\"Module({self.name} - {self.received_pulses})\"<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.received_pulses[pulse] += 1<br><br><br>class ModuleFactory:<br>    @staticmethod<br>    def create_module(module_identifier):<br>        if module_identifier.startswith(ModuleType.FLIP_FLOP.value):<br>            return FlipFlopModule(module_identifier[1:])<br>        elif module_identifier.startswith(ModuleType.CONJUNCTION.value):<br>            # Determine the number of inputs for the conjunction module<br>            name = module_identifier[1:]<br>            module_inputs = INPUT_TRACKER[name]<br>            return ConjunctionModule(name, module_inputs)<br>        elif module_identifier == ModuleType.BROADCASTER.value:<br>            return BroadcasterModule(module_identifier)<br>        else:<br>            return UntypedModule(module_identifier)<br><br><br>class Simulation:<br>    def __init__(self, modules):<br>        self.modules = modules<br><br>    def run_simulation(self, button_presses):<br>        for _ in range(button_presses):<br>            # Simulate button press - send a low pulse to broadcaster<br>            update_pulse_count(Pulse.LOW)<br>            self.modules[\"broadcaster\"].receive_pulse(Pulse.LOW, \"button\")<br><br>            # Process pulses in the queue<br>            while PULSE_QUEUE:<br>                pulse, dest_module, src_module = PULSE_QUEUE.popleft()<br>                self.modules[dest_module].receive_pulse(pulse, src_module)<br><br>    def run_simulation_until_rx(self):<br>        button_presses = 0<br><br>         # rx_source is the only input for rx i.e. &amp;dn<br>        rx_source = list(INPUT_TRACKER['rx'])[0]<br><br>        # dict to hold the index of the rx caller that received a Pulse.HIGH for the first time<br>        rx_callers_high_pulse_idx = {caller: 0 for caller in INPUT_TRACKER[rx_source]}<br><br>        # break when all the rx callers have received a high pulse for the first time<br>        while not all(idx &gt; 0 for idx in rx_callers_high_pulse_idx.values()):<br>            button_presses += 1<br>            self.modules['broadcaster'].receive_pulse(Pulse.LOW, \"button\")<br>            update_pulse_count(Pulse.LOW)<br><br>            while PULSE_QUEUE:<br>                pulse, dest_module, src_module = PULSE_QUEUE.popleft()<br>                self.modules[dest_module].receive_pulse(pulse, src_module)<br><br>                # update the index of the rx caller that received a high pulse for the first time<br>                if src_module in rx_callers_high_pulse_idx.keys() and  pulse == Pulse.HIGH:<br>                    rx_callers_high_pulse_idx[src_module] = button_presses<br><br>        # lcm formula<br>        lcm = lambda x, y: x * y // gcd(x, y)<br><br>        # find LCM for all the values in rx_callers_high_pulse_idx<br>        return reduce(lcm, list(rx_callers_high_pulse_idx.values()))<br><br><br># Util functions<br><br>def update_pulse_count(pulse):<br>    global LOW_PULSE_COUNT, HIGH_PULSE_COUNT<br>    if pulse == Pulse.LOW:<br>        LOW_PULSE_COUNT += 1<br>    elif pulse == Pulse.HIGH:<br>        HIGH_PULSE_COUNT += 1<br><br><br>def process_input_count(config_lines):<br>    global INPUT_TRACKER<br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source = parts[0].strip()<br>        if len(parts) &gt; 1:<br>            destinations = [dest.strip() for dest in parts[1].split(\",\")]<br><br>            for dest in destinations:<br>                # Remove any prefix from the destination name<br>                dest = dest.lstrip(\"%&amp;\")<br>                source = source.lstrip(\"%&amp;\")<br>                if dest not in INPUT_TRACKER:<br>                    INPUT_TRACKER[dest] = set()<br>                INPUT_TRACKER[dest].add(source)<br><br><br>def setup_modules(config_lines):<br>    modules = {}<br>    connections = {}<br><br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source_name = parts[0].strip()<br>        dest_names = parts[1].split(\",\") if len(parts) &gt; 1 else []<br>        clean_source_name = source_name.lstrip(\"%&amp; \")<br><br>        if clean_source_name not in modules:<br>            modules[clean_source_name] = ModuleFactory.create_module(source_name)<br><br>        for dest_name in dest_names:<br>            if clean_source_name not in connections:<br>                connections[clean_source_name] = []<br>            connections[clean_source_name].append(dest_name)<br><br>    # Set up connections<br>    for source_name, dest_names in connections.items():<br>        for dest_name in dest_names:<br>            dest_name = dest_name.strip()<br>            if dest_name not in modules:<br>                # Create module if it doesn't exist for destination<br>                modules[dest_name] = ModuleFactory.create_module(dest_name)<br>            modules[source_name].add_destination(modules[dest_name])<br><br>    return modules<br><br># Tests<br><br>def test_count_pulses_in_the_circuit_a():<br>    input_str = \"\"\"broadcaster -&gt; a, b, c<br>%a -&gt; b<br>%b -&gt; c<br>%c -&gt; inv<br>&amp;inv -&gt; a\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 32000000, f\"Expected 32000000, got {num_pulses}\"<br>    print(\"✅ test_count_pulses_in_the_circuit_a() passed\")<br><br><br>def test_count_pulses_in_the_circuit_b():<br>    input_str = \"\"\"broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 11687500, f\"Expected 11687500, got {num_pulses}\"<br>    print(\"✅ test_count_pulses_in_the_circuit_b() passed\")<br><br># Main<br><br>def part_one():<br>    with open(\"day_20/input.txt\") as f:<br>        config_lines = f.readlines()<br>    process_input_count(config_lines)<br>    modules = setup_modules(config_lines)<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    print(<br>        f\"❗️ Product of total number of low pulses sent by the \\<br>total number of high pulses sent: {num_pulses}\"<br>    )<br><br>def part_two():<br>    with open(\"day_20/input.txt\") as f:<br>        config_lines = f.readlines()<br>    process_input_count(config_lines)<br>    modules = setup_modules(config_lines)<br>    simulation = Simulation(modules)<br>    button_presses = simulation.run_simulation_until_rx()<br>    print(f\"❗️❗️ Number of button presses required to activate the Rx: {button_presses}\")<br><br><br>if __name__ == \"__main__\":<br>    # test_count_pulses_in_the_circuit_a()<br>    # test_count_pulses_in_the_circuit_b()<br>    # part_one()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine 👇</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! 🎄</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=844ad63b515a\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*pXNUwjPLdDqRpZmE\"><figcaption>Pulse Propagation (via DALL-E 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/20\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>With your help, the Elves manage to find the right parts and fix all of the machines. Now, they just need to send the command to boot up the machines and get the sand flowing again.</blockquote>\n<blockquote>The machines are far apart and wired together with long cables. The cables don’t connect to the machines directly, but rather to communication modules attached to the machines that perform various initialization tasks and also act as communication relays.</blockquote>\n<blockquote>Modules communicate using pulses. Each pulse is either a high pulse or a low pulse. When a module sends a pulse, it sends that type of pulse to each module in its list of destination modules.</blockquote>\n<blockquote>There are several different types of modules:</blockquote>\n<blockquote>Flip-flop modules (prefix %) are either on or off; they are initially off. If a flip-flop module receives a high pulse, it is ignored and nothing happens. However, if a flip-flop module receives a low pulse, it flips between on and off. If it was off, it turns on and sends a high pulse. If it was on, it turns off and sends a low pulse.</blockquote>\n<blockquote>Conjunction modules (prefix &amp;) remember the type of the most recent pulse received from each of their connected input modules; they initially default to remembering a low pulse for each input. When a pulse is received, the conjunction module first updates its memory for that input. Then, if it remembers high pulses for all inputs, it sends a low pulse; otherwise, it sends a high pulse.</blockquote>\n<blockquote>There is a single broadcast module (named broadcaster). When it receives a pulse, it sends the same pulse to all of its destination modules.</blockquote>\n<blockquote>Here at Desert Machine Headquarters, there is a module with a single button on it called, aptly, the button module. When you push the button, a single low pulse is sent directly to the broadcaster module.</blockquote>\n<blockquote>After pushing the button, you must wait until all pulses have been delivered and fully handled before pushing it again. Never push the button if modules are still processing pulses.</blockquote>\n<blockquote>Pulses are always processed in the order they are sent. So, if a pulse is sent to modules a, b, and c, and then module a processes its pulse and sends more pulses, the pulses sent to modules b and c would have to be handled first.</blockquote>\n<blockquote>The module configuration (your puzzle input) lists each module. The name of the module is preceded by a symbol identifying its type, if any. The name is then followed by an arrow and a list of its destination modules. For example:</blockquote>\n<blockquote>broadcaster -&gt; a, b, c<br>%a -&gt; b<br>%b -&gt; c<br>%c -&gt; inv<br>&amp;inv -&gt; a</blockquote>\n<blockquote>In this module configuration, the broadcaster has three destination modules named a, b, and c. Each of these modules is a flip-flop module (as indicated by the % prefix). a outputs to b which outputs to c which outputs to another module named inv. inv is a conjunction module (as indicated by the &amp; prefix) which, because it has only one input, acts like an inverter(it sends the opposite of the pulse type it receives); it outputs to a.</blockquote>\n<blockquote>By pushing the button once, the following pulses are sent:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>broadcaster -low-&gt; b<br>broadcaster -low-&gt; c<br>a -high-&gt; b<br>b -high-&gt; c<br>c -high-&gt; inv<br>inv -low-&gt; a<br>a -low-&gt; b<br>b -low-&gt; c<br>c -low-&gt; inv<br>inv -high-&gt; a</blockquote>\n<blockquote>After this sequence, the flip-flop modules all end up off, so pushing the button again repeats the same sequence.</blockquote>\n<blockquote>Here’s a more interesting example:</blockquote>\n<blockquote>broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output</blockquote>\n<blockquote>This module configuration includes the broadcaster, two flip-flops (named aand b), a single-input conjunction module (inv), a multi-input conjunction module (con), and an untyped module named output (for testing purposes). The multi-input conjunction module con watches the two flip-flop modules and, if they're both on, sends a low pulse to the output module.</blockquote>\n<blockquote>Here’s what happens if you push the button once:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -high-&gt; output<br>b -high-&gt; con<br>con -low-&gt; output</blockquote>\n<blockquote>Both flip-flops turn on and a low pulse is sent to output! However, now that both flip-flops are on and con remembers a high pulse from each of its two inputs, pushing the button a second time does something different:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt; output</blockquote>\n<blockquote>Flip-flop a turns off! Now, con remembers a low pulse from module a, and so it sends only a high pulse to output.</blockquote>\n<blockquote>Push the button a third time:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -low-&gt; output<br>b -low-&gt; con<br>con -high-&gt; output</blockquote>\n<blockquote>This time, flip-flop a turns on, then flip-flop b turns off. However, before b can turn off, the pulse sent to con is handled first, so it briefly remembers all high pulses for its inputs and sends a low pulse to output. After that, flip-flop b turns off, which causes con to update its state and send a high pulse to output.</blockquote>\n<blockquote>Finally, with a on and b off, push the button a fourth time:</blockquote>\n<blockquote>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt; output</blockquote>\n<blockquote>This completes the cycle: a turns off, causing con to remember only low pulses and restoring all modules to their original states.</blockquote>\n<blockquote>To get the cables warmed up, the Elves have pushed the button 1000 times. How many pulses got sent as a result (including the pulses sent by the button itself)?</blockquote>\n<blockquote>In the first example, the same thing happens every time the button is pushed: 8 low pulses and 4 high pulses are sent. So, after pushing the button 1000 times, 8000 low pulses and 4000 high pulses are sent. Multiplying these together gives 32000000.</blockquote>\n<blockquote>In the second example, after pushing the button 1000 times, 4250 low pulses and 2750 high pulses are sent. Multiplying these together gives 11687500.</blockquote>\n<blockquote>Consult your module configuration; determine the number of low pulses and high pulses that would be sent after pushing the button 1000 times, waiting for all pulses to be fully handled after each push of the button. What do you get if you multiply the total number of low pulses sent by the total number of high pulses sent?</blockquote>\n<p>So, let’s begin with a simple visualization of a case with just 2 machines connected:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Y70DVIH19S3lfweAYNLiAw.png\"></figure><p>CM aka Communication modules are attached to machines that perform various initialization tasks and also act as communication relays.</p>\n<p><strong>Types:</strong></p>\n<ul>\n<li>\n<strong>Flip-flop</strong> (%) — ON | <em>OFF (Default)<br></em> * High Pulse: Ignore<br> * Low Pulse: Flips state<br> — if Off: flips to ON + returns High Pulse<br> — if ON: flips to OFF + returns Low Pulse</li>\n<li>\n<strong>Conjunction</strong> (&amp;) — <em>Low pulse (Default)<br></em> * Remembers the most recent pulse for each input module<br> * for input pulse: updates memory, return High or Low</li>\n<li>\n<strong>Broadcast</strong> (broadcaster)<br> * input pulse -&gt; sends the same pulse to all destination modules</li>\n</ul>\n<blockquote>Now, at Desert Machine Headquarters, there is a module with a single button on it called, <strong>aptly</strong>, the button module. <strong>When you push the button</strong>, a single <strong>low pulse</strong> is sent directly to the broadcaster module.</blockquote>\n<p>Once we push aptly we must wait until all pulses have been processed for all modules in our network.</p>\n<blockquote>Pulses are <strong>always processed in the order</strong> they are sent.</blockquote>\n<blockquote>So, if a pulse is sent to modules a, b, and c, and then module a processes its pulse and sends more pulses, the pulses sent to modules b and c would have to be handled first.</blockquote>\n<p>So, we can see that the system in a way is “<strong><em>queueing</em></strong>” the requests!</p>\n<p>Now, we are given a <strong><em>module configuration</em></strong> (input)<strong><em> </em></strong>which is something like this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/661/1*1ONY5Hc4KshvHMd3nfVXmg.png\"></figure><blockquote>where, the <strong>broadcaster</strong> has <strong>three destination modules</strong> named a, b, and c. Each of these modules is a <strong>flip-flop module</strong> (as indicated by the % prefix).</blockquote>\n<blockquote>- a outputs to b which outputs to c which outputs to another module named inv.</blockquote>\n<blockquote>- inv is a <strong>conjunction</strong> module (as indicated by the &amp; prefix) which, because it has only one input, acts like an <strong>inverter</strong>(it sends the opposite of the pulse type it receives); it outputs to a.</blockquote>\n<p>By pushing the aptly button once, the following pulses are sent:</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>broadcaster -low-&gt; b<br>broadcaster -low-&gt; c<br>a -high-&gt; b<br>b -high-&gt; c<br>c -high-&gt; inv<br>inv -low-&gt; a<br>a -low-&gt; b<br>b -low-&gt; c<br>c -low-&gt; inv<br>inv -high-&gt; a</pre>\n<p>Let’s understand this with a visualization:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*_6D9nF-fllU8iipiJcCUGQ.png\"><figcaption>Starting from 1 → 12</figcaption></figure><p>After this sequence, the flip-flop modules all end up <strong>OFF</strong>, so pushing the button again <strong>repeats the same sequence</strong>.</p>\n<p>We are given another example:</p>\n<pre>broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output</pre>\n<p>Here’s what happens if you push the button <strong>once</strong>:</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -high-&gt; output<br>b -high-&gt; con<br>con -low-&gt; output</pre>\n<blockquote>Both flip-flops turn on and a low pulse is sent to output! However, now that both flip-flops are on and con remembers a high pulse from each of its two inputs</blockquote>\n<p>Pushing the button <strong>second</strong> time?</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt; output</pre>\n<blockquote>Flip-flop a turns off! Now, con remembers a low pulse from module a, and so it sends only a high pulse to output.</blockquote>\n<p>And <strong>third</strong> time?</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -high-&gt; inv<br>a -high-&gt; con<br>inv -low-&gt; b<br>con -low-&gt; output<br>b -low-&gt; con<br>con -high-&gt; output</pre>\n<blockquote>This time, flip-flop a turns on, then flip-flop b turns off. However, before b can turn off, the pulse sent to con is handled first, so it briefly remembers all high pulses for its inputs and sends a low pulse to output. After that, flip-flop b turns off, which causes con to update its state and send a high pulse to output.</blockquote>\n<p>Finally, with a on and b off, push the button a <strong>fourth</strong> time:</p>\n<pre>button -low-&gt; broadcaster<br>broadcaster -low-&gt; a<br>a -low-&gt; inv<br>a -low-&gt; con<br>inv -high-&gt; b<br>con -high-&gt; output</pre>\n<blockquote>This completes the cycle: a turns off, causing con to remember only low pulses and restoring all modules to their original states.</blockquote>\n<p>Now, the problem states that:</p>\n<blockquote>To get the cables warmed up, the Elves have pushed the button <strong>1000</strong> times. <strong>How many pulses got sent as a result (including the pulses sent by the button itself)?</strong>\n</blockquote>\n<p>— — —</p>\n<p>Phew! This one is going to be intense! I can feel it. We need to simulate the circuit and remember the states. Seems like OOP might be the perfect way to solve this one! ;)</p>\n<p>Let’s first write our base case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/990/1*HlVJcsTXqVz26jf_ZTL1Tw.png\"><figcaption>Skelton code, a good point to start!</figcaption></figure><p>As mentioned, I am heavily leaning towards an object-oriented approach here as it will allow us to simulate the behavior of the different types of modules and their interactions when the button is pressed!</p>\n<p>The key components on top of my mind are:</p>\n<ol>\n<li>\n<strong>Module Classes</strong>: Representing different types of modules (Flip-flop, Conjunction, Broadcaster and Untyped</li>\n<li>\n<strong>Pulse Management</strong>: Handling the sending and processing of pulses.</li>\n<li>\n<strong>Simulation Logic</strong>: To simulate the process of pushing the button and propagating the pulses.</li>\n</ol>\n<p>Let’s start by defining the classes and their methods:</p>\n<p><strong>Module Classes</strong></p>\n<ul>\n<li>BaseModule: An abstract class for common module functionality.</li>\n<li>FlipFlopModule: Represents a flip-flop module.</li>\n<li>ConjunctionModule: Represents a conjunction module.</li>\n<li>BroadcasterModule: Represents the broadcaster module.</li>\n<li>Untyped: Represents the untyped module.</li>\n</ul>\n<p>Also, to keep track of Pulse Type and Module State, we can just define enum classes to make the code cleaner?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/255/1*I1c-BOKWFnoccuWn6NbX3w.png\"></figure><p>Let’s see our base class for Module ?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/886/1*ofTrW1MllkJJg9fGL2VyYg.png\"><figcaption>We are leaving receive_pulse to be implemented by it’s derived classes</figcaption></figure><p>Now let’s implement:</p>\n<h4><strong>FlipFlopModule</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/880/1*Cn5YlWI4wpCzvgEkW0INrg.png\"></figure><p>The FlipFlopModule class initialises the object with State.OFF. We implement the receive_pulse method that changes the state of the module based on the received pulse.</p>\n<ul>\n<li>If the received pulse is LOW, the state of the module is toggled.</li>\n<li>If the current state is OFF, it is changed to ON, and vice versa.</li>\n</ul>\n<p>After changing the state, the module sends a pulse.</p>\n<ul><li>If the new state is ON, it sends a HIGH pulse, otherwise it sends a LOW pulse.</li></ul>\n<h4><strong>ConjunctionModule</strong></h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/912/1*VfOa_n3I5GJbnitIfEuiPw.png\"></figure><p>The ConjunctionModule class has a __init__ method that sets the name of the module and initializes a list of input states. The number of input states is determined by the inputs parameter, which is a list of input module names. Initially, all input states are set to LOW.</p>\n<p>The receive_pulse method is used to receive a pulse at a specific input. The pulse can be either HIGH or LOW, and the corresponding input state is updated accordingly. After updating the input state, the method checks if all input states are HIGH. If they are, it sends a LOW pulse; otherwise, it sends a HIGH pulse. This behavior is the opposite of a typical AND gate, which would output HIGH when all inputs are HIGH.</p>\n<h4>BroadcasterModule</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/391/1*3EtOqzJ_62qm0hIiS8KtLQ.png\"></figure><p>This represents a broadcaster module, which is a type of digital circuit that broadcasts the same pulse to all of its destination modules.</p>\n<p>The BroadcasterModule class has a receive_pulse method that immediately sends the received pulse to all destination modules. The pulse can be either HIGH or LOW. This behavior is implemented by calling the send_pulse method with the received pulse as the argument.</p>\n<h4>UntypedModule</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/520/1*RVfi_3TB_awl3Kb7j1cmCg.png\"></figure><p>It represents a module that can receive pulses but does not have a specific type.</p>\n<p>The receive_pulse method is used to receive a pulse and the name of the input module. The pulse can be either HIGH or LOW. The method appends the received pulse to the list of received pulses and then do nothing!</p>\n<h4>ModuleFactory</h4>\n<blockquote>💭 I think this is a cookie-cutter case for <a href=\"https://refactoring.guru/design-patterns/factory-method\">Factory Pattern</a> as we can create module instances based on their types as indicated by their names or prefixes.</blockquote>\n<p>We can define a<strong>ModuleFactory</strong> class responsible for creating module instances based on the input string.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/780/1*UGX9EiIMNauksqNmN5npMA.png\"></figure><p>This is pretty much self explanatory!</p>\n<h3>Simulation</h3>\n<p>Once all our pieces are set up! We are good to go to implement our simulation class that will orchestrate a pulse run for each button press and track everything we need!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/784/1*2IqQGmpd_CmjD7yWctpobw.png\"></figure><p>Now to orchestrate all of this, one of the most important parts is to parse the config_lines and set up our modules correctly with the type, state and destination so when they receive a Pulse, they can send it forward correctly!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VMVnpRAsA7fWBIccMghhng.png\"><figcaption>Here, we are setting up both modules and their respective connections in the destinations.</figcaption></figure><p>Let’s now run our first base test case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/804/1*1zKsJ-qF1GJEwNP9-phpIg.png\"></figure><p>And it failed! Let’s debug?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*hIXwdJ3DA1z9hz4mrFqyNw.png\"></figure><p>And after some debugging and back and forth, we can see it is counting <strong>LOW_PULSE_COUNT</strong> and <strong>HIGH_PULSE_COUNT</strong> correctly for the first run, now we just need to let it run <strong>1000</strong> times and return the product of both counts!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>✅ test_count_pulses_in_the_circuit() passed<br><br>[Done] exited with code=0 in 0.237 seconds</pre>\n<p>Perfect! Now, let’s test our code for thesecond example in the problem? This way we will be able to ensure we are covering all the edge cases!</p>\n<pre>broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/799/1*UOljqE7Ol8Pi9zI7TrJzdQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>✅ test_count_pulses_in_the_circuit() passed<br>Traceback (most recent call last):<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\", line 195, in &lt;module&gt;<br>    test_count_pulses_in_the_circuit_b()<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\", line 185, in test_count_pulses_in_the_circuit_b<br>    modules = setup_modules(input_str.splitlines())<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\", line 158, in setup_modules<br>    modules[source_name].add_destination(modules[dest_name])<br>KeyError: 'output'<br><br>[Done] exited with code=1 in 0.244 seconds</pre>\n<p>Whoops! We got stuck in an error as we are not initiating Modules for destinations, which is leading to an error for Output which should be an UntypedModule.</p>\n<p>We can update our setup_modules() code to handle that once we create all modules for the source part of the config:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/879/1*VXdtM5pVeItvdWbDGgdY-g.png\"></figure><p>Let’s run the test case again? And voila!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>✅ test_count_pulses_in_the_circuit_b() passed<br><br>[Done] exited with code=0 in 0.231 seconds</pre>\n<p>I feel pretty good about this code as it has a good runtime and has quite a clean code making it easy to debug.</p>\n<p>Let’s load up our puzzle input and see if we get an answer?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/1*q3AM8ioIDVERo9qxGvIlkw.png\"></figure><p>And…executing the code…</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>❗️ Product of total number of low pulses sent by the total number of high pulses sent: XXXXXXXXX<br><br>[Done] exited with code=0 in 0.248 seconds</pre>\n<p>We get an answer! Let’s input this in our answer box?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Vwpxsur1qGWQ8e3b8g6ErQ.png\"><figcaption>⭐️</figcaption></figure><p>Boom! Let me paste our well-structured object-oriented code till now:</p>\n<pre># Day 20 - Pulse Propagation<br><br>from enum import Enum<br>from collections import deque<br><br># Constants<br><br># dict to hold the count of inputs for each module<br>INPUT_TRACKER = {}<br># global queue to hold pulses<br>PULSE_QUEUE = deque()<br># to hold the count of low and high pulses<br>LOW_PULSE_COUNT, HIGH_PULSE_COUNT = 0, 0<br><br># Enums<br><br>class State(Enum):<br>    ON = 1<br>    OFF = 0<br><br><br>class Pulse(Enum):<br>    HIGH = 1<br>    LOW = 0<br><br><br>class ModuleType(Enum):<br>    FLIP_FLOP = \"%\"<br>    CONJUNCTION = \"&amp;\"<br>    BROADCASTER = \"broadcaster\"<br><br># Classes<br><br>class Module:<br>    def __init__(self, name):<br>        self.name = name<br>        self.destinations = []<br><br>    def add_destination(self, module):<br>        self.destinations.append(module)<br><br>    def send_pulse(self, pulse):<br>        for dest_module in self.destinations:<br>            PULSE_QUEUE.append((pulse, dest_module.name, self.name))<br>            update_pulse_count(pulse)<br><br>    def receive_pulse(self, pulse, input_name):<br>        raise NotImplementedError(\"Subclass must implement receive_pulse method\")<br><br><br>class FlipFlopModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.state = State.OFF<br><br>    def receive_pulse(self, pulse, src_module):<br>        if pulse == Pulse.LOW:<br>            self.state = State.ON if self.state == State.OFF else State.OFF<br>            self.send_pulse(Pulse.HIGH if self.state == State.ON else Pulse.LOW)<br><br><br>class ConjunctionModule(Module):<br>    def __init__(self, name, inputs):<br>        super().__init__(name)<br>        self.inputs = inputs  # List of input module names<br>        self.input_states = {input_name: Pulse.LOW for input_name in inputs}<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.input_states[src_module] = pulse<br><br>        if all(state == Pulse.HIGH for state in self.input_states.values()):<br>            self.send_pulse(Pulse.LOW)<br>        else:<br>            self.send_pulse(Pulse.HIGH)<br><br><br>class BroadcasterModule(Module):<br>    def receive_pulse(self, pulse, src_module):<br>        self.send_pulse(pulse)<br><br><br>class UntypedModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.received_pulses = []<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.received_pulses.append(pulse)<br><br><br>class ModuleFactory:<br>    @staticmethod<br>    def create_module(module_identifier):<br>        if module_identifier.startswith(ModuleType.FLIP_FLOP.value):<br>            return FlipFlopModule(module_identifier[1:])<br>        elif module_identifier.startswith(ModuleType.CONJUNCTION.value):<br>            # Determine the number of inputs for the conjunction module<br>            name = module_identifier[1:]<br>            module_inputs = INPUT_TRACKER[name]<br>            return ConjunctionModule(name, module_inputs)<br>        elif module_identifier == ModuleType.BROADCASTER.value:<br>            return BroadcasterModule(module_identifier)<br>        else:<br>            return UntypedModule(module_identifier)<br><br><br>class Simulation:<br>    def __init__(self, modules):<br>        self.modules = modules<br><br>    def run_simulation(self, button_presses):<br>        for _ in range(button_presses):<br>            # Simulate button press - send a low pulse to broadcaster<br>            update_pulse_count(Pulse.LOW)<br>            self.modules[\"broadcaster\"].receive_pulse(Pulse.LOW, \"button\")<br><br>            # Process pulses in the queue<br>            while PULSE_QUEUE:<br>                pulse, dest_module, src_module = PULSE_QUEUE.popleft()<br>                self.modules[dest_module].receive_pulse(pulse, src_module)<br><br># Util functions<br><br>def update_pulse_count(pulse):<br>    global LOW_PULSE_COUNT, HIGH_PULSE_COUNT<br>    if pulse == Pulse.LOW:<br>        LOW_PULSE_COUNT += 1<br>    elif pulse == Pulse.HIGH:<br>        HIGH_PULSE_COUNT += 1<br><br><br>def process_input_count(config_lines):<br>    global INPUT_TRACKER<br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source = parts[0].strip()<br>        if len(parts) &gt; 1:<br>            destinations = [dest.strip() for dest in parts[1].split(\",\")]<br><br>            for dest in destinations:<br>                # Remove any prefix from the destination name<br>                dest = dest.lstrip(\"%&amp;\")<br>                source = source.lstrip(\"%&amp;\")<br>                if dest not in INPUT_TRACKER:<br>                    INPUT_TRACKER[dest] = set()<br>                INPUT_TRACKER[dest].add(source)<br><br><br>def setup_modules(config_lines):<br>    modules = {}<br>    connections = {}<br><br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source_name = parts[0].strip()<br>        dest_names = parts[1].split(\",\") if len(parts) &gt; 1 else []<br>        clean_source_name = source_name.lstrip(\"%&amp; \")<br><br>        if clean_source_name not in modules:<br>            modules[clean_source_name] = ModuleFactory.create_module(source_name)<br><br>        for dest_name in dest_names:<br>            if clean_source_name not in connections:<br>                connections[clean_source_name] = []<br>            connections[clean_source_name].append(dest_name)<br><br>    # Set up connections<br>    for source_name, dest_names in connections.items():<br>        for dest_name in dest_names:<br>            dest_name = dest_name.strip()<br>            if dest_name not in modules:<br>                # Create module if it doesn't exist for destination<br>                modules[dest_name] = ModuleFactory.create_module(dest_name)<br>            modules[source_name].add_destination(modules[dest_name])<br><br>    return modules<br><br># Tests<br><br>def test_count_pulses_in_the_circuit_a():<br>    input_str = \"\"\"broadcaster -&gt; a, b, c<br>%a -&gt; b<br>%b -&gt; c<br>%c -&gt; inv<br>&amp;inv -&gt; a\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 32000000, f\"Expected 32000000, got {num_pulses}\"<br>    print(\"✅ test_count_pulses_in_the_circuit_a() passed\")<br><br><br>def test_count_pulses_in_the_circuit_b():<br>    input_str = \"\"\"broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 11687500, f\"Expected 11687500, got {num_pulses}\"<br>    print(\"✅ test_count_pulses_in_the_circuit_b() passed\")<br><br># Main<br><br>def part_one():<br>    with open(\"day_20/input.txt\") as f:<br>        config_lines = f.readlines()<br>    process_input_count(config_lines)<br>    modules = setup_modules(config_lines)<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    print(<br>        f\"❗️ Product of total number of low pulses sent by the \\<br>total number of high pulses sent: {num_pulses}\"<br>    )<br><br><br><br>if __name__ == \"__main__\":<br>    # test_count_pulses_in_the_circuit_a()<br>    # test_count_pulses_in_the_circuit_b()<br>    part_one()</pre>\n<blockquote>❗️The one limitation of our code here is that, we can only run 1 simulation at a time as we are using global variables to keep pulse count and queue. We shall address this in part 2.</blockquote>\n<h3>Part Two</h3>\n<blockquote>The final machine responsible for moving the sand down to Island Island has a module attached named rx. The machine turns on when a single low pulse is sent to rx.</blockquote>\n<blockquote>Reset all modules to their default states. Waiting for all pulses to be fully handled after each button press, what is the fewest number of button presses required to deliver a single low pulse to the module named rx?</blockquote>\n<p>Well, this seems simple?! All we need to do is track the <strong>min_num_of_button_press</strong> to send a <strong>Pulse.LOW</strong> to <strong>rx</strong> module!</p>\n<p>We can define a new function <strong>run_simulation_until_rx</strong>() that will basically keep pressing the button to go through the circuit till we recieve a <strong>Pulse.LOW</strong> headed towards <strong>rx</strong> module:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*cf_sJv7kTPgj_HYq4tuPkA.png\"></figure><p>.</p>\n<p>.</p>\n<p>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e0DWVRgnAIaEdnyiKrwc4g.png\"></figure><p>.</p>\n<p>.</p>\n<p>Well, it may not be as simple as we thought first! ~6 mins later, we are at <strong>521553 button presses</strong> with no sight of <strong>Pulse.LOW</strong> to <strong>rx</strong>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*9vzN6PdVdi0UQD-J2r6tIg.png\"></figure><p>I knew it was too good to be this simple! First things first, let’s add a __repr__ method to our base Module class so we don’t have to deal with this in our debugger:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/689/1*5WYArCFYmp5oTXaeRr1-Sg.png\"></figure><p>Let’s make it human readable without having to click through each object to see it’s properties:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/831/1*lAsyzzp01PExQ5Br2sx4tw.png\"><figcaption>Much better!</figcaption></figure><p>Now, looking at our puzzle input, the only module that has rx as a destination is &amp;dn (<em>ConjunctionModule</em>).</p>\n<pre>&amp;dn -&gt; rx</pre>\n<p>Let’s add that to our watch list to see how it changes the input_states as it can’t send a Pulse.LOW to rx until all its input_states are set to Pulse.HIGH!</p>\n<p>We can see that &amp;dn has 4 callers -&gt; xp, fh, dd, fc and they all are initiated as Pulse.LOW :</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/965/1*PyvjzT0ylkr0_stFW2zIDQ.png\"><figcaption>`dn` state as of initialization!</figcaption></figure><p>After 1 cycle complete (i.e. button_presses == 1), here’s how&amp;dn looks like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/953/1*Sy-valqJbyw2o9VD_P4stQ.png\"><figcaption>We got 4 pulses to `rx` but all of them were HIGH.</figcaption></figure><p>We basically need to find a case where all 4 of xp, fh, dd, fc become Pulse.HIGH . I am inclined to think that all 4 of these states may have some cycles and we might need to find a common point where these cycles will co-incide?</p>\n<p>Let’s create a breakpoint to see if we ever get a Pulse.HIGH for either of these 4?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*dIRug3xC7pgkv4sLPy2kKA.png\"><figcaption>conditional breakpoint</figcaption></figure><p>So, at <strong>3917</strong> we found our first call to fc with Pulse.HIGH :</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/935/1*7GaNuBsjjfTcCchRib16Fw.png\"></figure><p>which will then modify our dn <strong><em>input_states</em></strong> to:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/941/1*gFecxOnyS1VMSgyeOqoGaw.png\"></figure><p>And similarly, on <strong>3919</strong> button press, we get Pulse.HIGH for xp</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/941/1*OCZiRwypqnfCOMLWcWQ_lA.png\"></figure><p>changing our dn input_states to:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/969/1*xDDWxfqkikoYpVEzIGHmJQ.png\"></figure><p>Then for <strong>4003</strong> time, we get one for dd</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/949/1*0zttMxeT1CgVMs4Y38WqHw.png\"></figure><p>making our dn input_states:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/947/1*cJI65wFsXn3b3NxRLstwIw.png\"></figure><p>Lastly, we get Pulse.HIGH for fh at <strong>4027</strong> button press:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/897/1*lMbzrDmOwMUwe2pL0KhQhw.png\"></figure><p>making our dn to be:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/977/1*oe5AHnPrFKqAEvCTMFPgXg.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/930/1*cKbg0KwNmUnUexBhC5-VTQ.png\"></figure><blockquote>❗️Now! Moving on! We can see that the next event comes at <strong>7834th time </strong>for fc and if you scroll up, the last event came at <strong>3917 </strong>i.e: <strong>7834/2</strong>\n</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/930/1*cKbg0KwNmUnUexBhC5-VTQ.png\"></figure><p>This helps us establish that each of these input modules has its own cycle! And now this helps us deduce this down an <a href=\"https://en.wikipedia.org/wiki/Least_common_multiple\">LCM (Lowest common multiple)</a> problem, where all we need to find is what will be the first time in our button press cycle when all 4 xp, fh, dd, fc will receive Pulse.HIGH that will emit a Pulse.LOW to rx !</p>\n<p>This is now a simple mathematical problem!</p>\n<p>We can find the LCM for 3917, 3919, 4003 and 4027 i.e:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/156/0*-P0cFbDuOcFe89ES\"></figure><p>We can whip up a quick python script to find that:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/489/1*bL5iyR6GjNY6YnnIIfTwkQ.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>XXXXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.218 seconds</pre>\n<p>Let’s put this in our answer box and….yes! Our hunch was absolutely correct.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YBMYkpHVMeQoSp9dzh-dWQ.png\"><figcaption>YESSS!!</figcaption></figure><p>Well, since it is not physically possible for us to keep running our code for 200 Trillions+ (answer in some ballpark) times, we need to just update our code to find the first occurence for each xp, fh, dd, fc and then just find the LCM and exit:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*foKEVUYnle6qfKqKKICyEQ.png\"><figcaption>Some debugging steps later</figcaption></figure><p>Here’s our updated run_simulation_until_rx() that will iterate till:</p>\n<pre>all(idx &gt; 0 for idx in rx_callers_high_pulse_idx.values())</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wbwgKvxtCDalX9lonbfBmQ.png\"></figure><p>Let’s run it and see if we are getting the correct answer as we calculated mathematically before?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_20/pulse_propagation.py\"<br>❗️❗️ Number of button presses required to activate the Rx: XXXXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.412 seconds</pre>\n<p>Yep! XXXXXXXXXXXXXXX == XXXXXXXXXXXXXXX 🤓</p>\n<p>Here’s our full code for both Part 1 and 2:</p>\n<pre># Day 20 - Pulse Propagation<br><br>from enum import Enum<br>from collections import deque<br>from math import gcd<br>from functools import reduce<br><br># Constants<br><br># dict to hold the count of inputs for each module<br>INPUT_TRACKER = {}<br># global queue to hold pulses<br>PULSE_QUEUE = deque()<br># to hold the count of low and high pulses<br>LOW_PULSE_COUNT, HIGH_PULSE_COUNT = 0, 0<br><br># Enums<br><br>class State(Enum):<br>    ON = 1<br>    OFF = 0<br><br><br>class Pulse(Enum):<br>    HIGH = 1<br>    LOW = 0<br><br><br>class ModuleType(Enum):<br>    FLIP_FLOP = \"%\"<br>    CONJUNCTION = \"&amp;\"<br>    BROADCASTER = \"broadcaster\"<br><br># Classes<br><br>class Module:<br>    def __init__(self, name):<br>        self.name = name<br>        self.destinations = []<br><br>    def add_destination(self, module):<br>        self.destinations.append(module)<br><br>    def send_pulse(self, pulse):<br>        for dest_module in self.destinations:<br>            PULSE_QUEUE.append((pulse, dest_module.name, self.name))<br>            update_pulse_count(pulse)<br><br>    def receive_pulse(self, pulse, input_name):<br>        raise NotImplementedError(\"Subclass must implement receive_pulse method\")<br><br><br>class FlipFlopModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.state = State.OFF<br><br>    def __repr__(self) -&gt; str:<br>        return f\"Module({self.name} - {self.state})\"<br><br>    def receive_pulse(self, pulse, src_module):<br>        if pulse == Pulse.LOW:<br>            self.state = State.ON if self.state == State.OFF else State.OFF<br>            self.send_pulse(Pulse.HIGH if self.state == State.ON else Pulse.LOW)<br><br><br>class ConjunctionModule(Module):<br>    def __init__(self, name, inputs):<br>        super().__init__(name)<br>        self.inputs = inputs  # List of input module names<br>        self.input_states = {input_name: Pulse.LOW for input_name in inputs}<br><br>    def __repr__(self) -&gt; str:<br>        return f\"Module({self.name} - {self.input_states})\"<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.input_states[src_module] = pulse<br><br>        if all(state == Pulse.HIGH for state in self.input_states.values()):<br>            self.send_pulse(Pulse.LOW)<br>        else:<br>            self.send_pulse(Pulse.HIGH)<br><br><br>class BroadcasterModule(Module):<br>    def receive_pulse(self, pulse, src_module):<br>        self.send_pulse(pulse)<br><br><br>class UntypedModule(Module):<br>    def __init__(self, name):<br>        super().__init__(name)<br>        self.received_pulses = {Pulse.LOW: 0, Pulse.HIGH: 0}<br><br>    def __repr__(self) -&gt; str:<br>        return f\"Module({self.name} - {self.received_pulses})\"<br><br>    def receive_pulse(self, pulse, src_module):<br>        self.received_pulses[pulse] += 1<br><br><br>class ModuleFactory:<br>    @staticmethod<br>    def create_module(module_identifier):<br>        if module_identifier.startswith(ModuleType.FLIP_FLOP.value):<br>            return FlipFlopModule(module_identifier[1:])<br>        elif module_identifier.startswith(ModuleType.CONJUNCTION.value):<br>            # Determine the number of inputs for the conjunction module<br>            name = module_identifier[1:]<br>            module_inputs = INPUT_TRACKER[name]<br>            return ConjunctionModule(name, module_inputs)<br>        elif module_identifier == ModuleType.BROADCASTER.value:<br>            return BroadcasterModule(module_identifier)<br>        else:<br>            return UntypedModule(module_identifier)<br><br><br>class Simulation:<br>    def __init__(self, modules):<br>        self.modules = modules<br><br>    def run_simulation(self, button_presses):<br>        for _ in range(button_presses):<br>            # Simulate button press - send a low pulse to broadcaster<br>            update_pulse_count(Pulse.LOW)<br>            self.modules[\"broadcaster\"].receive_pulse(Pulse.LOW, \"button\")<br><br>            # Process pulses in the queue<br>            while PULSE_QUEUE:<br>                pulse, dest_module, src_module = PULSE_QUEUE.popleft()<br>                self.modules[dest_module].receive_pulse(pulse, src_module)<br><br>    def run_simulation_until_rx(self):<br>        button_presses = 0<br><br>         # rx_source is the only input for rx i.e. &amp;dn<br>        rx_source = list(INPUT_TRACKER['rx'])[0]<br><br>        # dict to hold the index of the rx caller that received a Pulse.HIGH for the first time<br>        rx_callers_high_pulse_idx = {caller: 0 for caller in INPUT_TRACKER[rx_source]}<br><br>        # break when all the rx callers have received a high pulse for the first time<br>        while not all(idx &gt; 0 for idx in rx_callers_high_pulse_idx.values()):<br>            button_presses += 1<br>            self.modules['broadcaster'].receive_pulse(Pulse.LOW, \"button\")<br>            update_pulse_count(Pulse.LOW)<br><br>            while PULSE_QUEUE:<br>                pulse, dest_module, src_module = PULSE_QUEUE.popleft()<br>                self.modules[dest_module].receive_pulse(pulse, src_module)<br><br>                # update the index of the rx caller that received a high pulse for the first time<br>                if src_module in rx_callers_high_pulse_idx.keys() and  pulse == Pulse.HIGH:<br>                    rx_callers_high_pulse_idx[src_module] = button_presses<br><br>        # lcm formula<br>        lcm = lambda x, y: x * y // gcd(x, y)<br><br>        # find LCM for all the values in rx_callers_high_pulse_idx<br>        return reduce(lcm, list(rx_callers_high_pulse_idx.values()))<br><br><br># Util functions<br><br>def update_pulse_count(pulse):<br>    global LOW_PULSE_COUNT, HIGH_PULSE_COUNT<br>    if pulse == Pulse.LOW:<br>        LOW_PULSE_COUNT += 1<br>    elif pulse == Pulse.HIGH:<br>        HIGH_PULSE_COUNT += 1<br><br><br>def process_input_count(config_lines):<br>    global INPUT_TRACKER<br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source = parts[0].strip()<br>        if len(parts) &gt; 1:<br>            destinations = [dest.strip() for dest in parts[1].split(\",\")]<br><br>            for dest in destinations:<br>                # Remove any prefix from the destination name<br>                dest = dest.lstrip(\"%&amp;\")<br>                source = source.lstrip(\"%&amp;\")<br>                if dest not in INPUT_TRACKER:<br>                    INPUT_TRACKER[dest] = set()<br>                INPUT_TRACKER[dest].add(source)<br><br><br>def setup_modules(config_lines):<br>    modules = {}<br>    connections = {}<br><br>    for line in config_lines:<br>        parts = line.split(\"-&gt;\")<br>        source_name = parts[0].strip()<br>        dest_names = parts[1].split(\",\") if len(parts) &gt; 1 else []<br>        clean_source_name = source_name.lstrip(\"%&amp; \")<br><br>        if clean_source_name not in modules:<br>            modules[clean_source_name] = ModuleFactory.create_module(source_name)<br><br>        for dest_name in dest_names:<br>            if clean_source_name not in connections:<br>                connections[clean_source_name] = []<br>            connections[clean_source_name].append(dest_name)<br><br>    # Set up connections<br>    for source_name, dest_names in connections.items():<br>        for dest_name in dest_names:<br>            dest_name = dest_name.strip()<br>            if dest_name not in modules:<br>                # Create module if it doesn't exist for destination<br>                modules[dest_name] = ModuleFactory.create_module(dest_name)<br>            modules[source_name].add_destination(modules[dest_name])<br><br>    return modules<br><br># Tests<br><br>def test_count_pulses_in_the_circuit_a():<br>    input_str = \"\"\"broadcaster -&gt; a, b, c<br>%a -&gt; b<br>%b -&gt; c<br>%c -&gt; inv<br>&amp;inv -&gt; a\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 32000000, f\"Expected 32000000, got {num_pulses}\"<br>    print(\"✅ test_count_pulses_in_the_circuit_a() passed\")<br><br><br>def test_count_pulses_in_the_circuit_b():<br>    input_str = \"\"\"broadcaster -&gt; a<br>%a -&gt; inv, con<br>&amp;inv -&gt; b<br>%b -&gt; con<br>&amp;con -&gt; output\"\"\"<br>    process_input_count(input_str.splitlines())<br>    modules = setup_modules(input_str.splitlines())<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    assert num_pulses == 11687500, f\"Expected 11687500, got {num_pulses}\"<br>    print(\"✅ test_count_pulses_in_the_circuit_b() passed\")<br><br># Main<br><br>def part_one():<br>    with open(\"day_20/input.txt\") as f:<br>        config_lines = f.readlines()<br>    process_input_count(config_lines)<br>    modules = setup_modules(config_lines)<br>    simulation = Simulation(modules)<br>    button_presses = 1000<br>    simulation.run_simulation(button_presses)<br>    num_pulses = LOW_PULSE_COUNT * HIGH_PULSE_COUNT<br>    print(<br>        f\"❗️ Product of total number of low pulses sent by the \\<br>total number of high pulses sent: {num_pulses}\"<br>    )<br><br>def part_two():<br>    with open(\"day_20/input.txt\") as f:<br>        config_lines = f.readlines()<br>    process_input_count(config_lines)<br>    modules = setup_modules(config_lines)<br>    simulation = Simulation(modules)<br>    button_presses = simulation.run_simulation_until_rx()<br>    print(f\"❗️❗️ Number of button presses required to activate the Rx: {button_presses}\")<br><br><br>if __name__ == \"__main__\":<br>    # test_count_pulses_in_the_circuit_a()<br>    # test_count_pulses_in_the_circuit_b()<br>    # part_one()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine 👇</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! 🎄</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=844ad63b515a\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "coding",
        "advent-of-code",
        "programming",
        "advent-of-code-2023",
        "python"
      ]
    },
    {
      "title": "[Day 19] Aplenty // Advent of Code 2023 (Python)",
      "pubDate": "2023-12-27 20:33:00",
      "link": "https://medium.com/@jatinkrmalik/day-19-aplenty-advent-of-code-2023-python-522ba14b1444?source=rss-ec576e4b06b0------2",
      "guid": "https://medium.com/p/522ba14b1444",
      "author": "Jatin K Malik",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*jciy1cL5lsSK0f7R\"><figcaption>Aplenty (via DALL-E 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/19\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>The Elves of Gear Island are thankful for your help and send you on your way. They even have a hang glider that someone <a href=\"https://adventofcode.com/2023/day/9\">stole</a> from Desert Island; since you’re already going that direction, it would help them a lot if you would use it to get down there and return it to them.</blockquote>\n<blockquote>As you reach the bottom of the relentless avalanche of machine parts, you discover that they’re already forming a formidable heap. Don’t worry, though — a group of Elves is already here organizing the parts, and they have a system.</blockquote>\n<blockquote>To start, each part is rated in each of four categories:</blockquote>\n<blockquote>x: Extremely cool looking</blockquote>\n<blockquote>m: Musical (it makes a noise when you hit it)</blockquote>\n<blockquote>a: Aerodynamic</blockquote>\n<blockquote>s: Shiny</blockquote>\n<blockquote>Then, each part is sent through a series of workflows that will ultimately accept or reject the part. Each workflow has a name and contains a list of rules; each rule specifies a condition and where to send the part if the condition is true. The first rule that matches the part being considered is applied immediately, and the part moves on to the destination described by the rule. (The last rule in each workflow has no condition and always applies if reached.)</blockquote>\n<blockquote>Consider the workflow ex{x&gt;10:one,m&lt;20:two,a&gt;30:R,A}. This workflow is named ex and contains four rules. If workflow ex were considering a specific part, it would perform the following steps in order:</blockquote>\n<blockquote>Rule “x&gt;10:one\": If the part's x is more than 10, send the part to the workflow named one.</blockquote>\n<blockquote>Rule “m&lt;20:two\": Otherwise, if the part's m is less than 20, send the part to the workflow named two.</blockquote>\n<blockquote>Rule “a&gt;30:R\": Otherwise, if the part's a is more than 30, the part is immediately rejected (R).</blockquote>\n<blockquote>Rule “A\": Otherwise, because no other rules matched the part, the part is immediately accepted (A).</blockquote>\n<blockquote>If a part is sent to another workflow, it immediately switches to the start of that workflow instead and never returns. If a part is accepted (sent to A) or rejected (sent to R), the part immediately stops any further processing.</blockquote>\n<blockquote>The system works, but it’s not keeping up with the torrent of weird metal shapes. The Elves ask if you can help sort a few parts and give you the list of workflows and some part ratings (your puzzle input). For example:</blockquote>\n<blockquote>px{a&lt;2006:qkq,m&gt;2090:A,rfg}<br>pv{a&gt;1716:R,A}<br>lnx{m&gt;1548:A,A}<br>rfg{s&lt;537:gd,x&gt;2440:R,A}<br>qs{s&gt;3448:A,lnx}<br>qkq{x&lt;1416:A,crn}<br>crn{x&gt;2662:A,R}<br>in{s&lt;1351:px,qqz}<br>qqz{s&gt;2770:qs,m&lt;1801:hdj,R}<br>gd{a&gt;3333:R,R}<br>hdj{m&gt;838:A,pv}</blockquote>\n<blockquote>{x=787,m=2655,a=1222,s=2876}<br>{x=1679,m=44,a=2067,s=496}<br>{x=2036,m=264,a=79,s=2244}<br>{x=2461,m=1339,a=466,s=291}<br>{x=2127,m=1623,a=2188,s=1013}</blockquote>\n<blockquote>The workflows are listed first, followed by a blank line, then the ratings of the parts the Elves would like you to sort. All parts begin in the workflow named in. In this example, the five listed parts go through the following workflows:</blockquote>\n<blockquote>{x=787,m=2655,a=1222,s=2876}: in -&gt; qqz -&gt; qs -&gt; lnx -&gt; A</blockquote>\n<blockquote>{x=1679,m=44,a=2067,s=496}: in -&gt; px -&gt; rfg -&gt; gd -&gt; R</blockquote>\n<blockquote>{x=2036,m=264,a=79,s=2244}: in -&gt; qqz -&gt; hdj -&gt; pv -&gt; A</blockquote>\n<blockquote>{x=2461,m=1339,a=466,s=291}: in -&gt; px -&gt; qkq -&gt; crn -&gt; R</blockquote>\n<blockquote>{x=2127,m=1623,a=2188,s=1013}: in -&gt; px -&gt; rfg -&gt; A</blockquote>\n<blockquote>Ultimately, three parts are accepted. Adding up the x, m, a, and s rating for each of the accepted parts gives 7540 for the part with x=787, 4623 for the part with x=2036, and 6951 for the part with x=2127. Adding all of the ratings for all of the accepted parts gives the sum total of 19114.</blockquote>\n<blockquote>Sort through all of the parts you’ve been given; what do you get if you add together all of the rating numbers for all of the parts that ultimately get accepted?</blockquote>\n<blockquote>They even have a hang glider that someone <a href=\"https://adventofcode.com/2023/day/9\">stole</a> from Desert Island.</blockquote>\n<p>Ah, well! 👀</p>\n<p>So, seems like now we have a <em>relentless avalanche of machine parts</em> that has formed a giant heap. But some elves are trying to organize them based of a system that rates each part in following 4 categories:</p>\n<ul>\n<li>x: Extremely cool looking</li>\n<li>m: Musical (it makes a noise when you hit it)</li>\n<li>a: Aerodynamic</li>\n<li>s: Shiny</li>\n</ul>\n<blockquote>Not very scientific, is it?!</blockquote>\n<blockquote>Then, each part is sent through a series of workflows that will ultimately accept or reject the part. Each workflow has a name and contains a list of rules; each rule specifies a condition and where to send the part if the condition is true. The first rule that matches the part being considered is applied immediately, and the part moves on to the destination described by the rule. (The last rule in each workflow has no condition and always applies if reached.)</blockquote>\n<p>So, seems like each workflow has a series of qualification checks and as soon as a condition is met, we send the part to subsequent workflow.</p>\n<p>We are given an example workflow: ex{x&gt;10:one,m&lt;20:two,a&gt;30:R,A} which is named ex and has 4 rules:</p>\n<ul>\n<li>Rule “x&gt;10:one\": If the part's x is more than 10, send the part to the workflow named one.</li>\n<li>Rule “m&lt;20:two\": Otherwise, if the part's m is less than 20, send the part to the workflow named two.</li>\n<li>Rule “a&gt;30:R\": Otherwise, if the part's a is more than 30, the part is immediately rejected (R).</li>\n<li>Rule “A\": Otherwise, because no other rules matched the part, the part is immediately accepted (A).</li>\n</ul>\n<blockquote>If a part is sent to another workflow, it immediately switches to the start of that workflow instead and never returns. If a part is accepted (sent to A) or rejected (sent to R), the part immediately stops any further processing.</blockquote>\n<p>Got it! So, we can clearly see that each <strong>part</strong> seems to be an <strong>object</strong> with 4 properties and then we have a <strong>rule engine </strong>which is navigating through a series of <strong>workflows</strong> to finally reach either: <strong>A Accepted </strong>or<strong> </strong><strong>R Rejected.</strong></p>\n<p>We then go on to calculate the <strong>sum of all rating numbers</strong> for all the <strong>accepted parts</strong> and that’s our answer!</p>\n<blockquote>❗️ All parts begin in the workflow named in.</blockquote>\n<p>We are given a base case, that looks something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*rtukACmiEyk92cD1Sh14KQ.png\"><figcaption>Base case walkthrough</figcaption></figure><p>So, let’s write some code for our base test case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/717/1*oXOjyikvG6FcHZHAb4ZBkQ.png\"><figcaption>Skelton code to get started</figcaption></figure><p>So, as per the visualization above, I am structuring my code to first process workflows and parts and then using the accepted_parts_list , calculate the sum .</p>\n<p>Let’s play around with our input_str to parse our workflows and part_list in a quick REPL:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zlnwDdt7uNqrPWVv3YtNAA.png\"></figure><p>I think we can encapsulate part data nicely by creating a class MachinePart like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/675/1*xtv6-LtP3ue2acH9MK42GA.png\"><figcaption>Might be overkill, but what YOLO</figcaption></figure><p>And our parse_input() looks something like this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/867/1*itPSPmNlXBlM_vJNSjrJkg.png\"></figure><p>Our workflows are still stored as a list of string rules, as I will be dealing with them during our process() flow, let’s do that! As always, we will start from a spagheti code to just build the logic and then refactor for brownee points:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yqwoIdT4NeytTzAO3L6Qkw.png\"><figcaption>Debugging is fun!</figcaption></figure><p>And our sum function can be as simple as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/643/1*gP7EjAquB36lWhzuNKiCFg.png\"></figure><p>Everthing looks good! Let’s run it?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty.py\"<br>✅ sum_of_rating_of_accepted_parts() tests passed<br>🎉 All tests passed<br><br>[Done] exited with code=0 in 0.248 seconds</pre>\n<p>I think we can do away with the ENUM, just makes the code little bloated, I will move the state into our MachinePart class and simplify some of the nesting as well:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/746/1*OuUARm0mFj5J5uW5hvwLiw.png\"><figcaption>MachinePart</figcaption></figure><p>And hence, our process() gets broken into 2 classes, where we can take out common condition logic into evaluate_condition() :</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/870/1*hPn1RfSlCsWCtItWo25Bpg.png\"><figcaption>process -&gt; evaluate_condition for each valid condition!</figcaption></figure><blockquote>I still see <strong>a lot of nesting</strong> we can simplify and we can <strong>save an iteration</strong> we are doing in sum_of_rating_of_accepted_parts, by directly doing that in process() but will leave that for part 2!</blockquote>\n<p>Let’s load up our puzzle input and run this one?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/607/1*xCt5ONdgUvxxJZW76DqKzg.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty.py\"<br>❗️ Sum of ratings of accepted parts: XXXXXX<br><br>[Done] exited with code=0 in 0.207 seconds</pre>\n<p>And we have an answer in just<strong> </strong><strong>0.207 seconds </strong>! Pretty good, considering we had <strong>593 workflows</strong> and <strong>200 parts</strong> in our puzzle input.</p>\n<p>Let’s see if this is the correct answer? And yes it is! 🙌</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qtFO_nNmiEbi4A9x5kHiBQ.png\"><figcaption>⭐️</figcaption></figure><p>Here’s our code till now:</p>\n<pre># Day 19 - Aplenty<br><br>class MachinePart:<br>    ACCEPTED = \"A\"<br>    REJECTED = \"R\"<br><br>    VALID_STATES = [ACCEPTED, REJECTED]<br><br>    def __init__(self, x: int, m: int, a: int, s: int):<br>        self.ratings = {\"x\": x, \"m\": m, \"a\": a, \"s\": s}<br>        self.state = None<br><br>    def set_state(self, state: str) -&gt; None:<br>        if state in [self.ACCEPTED, self.REJECTED]:<br>            self.state = state<br>        else:<br>            raise ValueError(f\"Invalid state: {state}\")<br><br>    def is_unprocessed(self) -&gt; bool:<br>        return self.state is None<br><br>    def __str__(self) -&gt; str:<br>        ratings_str = \",\".join(<br>            [f\"{key}={value}\" for key, value in self.ratings.items()]<br>        )<br>        return ratings_str<br><br><br>def evaluate_condition(part, condition):<br>    if \"&lt;\" in condition:<br>        variable, value = condition.split(\"&lt;\")<br>        return part.ratings[variable] &lt; int(value)<br>    elif \"&gt;\" in condition:<br>        variable, value = condition.split(\"&gt;\")<br>        return part.ratings[variable] &gt; int(value)<br>    else:<br>        raise ValueError(f\"Invalid condition: {condition}\")<br><br><br>def process(workflows: dict, parts_list: list) -&gt; list:<br>    INITIAL_WORKFLOW_ID = \"in\"<br>    CONDITION_SEPARATOR = \":\"<br><br>    for i, part in enumerate(parts_list):<br>        # print(f\"{i+1}/{len(parts_list)}\\n Processing part {part}\\n\\n\")<br>        worflow_id = INITIAL_WORKFLOW_ID<br>        while part.is_unprocessed():<br>            for rule in workflows[worflow_id]:<br>                if CONDITION_SEPARATOR in rule:<br>                    condition, worflow_id = rule.split(CONDITION_SEPARATOR)<br>                    if evaluate_condition(part, condition):<br>                        if worflow_id in MachinePart.VALID_STATES:<br>                            part.set_state(worflow_id)<br>                        break # Break out of for loop and move to new workflow<br>                elif rule in MachinePart.VALID_STATES:<br>                    part.set_state(rule)<br>                else:<br>                    worflow_id = rule<br>    return parts_list<br><br><br>def sum_of_rating_of_accepted_parts(parts_list: list) -&gt; int:<br>    sum = 0<br>    for part in parts_list:<br>        if part.state == MachinePart.ACCEPTED:<br>            sum += (<br>                part.ratings[\"x\"]<br>                + part.ratings[\"m\"]<br>                + part.ratings[\"a\"]<br>                + part.ratings[\"s\"]<br>            )<br>    return sum<br><br><br>def parse_input(input_str: str) -&gt; tuple:<br>    workflow_str, parts_str = input_str.split(\"\\n\\n\")<br>    workflows = {}<br>    for workflow in workflow_str.split(\"\\n\"):<br>        workflow_name, workflow_rules = workflow.split(\"{\")  # Split on first '{'<br>        workflow_rules = workflow_rules[:-1]  # Remove trailing '}'<br>        workflows[workflow_name] = workflow_rules.split(\",\")<br><br>    parts_list = []<br>    for part in parts_str.split(\"\\n\"):<br>        x, m, a, s = part[1:-1].split(\",\")<br>        x = int(x.split(\"=\")[1])<br>        m = int(m.split(\"=\")[1])<br>        a = int(a.split(\"=\")[1])<br>        s = int(s.split(\"=\")[1])<br>        parts_list.append(MachinePart(x, m, a, s))<br><br>    return workflows, parts_list<br><br>def part_one():<br>    with open(\"day_19/input.txt\") as f:<br>        input_str = f.read()<br>    workflows, parts_list = parse_input(input_str)<br>    parts_list = process(workflows, parts_list)<br>    sum = sum_of_rating_of_accepted_parts(parts_list)<br>    print(f\"❗️ Sum of ratings of accepted parts: {sum}\")<br><br>def test_sum_of_rating_of_accepted_parts():<br>    input_str = \"\"\"px{a&lt;2006:qkq,m&gt;2090:A,rfg}<br>pv{a&gt;1716:R,A}<br>lnx{m&gt;1548:A,A}<br>rfg{s&lt;537:gd,x&gt;2440:R,A}<br>qs{s&gt;3448:A,lnx}<br>qkq{x&lt;1416:A,crn}<br>crn{x&gt;2662:A,R}<br>in{s&lt;1351:px,qqz}<br>qqz{s&gt;2770:qs,m&lt;1801:hdj,R}<br>gd{a&gt;3333:R,R}<br>hdj{m&gt;838:A,pv}<br><br>{x=787,m=2655,a=1222,s=2876}<br>{x=1679,m=44,a=2067,s=496}<br>{x=2036,m=264,a=79,s=2244}<br>{x=2461,m=1339,a=466,s=291}<br>{x=2127,m=1623,a=2188,s=1013}\"\"\"<br><br>    workflows, parts_list = parse_input(input_str)<br>    parts_list = process(workflows, parts_list)<br>    sum = sum_of_rating_of_accepted_parts(parts_list)<br>    assert sum == 19114, f\"Expected 19114, got {sum}\"<br>    print(\"✅ sum_of_rating_of_accepted_parts() tests passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_sum_of_rating_of_accepted_parts()<br>    print(\"🎉 All tests passed\")<br><br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>Even with your help, the sorting process still isn’t fast enough.</blockquote>\n<blockquote>One of the Elves comes up with a new plan: rather than sort parts individually through all of these workflows, maybe you can figure out in advance which combinations of ratings will be accepted or rejected.</blockquote>\n<blockquote>Each of the four ratings (x, m, a, s) can have an integer value ranging from a minimum of 1 to a maximum of 4000. Of all possible distinct combinations of ratings, your job is to figure out which ones will be accepted.</blockquote>\n<blockquote>In the above example, there are 167409079868000 distinct combinations of ratings that will be accepted.</blockquote>\n<blockquote>Consider only your list of workflows; the list of part ratings that the Elves wanted you to sort is no longer relevant. How many distinct combinations of ratings will be accepted by the Elves’ workflows?</blockquote>\n<blockquote>Even with your help, the sorting process still <strong>isn’t fast enough</strong>.</blockquote>\n<p>Well, excuse me?!</p>\n<p>So, one of the Elves comes up with a new plan: <strong>rather than sort parts individually</strong> through all of these workflows, maybe we can figure out in advance <strong>which combinations of ratings</strong> will be <strong>accepted</strong> or <strong>rejected</strong>. 🤔</p>\n<p>Interesting! We are given that:</p>\n<ul>\n<li>Each of the four ratings (x, m, a, s) can have an integer value ranging from a minimum of 1 to a maximum of 4000.</li>\n<li>Of all possible distinct combinations of ratings, your job is to figure out which ones will be accepted.</li>\n</ul>\n<p>Well, now we can ignore parts in our puzzle input and we have to share that <strong>how many distinct combinations of ratings will be accepted by the Elves’ workflows?</strong></p>\n<p>💭 Now, looking at the question, it may seem pretty easy as we are scoping our rating values between 1 to 4000, but let me blow up your brain:</p>\n<blockquote>For each of the four ratings (X, M, A, S), which can each take on values from 1 to 4000, there are a total of 256 trillion (256,000,000,000,000) possible combinations! 🤯</blockquote>\n<p><strong>❗️ So, brute force approach is out of question here!</strong></p>\n<p>Now, we need to basically find the upper bound and lower bound of values for each X, M, A, S that will lead us to A — Accepted state for our rules!</p>\n<p>So, let’s visualize our base test case workflow rules? We can basically simplify this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/778/1*FsSQLaFfKQzScrjKVhv83Q.png\"></figure><p>into this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wlxavObXLncEEhyEOVyhMw.png\"></figure><p>where, starting from in we have all these conditional paths to reach A or R . Let’s take the <strong>top left </strong><strong>A in above visualization</strong>, now to reach there, we need to have a Part with value for each rating between the following inclusive ranges:</p>\n<p><strong>x: (1, 4000), m: (1, 2090), a: (2006, 4000), s: (1, 1350)</strong></p>\n<p>so that we can go from in[0] --&gt; px[0] --&gt; px[1] --&gt; A</p>\n<p>Now similarly, to reach the <strong>mid top </strong><strong>A in above visualiation, </strong>the following ranges will fulfill the criteria:</p>\n<p><strong>x: (1, 1415), m: (1, 4000), a: (1, 2005), s: (1, 1350)</strong></p>\n<blockquote>⬆️ This is important, if you didn’t understand how we reached these values, please read again!</blockquote>\n<p>Once we can calculate these ranges for each entry of A in our rules, we just need to do a sum of all possible combinations per range criteria!</p>\n<p>First things first, let’s create a new function find_acceptable_range() which will iterate through our workflow and its’ rules to find a list of ranges as we disucssed above:</p>\n<blockquote>I can’t help but think that this is a backtracking problem, where we will iterate through the <strong>workflows</strong> dict of rules and will push each path to a stack and then we encounter <strong>A </strong>we save that state of ranges and if we encounter <strong>R </strong>we just ignore that and backtrack else we keep going!</blockquote>\n<p>This is just a hunch, but let’s explore that!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6_aJxlS5W4Rg94ai2du2iw.png\"><figcaption>Ah! Let’s see how to fix this!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/672/1*Dt6j4KnrM6rh0SRfjjQAew.png\"><figcaption>Ok!</figcaption></figure><p>So, we are able to get all the valid ranges that will get us to A :</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/845/1*F2Lo3lKo3W5xnVjPsvogsg.png\"></figure><p>But the problem is, they all don’t seem distinct and our test case only has 9 A nodes but our range_list has 14 combinations! 🤔</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*apY1M5d_EpBoxcRaZ6xiLQ.png\"><figcaption>It seems like we have a lot of overlapping ranges!</figcaption></figure><p>.</p>\n<p>.</p>\n<blockquote>back to drawing board</blockquote>\n<p>.</p>\n<p>.</p>\n<p>After couple of hours of debugging! I was able to simplify our code a lot!</p>\n<p><strong><em>💭 The key caveat was that everytime we evaluate a condition </em></strong><strong><em>&lt; </em></strong><strong><em>&gt; for a </em></strong><strong><em>range, for example:</em></strong></p>\n<p><strong>range = {\"x\": (1, 4000), \"m\": (1, 4000), \"a\": (1, 4000), \"s\": (1, 4000)}</strong></p>\n<p>and given condition is a&lt;2006 , our range will split into 2 parts:</p>\n<p><strong>true_range = {.........., \"a\": (1, 2005),.......}</strong></p>\n<p><strong>false_range = {.........., \"a\": (2006, 4000),.......}</strong></p>\n<p>wheretrue_range will go on to evaluate the next_workflow_id and the false_range will move on to the next rule in list!</p>\n<p>Here’s what we had to change in code:</p>\n<p>Introduced a new class MachinePartRanges to store range for each rating! I also had to implement a copy() function for deep copy of our object while spliting into true_range and false_range</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/661/1*QYtDV5jDm2rYwXHzYKEZRg.png\"></figure><p>Here’s our modified evaluate_condition method:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Zi_akXHU4uNa35euIlNAuA.png\"></figure><p>And here’s our <em>creme la de creme</em> methodnum_of_combinations_possible that calculate the distinct combinations of ratings will be accepted by the workflows!</p>\n<blockquote>“This function 👇<strong> broke my brain!</strong>\n</blockquote>\n<blockquote>I spent over 2 hours debugging this as it started with a full on spagetti code with a lot of nesting! Only when I was able to clean it with early returns in my code was when I was able to make some progress!”</blockquote>\n<blockquote><strong><em>Moral of story: Always write clean code so you can debug it later!</em></strong></blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OroyF6H1W7uDVmns6SP9fw.png\"><figcaption>We use the same DFS with Backtracking approach to find all accepted_ranges</figcaption></figure><p>Let’s test our code for the base test case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/805/1*fnxjlpg_a5I7xWMdT9EVYQ.png\"><figcaption>We are still using the same input_str as part_one, but we will discard parts info while parse_input()</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty_2.py\"<br>✅ sum_of_rating_of_accepted_parts() tests passed<br><br>[Done] exited with code=0 in 0.317 seconds</pre>\n<p>Perfect! Let’s load up our puzzle input and check if we can get the answer?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/629/1*DyA0J7_RLH5KBIN0G7rpWw.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty_2.py\"<br>❗️❗️ Number of combinations possible: XXXXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.345 seconds</pre>\n<p>Let’s see if this is the correct answer? 🤞</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8e4LpyIEOcXkq2uAMu5gMA.png\"><figcaption>🌟</figcaption></figure><p>Here’s our code for Part 2, I am very proud of this code! 🥲</p>\n<pre># Day 19 - Aplenty<br># Part Two<br><br>class MachinePartRanges:<br>    ACCEPTED = \"A\"<br>    REJECTED = \"R\"<br><br>    def __init__(self):<br>        self.rating_ranges = {<br>            \"x\": (1, 4000),<br>            \"m\": (1, 4000),<br>            \"a\": (1, 4000),<br>            \"s\": (1, 4000),<br>        }<br>        self.state = None<br><br>    def __repr__(self) -&gt; str:<br>        return str(self.rating_ranges)<br><br>    def copy(self):<br>        # deep copy<br>        new_mpr = MachinePartRanges()<br>        new_mpr.rating_ranges = self.rating_ranges.copy()<br>        return new_mpr<br><br><br>def evaluate_condition(ranges: MachinePartRanges, condition: str) -&gt; (MachinePartRanges, MachinePartRanges):<br>    true_range, false_range = ranges.copy(), ranges.copy()<br><br>    variable, value = condition.split(\"&lt;\" if \"&lt;\" in condition else \"&gt;\")<br><br>    if \"&lt;\" in condition:<br>        true_range.rating_ranges[variable] = (true_range.rating_ranges[variable][0], int(value) - 1)<br>        false_range.rating_ranges[variable] = (int(value), false_range.rating_ranges[variable][1])<br>    elif \"&gt;\" in condition:<br>        true_range.rating_ranges[variable] = (int(value) + 1, true_range.rating_ranges[variable][1])<br>        false_range.rating_ranges[variable] = (false_range.rating_ranges[variable][0], int(value))<br><br>    return true_range, false_range<br><br><br>def num_of_combinations_possible(workflows) -&gt; int:<br>    INITIAL_WORKFLOW_ID = \"in\"<br>    accepted_ranges_list = []<br><br>    stack = [(MachinePartRanges(), INITIAL_WORKFLOW_ID)]<br><br>    while stack:<br>        ranges, workflow_id = stack.pop()<br><br>        if workflow_id == MachinePartRanges.ACCEPTED: <br>            accepted_ranges_list.append(ranges)<br>            continue<br><br>        if workflow_id == MachinePartRanges.REJECTED:<br>            continue<br><br>        for rule in workflows[workflow_id]:<br>            if rule == MachinePartRanges.ACCEPTED:<br>                accepted_ranges_list.append(ranges)<br>                break<br><br>            if rule == MachinePartRanges.REJECTED:<br>                break<br><br>            if \":\" not in rule:<br>                workflow_id = rule<br>                stack.append((ranges, workflow_id))<br>                continue<br><br>            # rule must be a condition<br>            condition, new_worflow_id = rule.split(\":\")<br>            true_range, false_range = evaluate_condition(ranges, condition) <br>            stack.append((true_range, new_worflow_id)) # Add true range to stack to explore new_workflow_id<br>            ranges = false_range # Update ranges for next iteration in rules loop<br><br>    # now we have a list of accepted ranges, we can calculate the number of combinations possible<br>    num_of_combinations = 0<br>    for ranges in accepted_ranges_list:<br>        num_of_combinations += (<br>            (ranges.rating_ranges[\"x\"][1] - ranges.rating_ranges[\"x\"][0] + 1)<br>            * (ranges.rating_ranges[\"m\"][1] - ranges.rating_ranges[\"m\"][0] + 1)<br>            * (ranges.rating_ranges[\"a\"][1] - ranges.rating_ranges[\"a\"][0] + 1)<br>            * (ranges.rating_ranges[\"s\"][1] - ranges.rating_ranges[\"s\"][0] + 1)<br>        )<br><br>    return num_of_combinations<br><br><br>def parse_input(input_str: str) -&gt; tuple:<br>    workflow_str, _ = input_str.split(\"\\n\\n\")<br>    workflows = {}<br>    for workflow in workflow_str.split(\"\\n\"):<br>        workflow_name, workflow_rules = workflow.split(\"{\")  # Split on first '{'<br>        workflow_rules = workflow_rules[:-1]  # Remove trailing '}'<br>        workflows[workflow_name] = workflow_rules.split(\",\")<br><br>    return workflows<br><br>def part_two():<br>    with open(\"day_19/input.txt\") as f:<br>        input_str = f.read()<br>    workflows = parse_input(input_str)<br>    num = num_of_combinations_possible(workflows)<br>    print(f\"❗️❗️ Number of combinations possible: {num}\")<br><br>def test_num_of_combinations_possible():<br>    input_str = \"\"\"px{a&lt;2006:qkq,m&gt;2090:A,rfg}<br>pv{a&gt;1716:R,A}<br>lnx{m&gt;1548:A,A}<br>rfg{s&lt;537:gd,x&gt;2440:R,A}<br>qs{s&gt;3448:A,lnx}<br>qkq{x&lt;1416:A,crn}<br>crn{x&gt;2662:A,R}<br>in{s&lt;1351:px,qqz}<br>qqz{s&gt;2770:qs,m&lt;1801:hdj,R}<br>gd{a&gt;3333:R,R}<br>hdj{m&gt;838:A,pv}<br><br>{x=787,m=2655,a=1222,s=2876}<br>{x=1679,m=44,a=2067,s=496}<br>{x=2036,m=264,a=79,s=2244}<br>{x=2461,m=1339,a=466,s=291}<br>{x=2127,m=1623,a=2188,s=1013}\"\"\"<br><br>    workflows = parse_input(input_str)<br>    num = num_of_combinations_possible(workflows)<br>    assert num == 167409079868000, f\"Expected 167409079868000, got {num}\"<br>    print(\"✅ sum_of_rating_of_accepted_parts() tests passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_num_of_combinations_possible()<br>    part_two()</pre>\n<p>I am keeping Part 1 and Part 2 seperate in our code base as both parts are actually pretty different in terms of processing, might come back to merge them later. Too tired for now!</p>\n<p>Feel free to raise a PR?!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine 👇</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! 🎄</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=522ba14b1444\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*jciy1cL5lsSK0f7R\"><figcaption>Aplenty (via DALL-E 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/19\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>The Elves of Gear Island are thankful for your help and send you on your way. They even have a hang glider that someone <a href=\"https://adventofcode.com/2023/day/9\">stole</a> from Desert Island; since you’re already going that direction, it would help them a lot if you would use it to get down there and return it to them.</blockquote>\n<blockquote>As you reach the bottom of the relentless avalanche of machine parts, you discover that they’re already forming a formidable heap. Don’t worry, though — a group of Elves is already here organizing the parts, and they have a system.</blockquote>\n<blockquote>To start, each part is rated in each of four categories:</blockquote>\n<blockquote>x: Extremely cool looking</blockquote>\n<blockquote>m: Musical (it makes a noise when you hit it)</blockquote>\n<blockquote>a: Aerodynamic</blockquote>\n<blockquote>s: Shiny</blockquote>\n<blockquote>Then, each part is sent through a series of workflows that will ultimately accept or reject the part. Each workflow has a name and contains a list of rules; each rule specifies a condition and where to send the part if the condition is true. The first rule that matches the part being considered is applied immediately, and the part moves on to the destination described by the rule. (The last rule in each workflow has no condition and always applies if reached.)</blockquote>\n<blockquote>Consider the workflow ex{x&gt;10:one,m&lt;20:two,a&gt;30:R,A}. This workflow is named ex and contains four rules. If workflow ex were considering a specific part, it would perform the following steps in order:</blockquote>\n<blockquote>Rule “x&gt;10:one\": If the part's x is more than 10, send the part to the workflow named one.</blockquote>\n<blockquote>Rule “m&lt;20:two\": Otherwise, if the part's m is less than 20, send the part to the workflow named two.</blockquote>\n<blockquote>Rule “a&gt;30:R\": Otherwise, if the part's a is more than 30, the part is immediately rejected (R).</blockquote>\n<blockquote>Rule “A\": Otherwise, because no other rules matched the part, the part is immediately accepted (A).</blockquote>\n<blockquote>If a part is sent to another workflow, it immediately switches to the start of that workflow instead and never returns. If a part is accepted (sent to A) or rejected (sent to R), the part immediately stops any further processing.</blockquote>\n<blockquote>The system works, but it’s not keeping up with the torrent of weird metal shapes. The Elves ask if you can help sort a few parts and give you the list of workflows and some part ratings (your puzzle input). For example:</blockquote>\n<blockquote>px{a&lt;2006:qkq,m&gt;2090:A,rfg}<br>pv{a&gt;1716:R,A}<br>lnx{m&gt;1548:A,A}<br>rfg{s&lt;537:gd,x&gt;2440:R,A}<br>qs{s&gt;3448:A,lnx}<br>qkq{x&lt;1416:A,crn}<br>crn{x&gt;2662:A,R}<br>in{s&lt;1351:px,qqz}<br>qqz{s&gt;2770:qs,m&lt;1801:hdj,R}<br>gd{a&gt;3333:R,R}<br>hdj{m&gt;838:A,pv}</blockquote>\n<blockquote>{x=787,m=2655,a=1222,s=2876}<br>{x=1679,m=44,a=2067,s=496}<br>{x=2036,m=264,a=79,s=2244}<br>{x=2461,m=1339,a=466,s=291}<br>{x=2127,m=1623,a=2188,s=1013}</blockquote>\n<blockquote>The workflows are listed first, followed by a blank line, then the ratings of the parts the Elves would like you to sort. All parts begin in the workflow named in. In this example, the five listed parts go through the following workflows:</blockquote>\n<blockquote>{x=787,m=2655,a=1222,s=2876}: in -&gt; qqz -&gt; qs -&gt; lnx -&gt; A</blockquote>\n<blockquote>{x=1679,m=44,a=2067,s=496}: in -&gt; px -&gt; rfg -&gt; gd -&gt; R</blockquote>\n<blockquote>{x=2036,m=264,a=79,s=2244}: in -&gt; qqz -&gt; hdj -&gt; pv -&gt; A</blockquote>\n<blockquote>{x=2461,m=1339,a=466,s=291}: in -&gt; px -&gt; qkq -&gt; crn -&gt; R</blockquote>\n<blockquote>{x=2127,m=1623,a=2188,s=1013}: in -&gt; px -&gt; rfg -&gt; A</blockquote>\n<blockquote>Ultimately, three parts are accepted. Adding up the x, m, a, and s rating for each of the accepted parts gives 7540 for the part with x=787, 4623 for the part with x=2036, and 6951 for the part with x=2127. Adding all of the ratings for all of the accepted parts gives the sum total of 19114.</blockquote>\n<blockquote>Sort through all of the parts you’ve been given; what do you get if you add together all of the rating numbers for all of the parts that ultimately get accepted?</blockquote>\n<blockquote>They even have a hang glider that someone <a href=\"https://adventofcode.com/2023/day/9\">stole</a> from Desert Island.</blockquote>\n<p>Ah, well! 👀</p>\n<p>So, seems like now we have a <em>relentless avalanche of machine parts</em> that has formed a giant heap. But some elves are trying to organize them based of a system that rates each part in following 4 categories:</p>\n<ul>\n<li>x: Extremely cool looking</li>\n<li>m: Musical (it makes a noise when you hit it)</li>\n<li>a: Aerodynamic</li>\n<li>s: Shiny</li>\n</ul>\n<blockquote>Not very scientific, is it?!</blockquote>\n<blockquote>Then, each part is sent through a series of workflows that will ultimately accept or reject the part. Each workflow has a name and contains a list of rules; each rule specifies a condition and where to send the part if the condition is true. The first rule that matches the part being considered is applied immediately, and the part moves on to the destination described by the rule. (The last rule in each workflow has no condition and always applies if reached.)</blockquote>\n<p>So, seems like each workflow has a series of qualification checks and as soon as a condition is met, we send the part to subsequent workflow.</p>\n<p>We are given an example workflow: ex{x&gt;10:one,m&lt;20:two,a&gt;30:R,A} which is named ex and has 4 rules:</p>\n<ul>\n<li>Rule “x&gt;10:one\": If the part's x is more than 10, send the part to the workflow named one.</li>\n<li>Rule “m&lt;20:two\": Otherwise, if the part's m is less than 20, send the part to the workflow named two.</li>\n<li>Rule “a&gt;30:R\": Otherwise, if the part's a is more than 30, the part is immediately rejected (R).</li>\n<li>Rule “A\": Otherwise, because no other rules matched the part, the part is immediately accepted (A).</li>\n</ul>\n<blockquote>If a part is sent to another workflow, it immediately switches to the start of that workflow instead and never returns. If a part is accepted (sent to A) or rejected (sent to R), the part immediately stops any further processing.</blockquote>\n<p>Got it! So, we can clearly see that each <strong>part</strong> seems to be an <strong>object</strong> with 4 properties and then we have a <strong>rule engine </strong>which is navigating through a series of <strong>workflows</strong> to finally reach either: <strong>A Accepted </strong>or<strong> </strong><strong>R Rejected.</strong></p>\n<p>We then go on to calculate the <strong>sum of all rating numbers</strong> for all the <strong>accepted parts</strong> and that’s our answer!</p>\n<blockquote>❗️ All parts begin in the workflow named in.</blockquote>\n<p>We are given a base case, that looks something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*rtukACmiEyk92cD1Sh14KQ.png\"><figcaption>Base case walkthrough</figcaption></figure><p>So, let’s write some code for our base test case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/717/1*oXOjyikvG6FcHZHAb4ZBkQ.png\"><figcaption>Skelton code to get started</figcaption></figure><p>So, as per the visualization above, I am structuring my code to first process workflows and parts and then using the accepted_parts_list , calculate the sum .</p>\n<p>Let’s play around with our input_str to parse our workflows and part_list in a quick REPL:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zlnwDdt7uNqrPWVv3YtNAA.png\"></figure><p>I think we can encapsulate part data nicely by creating a class MachinePart like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/675/1*xtv6-LtP3ue2acH9MK42GA.png\"><figcaption>Might be overkill, but what YOLO</figcaption></figure><p>And our parse_input() looks something like this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/867/1*itPSPmNlXBlM_vJNSjrJkg.png\"></figure><p>Our workflows are still stored as a list of string rules, as I will be dealing with them during our process() flow, let’s do that! As always, we will start from a spagheti code to just build the logic and then refactor for brownee points:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yqwoIdT4NeytTzAO3L6Qkw.png\"><figcaption>Debugging is fun!</figcaption></figure><p>And our sum function can be as simple as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/643/1*gP7EjAquB36lWhzuNKiCFg.png\"></figure><p>Everthing looks good! Let’s run it?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty.py\"<br>✅ sum_of_rating_of_accepted_parts() tests passed<br>🎉 All tests passed<br><br>[Done] exited with code=0 in 0.248 seconds</pre>\n<p>I think we can do away with the ENUM, just makes the code little bloated, I will move the state into our MachinePart class and simplify some of the nesting as well:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/746/1*OuUARm0mFj5J5uW5hvwLiw.png\"><figcaption>MachinePart</figcaption></figure><p>And hence, our process() gets broken into 2 classes, where we can take out common condition logic into evaluate_condition() :</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/870/1*hPn1RfSlCsWCtItWo25Bpg.png\"><figcaption>process -&gt; evaluate_condition for each valid condition!</figcaption></figure><blockquote>I still see <strong>a lot of nesting</strong> we can simplify and we can <strong>save an iteration</strong> we are doing in sum_of_rating_of_accepted_parts, by directly doing that in process() but will leave that for part 2!</blockquote>\n<p>Let’s load up our puzzle input and run this one?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/607/1*xCt5ONdgUvxxJZW76DqKzg.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty.py\"<br>❗️ Sum of ratings of accepted parts: XXXXXX<br><br>[Done] exited with code=0 in 0.207 seconds</pre>\n<p>And we have an answer in just<strong> </strong><strong>0.207 seconds </strong>! Pretty good, considering we had <strong>593 workflows</strong> and <strong>200 parts</strong> in our puzzle input.</p>\n<p>Let’s see if this is the correct answer? And yes it is! 🙌</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qtFO_nNmiEbi4A9x5kHiBQ.png\"><figcaption>⭐️</figcaption></figure><p>Here’s our code till now:</p>\n<pre># Day 19 - Aplenty<br><br>class MachinePart:<br>    ACCEPTED = \"A\"<br>    REJECTED = \"R\"<br><br>    VALID_STATES = [ACCEPTED, REJECTED]<br><br>    def __init__(self, x: int, m: int, a: int, s: int):<br>        self.ratings = {\"x\": x, \"m\": m, \"a\": a, \"s\": s}<br>        self.state = None<br><br>    def set_state(self, state: str) -&gt; None:<br>        if state in [self.ACCEPTED, self.REJECTED]:<br>            self.state = state<br>        else:<br>            raise ValueError(f\"Invalid state: {state}\")<br><br>    def is_unprocessed(self) -&gt; bool:<br>        return self.state is None<br><br>    def __str__(self) -&gt; str:<br>        ratings_str = \",\".join(<br>            [f\"{key}={value}\" for key, value in self.ratings.items()]<br>        )<br>        return ratings_str<br><br><br>def evaluate_condition(part, condition):<br>    if \"&lt;\" in condition:<br>        variable, value = condition.split(\"&lt;\")<br>        return part.ratings[variable] &lt; int(value)<br>    elif \"&gt;\" in condition:<br>        variable, value = condition.split(\"&gt;\")<br>        return part.ratings[variable] &gt; int(value)<br>    else:<br>        raise ValueError(f\"Invalid condition: {condition}\")<br><br><br>def process(workflows: dict, parts_list: list) -&gt; list:<br>    INITIAL_WORKFLOW_ID = \"in\"<br>    CONDITION_SEPARATOR = \":\"<br><br>    for i, part in enumerate(parts_list):<br>        # print(f\"{i+1}/{len(parts_list)}\\n Processing part {part}\\n\\n\")<br>        worflow_id = INITIAL_WORKFLOW_ID<br>        while part.is_unprocessed():<br>            for rule in workflows[worflow_id]:<br>                if CONDITION_SEPARATOR in rule:<br>                    condition, worflow_id = rule.split(CONDITION_SEPARATOR)<br>                    if evaluate_condition(part, condition):<br>                        if worflow_id in MachinePart.VALID_STATES:<br>                            part.set_state(worflow_id)<br>                        break # Break out of for loop and move to new workflow<br>                elif rule in MachinePart.VALID_STATES:<br>                    part.set_state(rule)<br>                else:<br>                    worflow_id = rule<br>    return parts_list<br><br><br>def sum_of_rating_of_accepted_parts(parts_list: list) -&gt; int:<br>    sum = 0<br>    for part in parts_list:<br>        if part.state == MachinePart.ACCEPTED:<br>            sum += (<br>                part.ratings[\"x\"]<br>                + part.ratings[\"m\"]<br>                + part.ratings[\"a\"]<br>                + part.ratings[\"s\"]<br>            )<br>    return sum<br><br><br>def parse_input(input_str: str) -&gt; tuple:<br>    workflow_str, parts_str = input_str.split(\"\\n\\n\")<br>    workflows = {}<br>    for workflow in workflow_str.split(\"\\n\"):<br>        workflow_name, workflow_rules = workflow.split(\"{\")  # Split on first '{'<br>        workflow_rules = workflow_rules[:-1]  # Remove trailing '}'<br>        workflows[workflow_name] = workflow_rules.split(\",\")<br><br>    parts_list = []<br>    for part in parts_str.split(\"\\n\"):<br>        x, m, a, s = part[1:-1].split(\",\")<br>        x = int(x.split(\"=\")[1])<br>        m = int(m.split(\"=\")[1])<br>        a = int(a.split(\"=\")[1])<br>        s = int(s.split(\"=\")[1])<br>        parts_list.append(MachinePart(x, m, a, s))<br><br>    return workflows, parts_list<br><br>def part_one():<br>    with open(\"day_19/input.txt\") as f:<br>        input_str = f.read()<br>    workflows, parts_list = parse_input(input_str)<br>    parts_list = process(workflows, parts_list)<br>    sum = sum_of_rating_of_accepted_parts(parts_list)<br>    print(f\"❗️ Sum of ratings of accepted parts: {sum}\")<br><br>def test_sum_of_rating_of_accepted_parts():<br>    input_str = \"\"\"px{a&lt;2006:qkq,m&gt;2090:A,rfg}<br>pv{a&gt;1716:R,A}<br>lnx{m&gt;1548:A,A}<br>rfg{s&lt;537:gd,x&gt;2440:R,A}<br>qs{s&gt;3448:A,lnx}<br>qkq{x&lt;1416:A,crn}<br>crn{x&gt;2662:A,R}<br>in{s&lt;1351:px,qqz}<br>qqz{s&gt;2770:qs,m&lt;1801:hdj,R}<br>gd{a&gt;3333:R,R}<br>hdj{m&gt;838:A,pv}<br><br>{x=787,m=2655,a=1222,s=2876}<br>{x=1679,m=44,a=2067,s=496}<br>{x=2036,m=264,a=79,s=2244}<br>{x=2461,m=1339,a=466,s=291}<br>{x=2127,m=1623,a=2188,s=1013}\"\"\"<br><br>    workflows, parts_list = parse_input(input_str)<br>    parts_list = process(workflows, parts_list)<br>    sum = sum_of_rating_of_accepted_parts(parts_list)<br>    assert sum == 19114, f\"Expected 19114, got {sum}\"<br>    print(\"✅ sum_of_rating_of_accepted_parts() tests passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_sum_of_rating_of_accepted_parts()<br>    print(\"🎉 All tests passed\")<br><br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>Even with your help, the sorting process still isn’t fast enough.</blockquote>\n<blockquote>One of the Elves comes up with a new plan: rather than sort parts individually through all of these workflows, maybe you can figure out in advance which combinations of ratings will be accepted or rejected.</blockquote>\n<blockquote>Each of the four ratings (x, m, a, s) can have an integer value ranging from a minimum of 1 to a maximum of 4000. Of all possible distinct combinations of ratings, your job is to figure out which ones will be accepted.</blockquote>\n<blockquote>In the above example, there are 167409079868000 distinct combinations of ratings that will be accepted.</blockquote>\n<blockquote>Consider only your list of workflows; the list of part ratings that the Elves wanted you to sort is no longer relevant. How many distinct combinations of ratings will be accepted by the Elves’ workflows?</blockquote>\n<blockquote>Even with your help, the sorting process still <strong>isn’t fast enough</strong>.</blockquote>\n<p>Well, excuse me?!</p>\n<p>So, one of the Elves comes up with a new plan: <strong>rather than sort parts individually</strong> through all of these workflows, maybe we can figure out in advance <strong>which combinations of ratings</strong> will be <strong>accepted</strong> or <strong>rejected</strong>. 🤔</p>\n<p>Interesting! We are given that:</p>\n<ul>\n<li>Each of the four ratings (x, m, a, s) can have an integer value ranging from a minimum of 1 to a maximum of 4000.</li>\n<li>Of all possible distinct combinations of ratings, your job is to figure out which ones will be accepted.</li>\n</ul>\n<p>Well, now we can ignore parts in our puzzle input and we have to share that <strong>how many distinct combinations of ratings will be accepted by the Elves’ workflows?</strong></p>\n<p>💭 Now, looking at the question, it may seem pretty easy as we are scoping our rating values between 1 to 4000, but let me blow up your brain:</p>\n<blockquote>For each of the four ratings (X, M, A, S), which can each take on values from 1 to 4000, there are a total of 256 trillion (256,000,000,000,000) possible combinations! 🤯</blockquote>\n<p><strong>❗️ So, brute force approach is out of question here!</strong></p>\n<p>Now, we need to basically find the upper bound and lower bound of values for each X, M, A, S that will lead us to A — Accepted state for our rules!</p>\n<p>So, let’s visualize our base test case workflow rules? We can basically simplify this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/778/1*FsSQLaFfKQzScrjKVhv83Q.png\"></figure><p>into this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wlxavObXLncEEhyEOVyhMw.png\"></figure><p>where, starting from in we have all these conditional paths to reach A or R . Let’s take the <strong>top left </strong><strong>A in above visualization</strong>, now to reach there, we need to have a Part with value for each rating between the following inclusive ranges:</p>\n<p><strong>x: (1, 4000), m: (1, 2090), a: (2006, 4000), s: (1, 1350)</strong></p>\n<p>so that we can go from in[0] --&gt; px[0] --&gt; px[1] --&gt; A</p>\n<p>Now similarly, to reach the <strong>mid top </strong><strong>A in above visualiation, </strong>the following ranges will fulfill the criteria:</p>\n<p><strong>x: (1, 1415), m: (1, 4000), a: (1, 2005), s: (1, 1350)</strong></p>\n<blockquote>⬆️ This is important, if you didn’t understand how we reached these values, please read again!</blockquote>\n<p>Once we can calculate these ranges for each entry of A in our rules, we just need to do a sum of all possible combinations per range criteria!</p>\n<p>First things first, let’s create a new function find_acceptable_range() which will iterate through our workflow and its’ rules to find a list of ranges as we disucssed above:</p>\n<blockquote>I can’t help but think that this is a backtracking problem, where we will iterate through the <strong>workflows</strong> dict of rules and will push each path to a stack and then we encounter <strong>A </strong>we save that state of ranges and if we encounter <strong>R </strong>we just ignore that and backtrack else we keep going!</blockquote>\n<p>This is just a hunch, but let’s explore that!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6_aJxlS5W4Rg94ai2du2iw.png\"><figcaption>Ah! Let’s see how to fix this!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/672/1*Dt6j4KnrM6rh0SRfjjQAew.png\"><figcaption>Ok!</figcaption></figure><p>So, we are able to get all the valid ranges that will get us to A :</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/845/1*F2Lo3lKo3W5xnVjPsvogsg.png\"></figure><p>But the problem is, they all don’t seem distinct and our test case only has 9 A nodes but our range_list has 14 combinations! 🤔</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*apY1M5d_EpBoxcRaZ6xiLQ.png\"><figcaption>It seems like we have a lot of overlapping ranges!</figcaption></figure><p>.</p>\n<p>.</p>\n<blockquote>back to drawing board</blockquote>\n<p>.</p>\n<p>.</p>\n<p>After couple of hours of debugging! I was able to simplify our code a lot!</p>\n<p><strong><em>💭 The key caveat was that everytime we evaluate a condition </em></strong><strong><em>&lt; </em></strong><strong><em>&gt; for a </em></strong><strong><em>range, for example:</em></strong></p>\n<p><strong>range = {\"x\": (1, 4000), \"m\": (1, 4000), \"a\": (1, 4000), \"s\": (1, 4000)}</strong></p>\n<p>and given condition is a&lt;2006 , our range will split into 2 parts:</p>\n<p><strong>true_range = {.........., \"a\": (1, 2005),.......}</strong></p>\n<p><strong>false_range = {.........., \"a\": (2006, 4000),.......}</strong></p>\n<p>wheretrue_range will go on to evaluate the next_workflow_id and the false_range will move on to the next rule in list!</p>\n<p>Here’s what we had to change in code:</p>\n<p>Introduced a new class MachinePartRanges to store range for each rating! I also had to implement a copy() function for deep copy of our object while spliting into true_range and false_range</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/661/1*QYtDV5jDm2rYwXHzYKEZRg.png\"></figure><p>Here’s our modified evaluate_condition method:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Zi_akXHU4uNa35euIlNAuA.png\"></figure><p>And here’s our <em>creme la de creme</em> methodnum_of_combinations_possible that calculate the distinct combinations of ratings will be accepted by the workflows!</p>\n<blockquote>“This function 👇<strong> broke my brain!</strong>\n</blockquote>\n<blockquote>I spent over 2 hours debugging this as it started with a full on spagetti code with a lot of nesting! Only when I was able to clean it with early returns in my code was when I was able to make some progress!”</blockquote>\n<blockquote><strong><em>Moral of story: Always write clean code so you can debug it later!</em></strong></blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OroyF6H1W7uDVmns6SP9fw.png\"><figcaption>We use the same DFS with Backtracking approach to find all accepted_ranges</figcaption></figure><p>Let’s test our code for the base test case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/805/1*fnxjlpg_a5I7xWMdT9EVYQ.png\"><figcaption>We are still using the same input_str as part_one, but we will discard parts info while parse_input()</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty_2.py\"<br>✅ sum_of_rating_of_accepted_parts() tests passed<br><br>[Done] exited with code=0 in 0.317 seconds</pre>\n<p>Perfect! Let’s load up our puzzle input and check if we can get the answer?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/629/1*DyA0J7_RLH5KBIN0G7rpWw.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_19/aplenty_2.py\"<br>❗️❗️ Number of combinations possible: XXXXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.345 seconds</pre>\n<p>Let’s see if this is the correct answer? 🤞</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8e4LpyIEOcXkq2uAMu5gMA.png\"><figcaption>🌟</figcaption></figure><p>Here’s our code for Part 2, I am very proud of this code! 🥲</p>\n<pre># Day 19 - Aplenty<br># Part Two<br><br>class MachinePartRanges:<br>    ACCEPTED = \"A\"<br>    REJECTED = \"R\"<br><br>    def __init__(self):<br>        self.rating_ranges = {<br>            \"x\": (1, 4000),<br>            \"m\": (1, 4000),<br>            \"a\": (1, 4000),<br>            \"s\": (1, 4000),<br>        }<br>        self.state = None<br><br>    def __repr__(self) -&gt; str:<br>        return str(self.rating_ranges)<br><br>    def copy(self):<br>        # deep copy<br>        new_mpr = MachinePartRanges()<br>        new_mpr.rating_ranges = self.rating_ranges.copy()<br>        return new_mpr<br><br><br>def evaluate_condition(ranges: MachinePartRanges, condition: str) -&gt; (MachinePartRanges, MachinePartRanges):<br>    true_range, false_range = ranges.copy(), ranges.copy()<br><br>    variable, value = condition.split(\"&lt;\" if \"&lt;\" in condition else \"&gt;\")<br><br>    if \"&lt;\" in condition:<br>        true_range.rating_ranges[variable] = (true_range.rating_ranges[variable][0], int(value) - 1)<br>        false_range.rating_ranges[variable] = (int(value), false_range.rating_ranges[variable][1])<br>    elif \"&gt;\" in condition:<br>        true_range.rating_ranges[variable] = (int(value) + 1, true_range.rating_ranges[variable][1])<br>        false_range.rating_ranges[variable] = (false_range.rating_ranges[variable][0], int(value))<br><br>    return true_range, false_range<br><br><br>def num_of_combinations_possible(workflows) -&gt; int:<br>    INITIAL_WORKFLOW_ID = \"in\"<br>    accepted_ranges_list = []<br><br>    stack = [(MachinePartRanges(), INITIAL_WORKFLOW_ID)]<br><br>    while stack:<br>        ranges, workflow_id = stack.pop()<br><br>        if workflow_id == MachinePartRanges.ACCEPTED: <br>            accepted_ranges_list.append(ranges)<br>            continue<br><br>        if workflow_id == MachinePartRanges.REJECTED:<br>            continue<br><br>        for rule in workflows[workflow_id]:<br>            if rule == MachinePartRanges.ACCEPTED:<br>                accepted_ranges_list.append(ranges)<br>                break<br><br>            if rule == MachinePartRanges.REJECTED:<br>                break<br><br>            if \":\" not in rule:<br>                workflow_id = rule<br>                stack.append((ranges, workflow_id))<br>                continue<br><br>            # rule must be a condition<br>            condition, new_worflow_id = rule.split(\":\")<br>            true_range, false_range = evaluate_condition(ranges, condition) <br>            stack.append((true_range, new_worflow_id)) # Add true range to stack to explore new_workflow_id<br>            ranges = false_range # Update ranges for next iteration in rules loop<br><br>    # now we have a list of accepted ranges, we can calculate the number of combinations possible<br>    num_of_combinations = 0<br>    for ranges in accepted_ranges_list:<br>        num_of_combinations += (<br>            (ranges.rating_ranges[\"x\"][1] - ranges.rating_ranges[\"x\"][0] + 1)<br>            * (ranges.rating_ranges[\"m\"][1] - ranges.rating_ranges[\"m\"][0] + 1)<br>            * (ranges.rating_ranges[\"a\"][1] - ranges.rating_ranges[\"a\"][0] + 1)<br>            * (ranges.rating_ranges[\"s\"][1] - ranges.rating_ranges[\"s\"][0] + 1)<br>        )<br><br>    return num_of_combinations<br><br><br>def parse_input(input_str: str) -&gt; tuple:<br>    workflow_str, _ = input_str.split(\"\\n\\n\")<br>    workflows = {}<br>    for workflow in workflow_str.split(\"\\n\"):<br>        workflow_name, workflow_rules = workflow.split(\"{\")  # Split on first '{'<br>        workflow_rules = workflow_rules[:-1]  # Remove trailing '}'<br>        workflows[workflow_name] = workflow_rules.split(\",\")<br><br>    return workflows<br><br>def part_two():<br>    with open(\"day_19/input.txt\") as f:<br>        input_str = f.read()<br>    workflows = parse_input(input_str)<br>    num = num_of_combinations_possible(workflows)<br>    print(f\"❗️❗️ Number of combinations possible: {num}\")<br><br>def test_num_of_combinations_possible():<br>    input_str = \"\"\"px{a&lt;2006:qkq,m&gt;2090:A,rfg}<br>pv{a&gt;1716:R,A}<br>lnx{m&gt;1548:A,A}<br>rfg{s&lt;537:gd,x&gt;2440:R,A}<br>qs{s&gt;3448:A,lnx}<br>qkq{x&lt;1416:A,crn}<br>crn{x&gt;2662:A,R}<br>in{s&lt;1351:px,qqz}<br>qqz{s&gt;2770:qs,m&lt;1801:hdj,R}<br>gd{a&gt;3333:R,R}<br>hdj{m&gt;838:A,pv}<br><br>{x=787,m=2655,a=1222,s=2876}<br>{x=1679,m=44,a=2067,s=496}<br>{x=2036,m=264,a=79,s=2244}<br>{x=2461,m=1339,a=466,s=291}<br>{x=2127,m=1623,a=2188,s=1013}\"\"\"<br><br>    workflows = parse_input(input_str)<br>    num = num_of_combinations_possible(workflows)<br>    assert num == 167409079868000, f\"Expected 167409079868000, got {num}\"<br>    print(\"✅ sum_of_rating_of_accepted_parts() tests passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_num_of_combinations_possible()<br>    part_two()</pre>\n<p>I am keeping Part 1 and Part 2 seperate in our code base as both parts are actually pretty different in terms of processing, might come back to merge them later. Too tired for now!</p>\n<p>Feel free to raise a PR?!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine 👇</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! 🎄</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=522ba14b1444\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "programming",
        "advent-of-code",
        "advent-of-code-2023",
        "python",
        "coding"
      ]
    },
    {
      "title": "[Day 18] Lavaduct Lagoon // Advent of Code 2023 (Python)",
      "pubDate": "2023-12-26 16:09:49",
      "link": "https://medium.com/@jatinkrmalik/day-18-lavaduct-lagoon-advent-of-code-2023-python-f9413538d1d1?source=rss-ec576e4b06b0------2",
      "guid": "https://medium.com/p/f9413538d1d1",
      "author": "Jatin K Malik",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*lYtv2QgDM5vbpmoV\"><figcaption>Lavaduct Lagoon (via DALL-E 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/18\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>Thanks to your efforts, the machine parts factory is one of the first factories up and running since the lavafall came back. However, to catch up with the large backlog of parts requests, the factory will also need a large supply of lava for a while; the Elves have already started creating a large lagoon nearby for this purpose.</blockquote>\n<blockquote>However, they aren’t sure the lagoon will be big enough; they’ve asked you to take a look at the dig plan (your puzzle input). For example:</blockquote>\n<blockquote>R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)</blockquote>\n<blockquote>The digger starts in a 1 meter cube hole in the ground. They then dig the specified number of meters up (U), down (D), left (L), or right (R), clearing full 1 meter cubes as they go. The directions are given as seen from above, so if \"up\" were north, then \"right\" would be east, and so on. Each trench is also listed with the color that the edge of the trench should be painted as an <a href=\"https://en.wikipedia.org/wiki/RGB_color_model#Numeric_representations\">RGB hexadecimal color code</a>.</blockquote>\n<blockquote>When viewed from above, the above example dig plan would result in the following loop of trench (#) having been dug out from otherwise ground-level terrain (.):</blockquote>\n<blockquote>#######<br>#.....#<br>###...#<br>..#...#<br>..#...#<br>###.###<br>#...#..<br>##..###<br>.#....#<br>.######</blockquote>\n<blockquote>At this point, the trench could contain 38 cubic meters of lava. However, this is just the edge of the lagoon; the next step is to dig out the interior so that it is one meter deep as well:</blockquote>\n<blockquote>#######<br>#######<br>#######<br>..#####<br>..#####<br>#######<br>#####..<br>#######<br>.######<br>.######</blockquote>\n<blockquote>Now, the lagoon can contain a much more respectable 62 cubic meters of lava. While the interior is dug out, the edges are also painted according to the color codes in the dig plan.</blockquote>\n<blockquote>The Elves are concerned the lagoon won’t be large enough; if they follow their dig plan, how many cubic meters of lava could it hold?</blockquote>\n<p>So, we are given a dig plan for the lagoon, which looks like this:</p>\n<pre>R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)</pre>\n<p>So, this basically works in 3 steps:</p>\n<ol>\n<li>\n<strong>Dig</strong> the trenches as per each row of dig plan</li>\n<li>\n<strong>Paint</strong> the edges of trenches as per the dig plan</li>\n<li>\n<strong>Dig</strong> enclosed area by trench loop to form a lagoon</li>\n</ol>\n<p>We can understand this better with the following visualization I created for my own understanding:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*i0i1AiTNlNCOPpdzXIQR2g.png\"><figcaption>Visualizations make everything simple!</figcaption></figure><blockquote>The Elves are concerned the lagoon won’t be large enough; if they follow their dig plan, how many cubic meters of lava could it hold?</blockquote>\n<p>Got it! So, let’s follow our visualization and write some code with the base test case!</p>\n<blockquote>💡I don’t see any use of RGB hexcodes for now, so we will park that. We may need it in part 2.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/785/1*AVtJDen82jr1JNBixsd3uA.png\"></figure><p>Let’s start one by one! First step is to implement dig_trench()</p>\n<blockquote>❗️A caveat I can observe is that we don’t really know the size of the site! All we know is that digger starts in a 1 meter cube hole in the ground.</blockquote>\n<p>Assuming we start from (0, 0) our size will depend on how much further RIGHT and DOWN we go! Something like row, col = max(DOWN), max(RIGHT) , we will figure out that.</p>\n<p>Now, to parse dig_plan, we can just define:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/354/1*Jps0cV06YMfgT5Tqz9QQnw.png\"></figure><p>And then, we can just iterate over the dig_plan and store the path in trench_path as a list of cordinates:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/627/1*wmxMcP44a-2UAdzWBa4sCQ.png\"></figure><p>Our trench_path may have duplicate nodes based on our dig plan, so since each node is just 1 m³ deep, we can calculate it’s volume by just returning len(set(trench_path)) !</p>\n<p>Let’s verify if this is correct, modifying our base test case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/761/1*eL1jyYxJczzbJPmcvMd75g.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>✅ get_trench_volume passed<br><br>[Done] exited with code=0 in 0.236 seconds</pre>\n<p>Perfect, now let’s implement dig_lagoon to convert our trench_path loop into a lagoon_area !</p>\n<p>💭 So, whenver we have to find tiles enclosed within a loop, the best way I know to do so is to do the<strong> Flood Fill</strong> algorithm! It works something like:</p>\n<ul>\n<li>start from 1 point inside the loop</li>\n<li>use flood fill algorithm from this starting point to fill all reachable tiles</li>\n<li>it starts at a tile, then recursively fills adjacent tiles until it hits the boundary (the trench_path in this case).</li>\n<li>as the flood fill algorithm visits each tile, store these tiles in a set — lagoon_area</li>\n</ul>\n<p>Here’s a quick visualization for this example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*bnnAGlPqXtpppKsPzmvURA.gif\"><figcaption>Flood fill for the base case</figcaption></figure><p>But wait! We have seen this before! Remember Day 10?</p>\n<p><a href=\"https://medium.com/@jatinkrmalik/wip-day-10-pipe-maze-advent-of-code-2023-python-2a4c8622707f\">[WIP][Day 10] Pipe Maze // Advent of Code 2023 (Python)</a></p>\n<p>We had exactly the same problem, but here instead of area, we have to calculate the volume, but given the depth == 1 m³, the answer shall be equivalent to the area itself!</p>\n<p>We can similarly use:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Shoelace_formula\">Shoelace formula - Wikipedia</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Pick%27s_theorem\">Pick's theorem - Wikipedia</a></li>\n</ul>\n<p>And get number of tiles enclosed within trench_loop and then calculate lagoon’s volume!</p>\n<p>Let’s experiment with that one first!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/723/1*0X6R6Zq9uPP_KEStV73VsA.png\"></figure><p>And…running our test case now:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/727/1*3v815OPcZBhBXIDl31G7sQ.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>✅ get_trench_volume passed<br>✅ get_lagoon_volume passed<br><br>[Done] exited with code=0 in 0.305 seconds</pre>\n<p>Boom! Our hypothesis was correct, as we didn’t have to do the flood fill and Shoelace’s formula came to the rescue!</p>\n<p>Let’s load up our puzzle input and see if it works!</p>\n<blockquote>❗️The only caveat with Shoelace’s formula is that it works for simple, non-intersecting polygon! <strong><em>That may cause a problem!</em></strong>\n</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/706/1*ivfOVbq9KCimj91BwYCg2A.png\"></figure><p>Let’s run this!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>❗️ Our lagoon can hold XXXXX m^3 of lava!<br><br>[Done] exited with code=0 in 0.312 seconds</pre>\n<p>We got an answer! 👏</p>\n<p>Let’s put this in puzzle box and see if it is correct:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*xW2m6c1VBdlzp1w5z0rhWw.png\"><figcaption>⭐️</figcaption></figure><p>Here’s our code till now: 🤌</p>\n<pre># Day 18: Lavaduct Lagoon<br><br>from enum import Enum<br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br>dig_plan_to_direction = {<br>    'U': Direction.UP,<br>    'D': Direction.DOWN,<br>    'L': Direction.LEFT,<br>    'R': Direction.RIGHT,<br>}<br><br>LAGOON_DEPTH = 1<br><br>def dig_trench(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_path = [(start_x, start_y)]<br><br>    for direction, distance, color in dig_plan:<br>        direction = dig_plan_to_direction[direction]<br>        for _ in range(int(distance)):<br>            dx, dy = direction.value<br>            start_x, start_y = start_x + dx, start_y + dy<br>            if (start_x, start_y) not in trench_path:<br>                trench_path.append((start_x, start_y))<br><br>    return trench_path<br><br><br>def get_trench_volume(trench_path):<br>    return len(trench_path) * LAGOON_DEPTH<br><br>def get_lagoon_volume(trench_path):<br>    lagoon_area = 0<br><br>    num_trench_tiles = len(trench_path)<br><br>    # Shoelace formula<br>    for i in range(num_trench_tiles):<br>        j = (i + 1) % num_trench_tiles<br><br>        lagoon_area += trench_path[i][0] * trench_path[j][1]<br>        lagoon_area -= trench_path[j][0] * trench_path[i][1]<br><br>    lagoon_area = abs(lagoon_area) / 2.0<br>    num_lagoon_tiles = lagoon_area - num_trench_tiles // 2 + 1<br><br>    return int((num_lagoon_tiles + num_trench_tiles) * LAGOON_DEPTH)<br><br>def test_lavaduct_lagoon():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split('\\n')]<br>    trench_path = dig_trench(dig_plan)<br>    trench_volume = get_trench_volume(trench_path)<br>    assert trench_volume == 38, f\"Expected 38, got {trench_volume}\"<br>    print(\"✅ get_trench_volume passed\")<br><br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    assert lagoon_volume == 62, f\"Expected 62, got {lagoon_volume}\"<br>    print(\"✅ get_lagoon_volume passed\")<br><br>def part_one():<br>    with open('day_18/input.txt', 'r') as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_path = dig_trench(dig_plan)<br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    print(f\"❗️ Our lagoon can hold {lagoon_volume} m^3 of lava!\")<br><br>if __name__ == \"__main__\":<br>    test_lavaduct_lagoon()<br>    part_one()</pre>\n<h4>Part Two</h4>\n<blockquote>The Elves were right to be concerned; the planned lagoon would be much too small.</blockquote>\n<blockquote>After a few minutes, someone realizes what happened; someone swapped the color and instruction parameters when producing the dig plan. They don’t have time to fix the bug; one of them asks if you can extract the correct instructions from the hexadecimal codes.</blockquote>\n<blockquote>Each hexadecimal code is six hexadecimal digits long. The first five hexadecimal digits encode the distance in meters as a five-digit hexadecimal number. The last hexadecimal digit encodes the direction to dig: 0 means R, 1 means D, 2 means L, and 3 means U.</blockquote>\n<blockquote>So, in the above example, the hexadecimal codes can be converted into the true instructions:</blockquote>\n<blockquote>#70c710 = R 461937</blockquote>\n<blockquote>#0dc571 = D 56407</blockquote>\n<blockquote>#5713f0 = R 356671</blockquote>\n<blockquote>#d2c081 = D 863240</blockquote>\n<blockquote>#59c680 = R 367720</blockquote>\n<blockquote>#411b91 = D 266681</blockquote>\n<blockquote>#8ceee2 = L 577262</blockquote>\n<blockquote>#caa173 = U 829975</blockquote>\n<blockquote>#1b58a2 = L 112010</blockquote>\n<blockquote>#caa171 = D 829975</blockquote>\n<blockquote>#7807d2 = L 491645</blockquote>\n<blockquote>#a77fa3 = U 686074</blockquote>\n<blockquote>#015232 = L 5411</blockquote>\n<blockquote>#7a21e3 = U 500254</blockquote>\n<blockquote>Digging out this loop and its interior produces a lagoon that can hold an impressive 952408144115 cubic meters of lava.</blockquote>\n<blockquote>Convert the hexadecimal color codes into the correct instructions; if the Elves follow this new dig plan, how many cubic meters of lava could the lagoon hold?</blockquote>\n<p>Well, seems like the lagoon won’t hold all the lava!</p>\n<p>Ofcourse, <strong>someone swapped</strong> the color and instruction parameters when producing the dig plan. 😪</p>\n<p>Seems like we will need to extract instruction from what we thought to be hex codes for the colors first! Something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/676/1*VdFd0RBCbNemiI0tZwVnvA.png\"><figcaption>The new instruction set!</figcaption></figure><p>Well, looks like this might increase the scope of calculations, but good thing is that we were able to reduce this from a 2D Grid to a mathematical problem only!</p>\n<p>I am pretty confident that our solution will scale, all we need to update is our parsing criteria!</p>\n<p>First things first, let’s create another map to help us map the new dig directions:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/295/1*HB20p540oJVUmCx_MkTo5A.png\"></figure><p>We can now implement a new function — dig_trench_hex() which will parse the hexcode part of the input and then use it to create trench_path</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/739/1*cWSOsvUH0WgtAyYLoHJofw.png\"></figure><p>Rest of the methods should be same more or less! Now let’s test our new code against the base test case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/983/1*Mci6SCz52FwV1jPY2M5Zdw.png\"></figure><p>While using the debugger, I can see the <a href=\"https://en.wikipedia.org/wiki/Achilles%27_heel\">achilles heel</a> of our code:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Z1HTTDMj5XhTkjvBmy7jRA.png\"><figcaption>15 minutes later</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*RAFgO9VU5MW-yimPlsNiMg.png\"><figcaption>We have still not completed the first hex code in the test input 😅</figcaption></figure><p>We need to rethink our approach as clearly we can’t have a trench path list with millions of enteries, it’s just not efficient as the larger a list becomes, the slower list operations become!</p>\n<p>While we can have a band aid solution by trying numpy or pandas but I want to solve this using stdio itself.</p>\n<p>Let’s think again! The bottleneck here is trying to generate these insanely long dig paths, what if we could just store the (start_x, start_y), (end_x, end_y) and use that to calculate everything else arithematically?</p>\n<p>As anyway we just need the length of path to calculate the volume initially! The volume of lagoon might get tricky as we usually need vertex (cordinates) of the path, but we will figure that once we have the ranges for trench_path?!</p>\n<p>Intoducing TrenchLine which is a subset of trench_path which simply calculates the end_x, end_y based on the direction and distance!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/894/1*sgd0eW_K7pbY3rMhKvK_Sg.png\"></figure><p>So, by changing our code and running it again, we can observe that we have a trench_path_ranges list with TrenchLine objects storing the range and direction for each dig line:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*H5dtVzMvL_a7cxqok62i6g.png\"><figcaption>13 opearions, 13 lines with trench starting from 0, 0 and ending on 0, 0</figcaption></figure><p>So, now that we have this, we can easily calculate the volume of trench as well:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/548/1*dshSaO-W2rADuFstcKxZhQ.png\"></figure><p>Now, coming to lagoon, this gets a little tricky!</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<blockquote>OH! EUREKA!</blockquote>\n<p>See, for Shoelace’s algorith we don’t really need each and every point on the path of the polygon! All we care is about the vertex nodes which incidentally we have captured in our trench_path_ranges</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/569/1*0RrqGDMaA1wdU7qQJZQxmw.png\"></figure><p>We can simplify transform this into a list of vertexes for the polygon by doing:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/887/1*3agE2DWTCw8KX3X7QMauew.png\"></figure><p>which gives us:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/613/1*wlO3XeXUM0LBwF-QSBd2Bg.png\"><figcaption>A list of 15 points encolsing our huge lagoon!</figcaption></figure><p>Now we can just use the same shoelace’s formula to solve this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/807/1*jgSOTbBkPLb1j8K5GVVXiQ.png\"></figure><p>Let’s run the base test case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/915/1*K8GJ16K5-uXZlS7JPNHDNg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>✅ get_trench_volume passed<br>✅ get_lagoon_volume passed<br><br>[Done] exited with code=0 in 0.256 seconds</pre>\n<p>Woohoo! Let’s load up our puzzle input and get the answer for part 2:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>❗️❗️ Our lagoon can actually hold XXXXXXXXXXXXXXX m^3 of lava!<br><br>[Done] exited with code=0 in 0.241 seconds</pre>\n<p>That is actually a longboi answer! But we were able to get it in just <strong>0.241</strong> seconds!</p>\n<p>Let’s put this in our answer box and check if this is correct:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*vWoJSGWsHgvlMBkM2mZP7A.png\"><figcaption>🌟</figcaption></figure><p>Here’s my rough code till now with a lot of repeated chunks:</p>\n<pre># Day 18: Lavaduct Lagoon<br><br>from enum import Enum<br><br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br>dig_plan_to_direction = {<br>    \"U\": Direction.UP,<br>    \"D\": Direction.DOWN,<br>    \"L\": Direction.LEFT,<br>    \"R\": Direction.RIGHT,<br>}<br><br>hex_to_directions = {<br>    \"0\": Direction.RIGHT,<br>    \"1\": Direction.DOWN,<br>    \"2\": Direction.LEFT,<br>    \"3\": Direction.UP,<br>}<br><br>LAGOON_DEPTH = 1<br><br><br>class TrenchLine:<br>    def __init__(self, start_x, start_y, direction, distance):<br>        self.start_x = start_x<br>        self.start_y = start_y<br>        self.direction = direction<br>        self.distance = distance<br><br>        self.end_x = self.start_x + self.direction.value[0] * self.distance<br>        self.end_y = self.start_y + self.direction.value[1] * self.distance<br><br>    def __repr__(self):<br>        return f\"({self.start_x}, {self.start_y}) -&gt; ({self.end_x}, {self.end_y})\"<br><br><br>def dig_trench_simple(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_path = [(start_x, start_y)]<br><br>    for direction, distance, hexcode in dig_plan:<br>        direction = dig_plan_to_direction[direction]<br>        for _ in range(int(distance)):<br>            dx, dy = direction.value<br>            start_x, start_y = start_x + dx, start_y + dy<br>            if (start_x, start_y) not in trench_path:<br>                trench_path.append((start_x, start_y))<br><br>    return trench_path<br><br><br>def parse_hex(hex_code):<br>    # remove parentheses<br>    hex_code = hex_code[1:-1]<br>    # remove hash<br>    hex_code = hex_code[1:]<br><br>    # split into dig_distance(5 chars), dig_direction(last char)<br>    dig_distance_hex, dig_direction_hex = hex_code[:-1], hex_code[-1]<br><br>    # convert dig_distance_hex to decimal<br>    dig_distance = int(dig_distance_hex, 16)<br>    # convert dig_direction_hex to direction<br>    dig_direction = hex_to_directions[dig_direction_hex]<br><br>    return dig_distance, dig_direction<br><br><br>def dig_trench_hex(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_path_ranges = []<br><br>    for _, _, hex_code in dig_plan:<br>        dig_distance, dig_direction = parse_hex(hex_code)<br>        trench_line = TrenchLine(start_x, start_y, dig_direction, dig_distance)<br>        trench_path_ranges.append(trench_line)<br>        start_x, start_y = trench_line.end_x, trench_line.end_y<br><br>    return trench_path_ranges<br><br><br>def get_trench_volume_hex(trench_path_ranges):<br>    trench_area = 0<br><br>    for trench_line in trench_path_ranges:<br>        trench_area += trench_line.distance<br><br>    return trench_area * LAGOON_DEPTH<br><br><br>def create_polygon_from_trench_lines(trench_path_ranges):<br>    # Assuming the trench path forms a simple, closed loop<br>    polygon_points = [(line.start_x, line.start_y) for line in trench_path_ranges]<br>    polygon_points.append(<br>        (trench_path_ranges[-1].end_x, trench_path_ranges[-1].end_y)<br>    )  # Closing the loop<br>    return polygon_points<br><br><br>def get_lagoon_volume_hex(trench_path_ranges):<br>    trench_volume = get_trench_volume_hex(trench_path_ranges)<br>    polygon_points = create_polygon_from_trench_lines(trench_path_ranges)<br><br>    num_of_vertex = len(polygon_points)<br>    lagoon_area = 0.0<br><br>    for i in range(num_of_vertex):<br>        j = (i + 1) % num_of_vertex<br>        lagoon_area += polygon_points[i][0] * polygon_points[j][1]<br>        lagoon_area -= polygon_points[j][0] * polygon_points[i][1]<br><br>    lagoon_area = abs(lagoon_area) / 2.0<br><br>    num_lagoon_tiles = lagoon_area - trench_volume // 2 + 1<br><br>    return int((num_lagoon_tiles + trench_volume) * LAGOON_DEPTH)<br><br><br>def get_trench_volume(trench_path):<br>    return len(trench_path) * LAGOON_DEPTH<br><br><br>def get_lagoon_volume(trench_path):<br>    lagoon_area = 0<br><br>    num_trench_tiles = len(trench_path)<br><br>    # Shoelace formula<br>    for i in range(num_trench_tiles):<br>        j = (i + 1) % num_trench_tiles<br><br>        lagoon_area += trench_path[i][0] * trench_path[j][1]<br>        lagoon_area -= trench_path[j][0] * trench_path[i][1]<br><br>    lagoon_area = abs(lagoon_area) / 2.0<br>    num_lagoon_tiles = lagoon_area - num_trench_tiles // 2 + 1<br><br>    return int((num_lagoon_tiles + num_trench_tiles) * LAGOON_DEPTH)<br><br><br>def test_lavaduct_lagoon():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_path = dig_trench_simple(dig_plan)<br>    trench_volume = get_trench_volume(trench_path)<br>    assert trench_volume == 38, f\"Expected 38, got {trench_volume}\"<br>    print(\"✅ get_trench_volume passed\")<br><br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    assert lagoon_volume == 62, f\"Expected 62, got {lagoon_volume}\"<br>    print(\"✅ get_lagoon_volume passed\")<br><br><br>def test_lavaduct_lagoon_hex():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_path_ranges = dig_trench_hex(dig_plan)<br>    trench_volume = get_trench_volume_hex(trench_path_ranges)<br>    assert trench_volume == 6405262, f\"Expected 6405262, got {trench_volume}\"<br>    print(\"✅ get_trench_volume passed\")<br><br>    lagoon_volume = get_lagoon_volume_hex(trench_path_ranges)<br>    assert lagoon_volume == 952408144115, f\"Expected 952408144115, got {lagoon_volume}\"<br>    print(\"✅ get_lagoon_volume passed\")<br><br><br>def part_one():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_path = dig_trench_simple(dig_plan)<br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    print(f\"❗️ Our lagoon can hold {lagoon_volume} m^3 of lava!\")<br><br>def part_two():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_path_ranges = dig_trench_hex(dig_plan)<br>    lagoon_volume = get_lagoon_volume_hex(trench_path_ranges)<br>    print(f\"❗️❗️ Our lagoon can actually hold {lagoon_volume} m^3 of lava!\")<br><br><br>if __name__ == \"__main__\":<br>    # test_lavaduct_lagoon()<br>    # part_one()<br><br>    # test_lavaduct_lagoon_hex()<br>    part_two()</pre>\n<blockquote>Man! This felt really good. Time complexity optimizations are just black magic!</blockquote>\n<p>I see a couple of improvements in my code to make it even faster, let me do that and then share the pythonic code with you:</p>\n<pre># Day 18: Lavaduct Lagoon<br><br>from enum import Enum<br><br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br>dig_plan_to_direction = {<br>    \"U\": Direction.UP,<br>    \"D\": Direction.DOWN,<br>    \"L\": Direction.LEFT,<br>    \"R\": Direction.RIGHT,<br>}<br><br>class TrenchLine:<br>    hex_to_directions = {<br>        \"0\": Direction.RIGHT,<br>        \"1\": Direction.DOWN,<br>        \"2\": Direction.LEFT,<br>        \"3\": Direction.UP,<br>    }<br><br>    def __init__(self, start_x, start_y, direction, distance):<br>        self.start_x = start_x<br>        self.start_y = start_y<br>        self.direction = direction<br>        self.distance = distance<br>        self.end_x, self.end_y = self.calculate_end_coordinates()<br><br>    def calculate_end_coordinates(self):<br>        return (<br>            self.start_x + self.direction.value[0] * self.distance,<br>            self.start_y + self.direction.value[1] * self.distance,<br>        )<br><br>    def __repr__(self):<br>        return f\"({self.start_x}, {self.start_y}) -&gt; ({self.end_x}, {self.end_y})\"<br><br>    @staticmethod<br>    def from_hex_code(start_x, start_y, hex_code):<br>        hex_code = hex_code[1:-1][1:]<br>        dig_distance = int(hex_code[:-1], 16)<br>        dig_direction_hex = hex_code[-1]<br>        dig_direction = TrenchLine.hex_to_directions[<br>            dig_direction_hex<br>        ] <br>        return TrenchLine(start_x, start_y, dig_direction, dig_distance)<br><br><br>class Lagoon:<br>    DEPTH = 1<br><br>    @staticmethod<br>    def get_trench_volume(trench_lines):<br>        return sum(line.distance for line in trench_lines) * Lagoon.DEPTH<br><br>    @staticmethod<br>    def get_lagoon_volume(trench_lines):<br>        polygon_points = [(line.start_x, line.start_y) for line in trench_lines] + [<br>            (trench_lines[-1].end_x, trench_lines[-1].end_y)<br>        ]<br>        lagoon_area = abs(<br>            sum(<br>                polygon_points[i][0] * polygon_points[(i + 1) % len(polygon_points)][1]<br>                - polygon_points[(i + 1) % len(polygon_points)][0]<br>                * polygon_points[i][1]<br>                for i in range(len(polygon_points))<br>            )<br>            / 2.0<br>        )<br>        num_lagoon_tiles = lagoon_area - Lagoon.get_trench_volume(trench_lines) // 2 + 1<br>        return int(<br>            (num_lagoon_tiles + Lagoon.get_trench_volume(trench_lines)) * Lagoon.DEPTH<br>        )<br><br><br>def dig_trench_simple(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_lines = []<br><br>    for direction_key, distance, _ in dig_plan:<br>        direction = dig_plan_to_direction[<br>            direction_key<br>        ] <br>        trench_line = TrenchLine(start_x, start_y, direction, int(distance))<br>        trench_lines.append(trench_line)<br>        start_x, start_y = trench_line.end_x, trench_line.end_y<br><br>    return trench_lines<br><br><br>def dig_trench_hex(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_lines = []<br><br>    for _, _, hex_code in dig_plan:<br>        trench_line = TrenchLine.from_hex_code(start_x, start_y, hex_code)<br>        trench_lines.append(trench_line)<br>        start_x, start_y = trench_line.end_x, trench_line.end_y<br><br>    return trench_lines<br><br><br>def test_lavaduct_lagoon():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_lines = dig_trench_simple(dig_plan)<br>    trench_volume = Lagoon.get_trench_volume(trench_lines)<br>    assert trench_volume == 38, f\"Expected 38, got {trench_volume}\"<br>    print(\"✅ get_trench_volume passed\")<br><br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    assert lagoon_volume == 62, f\"Expected 62, got {lagoon_volume}\"<br>    print(\"✅ get_lagoon_volume passed\")<br><br><br>def test_lavaduct_lagoon_hex():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_lines = dig_trench_hex(dig_plan)<br>    trench_volume = Lagoon.get_trench_volume(trench_lines)<br>    assert trench_volume == 6405262, f\"Expected 6405262, got {trench_volume}\"<br>    print(\"✅ get_trench_volume passed\")<br><br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    assert lagoon_volume == 952408144115, f\"Expected 952408144115, got {lagoon_volume}\"<br>    print(\"✅ get_lagoon_volume passed\")<br><br><br>def part_one():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_lines = dig_trench_simple(dig_plan)<br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    print(f\"❗️ Our lagoon can hold {lagoon_volume} m^3 of lava!\")<br><br><br>def part_two():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_lines = dig_trench_hex(dig_plan)<br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    print(f\"❗️❗️ Our lagoon can actually hold {lagoon_volume} m^3 of lava!\")<br><br><br>if __name__ == \"__main__\":<br>    test_lavaduct_lagoon()<br>    test_lavaduct_lagoon_hex()<br>    part_one()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine 👇</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! 🎄</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f9413538d1d1\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*lYtv2QgDM5vbpmoV\"><figcaption>Lavaduct Lagoon (via DALL-E 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/18\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>Thanks to your efforts, the machine parts factory is one of the first factories up and running since the lavafall came back. However, to catch up with the large backlog of parts requests, the factory will also need a large supply of lava for a while; the Elves have already started creating a large lagoon nearby for this purpose.</blockquote>\n<blockquote>However, they aren’t sure the lagoon will be big enough; they’ve asked you to take a look at the dig plan (your puzzle input). For example:</blockquote>\n<blockquote>R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)</blockquote>\n<blockquote>The digger starts in a 1 meter cube hole in the ground. They then dig the specified number of meters up (U), down (D), left (L), or right (R), clearing full 1 meter cubes as they go. The directions are given as seen from above, so if \"up\" were north, then \"right\" would be east, and so on. Each trench is also listed with the color that the edge of the trench should be painted as an <a href=\"https://en.wikipedia.org/wiki/RGB_color_model#Numeric_representations\">RGB hexadecimal color code</a>.</blockquote>\n<blockquote>When viewed from above, the above example dig plan would result in the following loop of trench (#) having been dug out from otherwise ground-level terrain (.):</blockquote>\n<blockquote>#######<br>#.....#<br>###...#<br>..#...#<br>..#...#<br>###.###<br>#...#..<br>##..###<br>.#....#<br>.######</blockquote>\n<blockquote>At this point, the trench could contain 38 cubic meters of lava. However, this is just the edge of the lagoon; the next step is to dig out the interior so that it is one meter deep as well:</blockquote>\n<blockquote>#######<br>#######<br>#######<br>..#####<br>..#####<br>#######<br>#####..<br>#######<br>.######<br>.######</blockquote>\n<blockquote>Now, the lagoon can contain a much more respectable 62 cubic meters of lava. While the interior is dug out, the edges are also painted according to the color codes in the dig plan.</blockquote>\n<blockquote>The Elves are concerned the lagoon won’t be large enough; if they follow their dig plan, how many cubic meters of lava could it hold?</blockquote>\n<p>So, we are given a dig plan for the lagoon, which looks like this:</p>\n<pre>R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)</pre>\n<p>So, this basically works in 3 steps:</p>\n<ol>\n<li>\n<strong>Dig</strong> the trenches as per each row of dig plan</li>\n<li>\n<strong>Paint</strong> the edges of trenches as per the dig plan</li>\n<li>\n<strong>Dig</strong> enclosed area by trench loop to form a lagoon</li>\n</ol>\n<p>We can understand this better with the following visualization I created for my own understanding:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*i0i1AiTNlNCOPpdzXIQR2g.png\"><figcaption>Visualizations make everything simple!</figcaption></figure><blockquote>The Elves are concerned the lagoon won’t be large enough; if they follow their dig plan, how many cubic meters of lava could it hold?</blockquote>\n<p>Got it! So, let’s follow our visualization and write some code with the base test case!</p>\n<blockquote>💡I don’t see any use of RGB hexcodes for now, so we will park that. We may need it in part 2.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/785/1*AVtJDen82jr1JNBixsd3uA.png\"></figure><p>Let’s start one by one! First step is to implement dig_trench()</p>\n<blockquote>❗️A caveat I can observe is that we don’t really know the size of the site! All we know is that digger starts in a 1 meter cube hole in the ground.</blockquote>\n<p>Assuming we start from (0, 0) our size will depend on how much further RIGHT and DOWN we go! Something like row, col = max(DOWN), max(RIGHT) , we will figure out that.</p>\n<p>Now, to parse dig_plan, we can just define:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/354/1*Jps0cV06YMfgT5Tqz9QQnw.png\"></figure><p>And then, we can just iterate over the dig_plan and store the path in trench_path as a list of cordinates:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/627/1*wmxMcP44a-2UAdzWBa4sCQ.png\"></figure><p>Our trench_path may have duplicate nodes based on our dig plan, so since each node is just 1 m³ deep, we can calculate it’s volume by just returning len(set(trench_path)) !</p>\n<p>Let’s verify if this is correct, modifying our base test case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/761/1*eL1jyYxJczzbJPmcvMd75g.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>✅ get_trench_volume passed<br><br>[Done] exited with code=0 in 0.236 seconds</pre>\n<p>Perfect, now let’s implement dig_lagoon to convert our trench_path loop into a lagoon_area !</p>\n<p>💭 So, whenver we have to find tiles enclosed within a loop, the best way I know to do so is to do the<strong> Flood Fill</strong> algorithm! It works something like:</p>\n<ul>\n<li>start from 1 point inside the loop</li>\n<li>use flood fill algorithm from this starting point to fill all reachable tiles</li>\n<li>it starts at a tile, then recursively fills adjacent tiles until it hits the boundary (the trench_path in this case).</li>\n<li>as the flood fill algorithm visits each tile, store these tiles in a set — lagoon_area</li>\n</ul>\n<p>Here’s a quick visualization for this example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*bnnAGlPqXtpppKsPzmvURA.gif\"><figcaption>Flood fill for the base case</figcaption></figure><p>But wait! We have seen this before! Remember Day 10?</p>\n<p><a href=\"https://medium.com/@jatinkrmalik/wip-day-10-pipe-maze-advent-of-code-2023-python-2a4c8622707f\">[WIP][Day 10] Pipe Maze // Advent of Code 2023 (Python)</a></p>\n<p>We had exactly the same problem, but here instead of area, we have to calculate the volume, but given the depth == 1 m³, the answer shall be equivalent to the area itself!</p>\n<p>We can similarly use:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Shoelace_formula\">Shoelace formula - Wikipedia</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Pick%27s_theorem\">Pick's theorem - Wikipedia</a></li>\n</ul>\n<p>And get number of tiles enclosed within trench_loop and then calculate lagoon’s volume!</p>\n<p>Let’s experiment with that one first!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/723/1*0X6R6Zq9uPP_KEStV73VsA.png\"></figure><p>And…running our test case now:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/727/1*3v815OPcZBhBXIDl31G7sQ.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>✅ get_trench_volume passed<br>✅ get_lagoon_volume passed<br><br>[Done] exited with code=0 in 0.305 seconds</pre>\n<p>Boom! Our hypothesis was correct, as we didn’t have to do the flood fill and Shoelace’s formula came to the rescue!</p>\n<p>Let’s load up our puzzle input and see if it works!</p>\n<blockquote>❗️The only caveat with Shoelace’s formula is that it works for simple, non-intersecting polygon! <strong><em>That may cause a problem!</em></strong>\n</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/706/1*ivfOVbq9KCimj91BwYCg2A.png\"></figure><p>Let’s run this!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>❗️ Our lagoon can hold XXXXX m^3 of lava!<br><br>[Done] exited with code=0 in 0.312 seconds</pre>\n<p>We got an answer! 👏</p>\n<p>Let’s put this in puzzle box and see if it is correct:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*xW2m6c1VBdlzp1w5z0rhWw.png\"><figcaption>⭐️</figcaption></figure><p>Here’s our code till now: 🤌</p>\n<pre># Day 18: Lavaduct Lagoon<br><br>from enum import Enum<br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br>dig_plan_to_direction = {<br>    'U': Direction.UP,<br>    'D': Direction.DOWN,<br>    'L': Direction.LEFT,<br>    'R': Direction.RIGHT,<br>}<br><br>LAGOON_DEPTH = 1<br><br>def dig_trench(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_path = [(start_x, start_y)]<br><br>    for direction, distance, color in dig_plan:<br>        direction = dig_plan_to_direction[direction]<br>        for _ in range(int(distance)):<br>            dx, dy = direction.value<br>            start_x, start_y = start_x + dx, start_y + dy<br>            if (start_x, start_y) not in trench_path:<br>                trench_path.append((start_x, start_y))<br><br>    return trench_path<br><br><br>def get_trench_volume(trench_path):<br>    return len(trench_path) * LAGOON_DEPTH<br><br>def get_lagoon_volume(trench_path):<br>    lagoon_area = 0<br><br>    num_trench_tiles = len(trench_path)<br><br>    # Shoelace formula<br>    for i in range(num_trench_tiles):<br>        j = (i + 1) % num_trench_tiles<br><br>        lagoon_area += trench_path[i][0] * trench_path[j][1]<br>        lagoon_area -= trench_path[j][0] * trench_path[i][1]<br><br>    lagoon_area = abs(lagoon_area) / 2.0<br>    num_lagoon_tiles = lagoon_area - num_trench_tiles // 2 + 1<br><br>    return int((num_lagoon_tiles + num_trench_tiles) * LAGOON_DEPTH)<br><br>def test_lavaduct_lagoon():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split('\\n')]<br>    trench_path = dig_trench(dig_plan)<br>    trench_volume = get_trench_volume(trench_path)<br>    assert trench_volume == 38, f\"Expected 38, got {trench_volume}\"<br>    print(\"✅ get_trench_volume passed\")<br><br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    assert lagoon_volume == 62, f\"Expected 62, got {lagoon_volume}\"<br>    print(\"✅ get_lagoon_volume passed\")<br><br>def part_one():<br>    with open('day_18/input.txt', 'r') as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_path = dig_trench(dig_plan)<br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    print(f\"❗️ Our lagoon can hold {lagoon_volume} m^3 of lava!\")<br><br>if __name__ == \"__main__\":<br>    test_lavaduct_lagoon()<br>    part_one()</pre>\n<h4>Part Two</h4>\n<blockquote>The Elves were right to be concerned; the planned lagoon would be much too small.</blockquote>\n<blockquote>After a few minutes, someone realizes what happened; someone swapped the color and instruction parameters when producing the dig plan. They don’t have time to fix the bug; one of them asks if you can extract the correct instructions from the hexadecimal codes.</blockquote>\n<blockquote>Each hexadecimal code is six hexadecimal digits long. The first five hexadecimal digits encode the distance in meters as a five-digit hexadecimal number. The last hexadecimal digit encodes the direction to dig: 0 means R, 1 means D, 2 means L, and 3 means U.</blockquote>\n<blockquote>So, in the above example, the hexadecimal codes can be converted into the true instructions:</blockquote>\n<blockquote>#70c710 = R 461937</blockquote>\n<blockquote>#0dc571 = D 56407</blockquote>\n<blockquote>#5713f0 = R 356671</blockquote>\n<blockquote>#d2c081 = D 863240</blockquote>\n<blockquote>#59c680 = R 367720</blockquote>\n<blockquote>#411b91 = D 266681</blockquote>\n<blockquote>#8ceee2 = L 577262</blockquote>\n<blockquote>#caa173 = U 829975</blockquote>\n<blockquote>#1b58a2 = L 112010</blockquote>\n<blockquote>#caa171 = D 829975</blockquote>\n<blockquote>#7807d2 = L 491645</blockquote>\n<blockquote>#a77fa3 = U 686074</blockquote>\n<blockquote>#015232 = L 5411</blockquote>\n<blockquote>#7a21e3 = U 500254</blockquote>\n<blockquote>Digging out this loop and its interior produces a lagoon that can hold an impressive 952408144115 cubic meters of lava.</blockquote>\n<blockquote>Convert the hexadecimal color codes into the correct instructions; if the Elves follow this new dig plan, how many cubic meters of lava could the lagoon hold?</blockquote>\n<p>Well, seems like the lagoon won’t hold all the lava!</p>\n<p>Ofcourse, <strong>someone swapped</strong> the color and instruction parameters when producing the dig plan. 😪</p>\n<p>Seems like we will need to extract instruction from what we thought to be hex codes for the colors first! Something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/676/1*VdFd0RBCbNemiI0tZwVnvA.png\"><figcaption>The new instruction set!</figcaption></figure><p>Well, looks like this might increase the scope of calculations, but good thing is that we were able to reduce this from a 2D Grid to a mathematical problem only!</p>\n<p>I am pretty confident that our solution will scale, all we need to update is our parsing criteria!</p>\n<p>First things first, let’s create another map to help us map the new dig directions:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/295/1*HB20p540oJVUmCx_MkTo5A.png\"></figure><p>We can now implement a new function — dig_trench_hex() which will parse the hexcode part of the input and then use it to create trench_path</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/739/1*cWSOsvUH0WgtAyYLoHJofw.png\"></figure><p>Rest of the methods should be same more or less! Now let’s test our new code against the base test case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/983/1*Mci6SCz52FwV1jPY2M5Zdw.png\"></figure><p>While using the debugger, I can see the <a href=\"https://en.wikipedia.org/wiki/Achilles%27_heel\">achilles heel</a> of our code:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Z1HTTDMj5XhTkjvBmy7jRA.png\"><figcaption>15 minutes later</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*RAFgO9VU5MW-yimPlsNiMg.png\"><figcaption>We have still not completed the first hex code in the test input 😅</figcaption></figure><p>We need to rethink our approach as clearly we can’t have a trench path list with millions of enteries, it’s just not efficient as the larger a list becomes, the slower list operations become!</p>\n<p>While we can have a band aid solution by trying numpy or pandas but I want to solve this using stdio itself.</p>\n<p>Let’s think again! The bottleneck here is trying to generate these insanely long dig paths, what if we could just store the (start_x, start_y), (end_x, end_y) and use that to calculate everything else arithematically?</p>\n<p>As anyway we just need the length of path to calculate the volume initially! The volume of lagoon might get tricky as we usually need vertex (cordinates) of the path, but we will figure that once we have the ranges for trench_path?!</p>\n<p>Intoducing TrenchLine which is a subset of trench_path which simply calculates the end_x, end_y based on the direction and distance!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/894/1*sgd0eW_K7pbY3rMhKvK_Sg.png\"></figure><p>So, by changing our code and running it again, we can observe that we have a trench_path_ranges list with TrenchLine objects storing the range and direction for each dig line:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*H5dtVzMvL_a7cxqok62i6g.png\"><figcaption>13 opearions, 13 lines with trench starting from 0, 0 and ending on 0, 0</figcaption></figure><p>So, now that we have this, we can easily calculate the volume of trench as well:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/548/1*dshSaO-W2rADuFstcKxZhQ.png\"></figure><p>Now, coming to lagoon, this gets a little tricky!</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<blockquote>OH! EUREKA!</blockquote>\n<p>See, for Shoelace’s algorith we don’t really need each and every point on the path of the polygon! All we care is about the vertex nodes which incidentally we have captured in our trench_path_ranges</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/569/1*0RrqGDMaA1wdU7qQJZQxmw.png\"></figure><p>We can simplify transform this into a list of vertexes for the polygon by doing:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/887/1*3agE2DWTCw8KX3X7QMauew.png\"></figure><p>which gives us:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/613/1*wlO3XeXUM0LBwF-QSBd2Bg.png\"><figcaption>A list of 15 points encolsing our huge lagoon!</figcaption></figure><p>Now we can just use the same shoelace’s formula to solve this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/807/1*jgSOTbBkPLb1j8K5GVVXiQ.png\"></figure><p>Let’s run the base test case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/915/1*K8GJ16K5-uXZlS7JPNHDNg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>✅ get_trench_volume passed<br>✅ get_lagoon_volume passed<br><br>[Done] exited with code=0 in 0.256 seconds</pre>\n<p>Woohoo! Let’s load up our puzzle input and get the answer for part 2:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_18/lavaduct_lagoon.py\"<br>❗️❗️ Our lagoon can actually hold XXXXXXXXXXXXXXX m^3 of lava!<br><br>[Done] exited with code=0 in 0.241 seconds</pre>\n<p>That is actually a longboi answer! But we were able to get it in just <strong>0.241</strong> seconds!</p>\n<p>Let’s put this in our answer box and check if this is correct:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*vWoJSGWsHgvlMBkM2mZP7A.png\"><figcaption>🌟</figcaption></figure><p>Here’s my rough code till now with a lot of repeated chunks:</p>\n<pre># Day 18: Lavaduct Lagoon<br><br>from enum import Enum<br><br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br>dig_plan_to_direction = {<br>    \"U\": Direction.UP,<br>    \"D\": Direction.DOWN,<br>    \"L\": Direction.LEFT,<br>    \"R\": Direction.RIGHT,<br>}<br><br>hex_to_directions = {<br>    \"0\": Direction.RIGHT,<br>    \"1\": Direction.DOWN,<br>    \"2\": Direction.LEFT,<br>    \"3\": Direction.UP,<br>}<br><br>LAGOON_DEPTH = 1<br><br><br>class TrenchLine:<br>    def __init__(self, start_x, start_y, direction, distance):<br>        self.start_x = start_x<br>        self.start_y = start_y<br>        self.direction = direction<br>        self.distance = distance<br><br>        self.end_x = self.start_x + self.direction.value[0] * self.distance<br>        self.end_y = self.start_y + self.direction.value[1] * self.distance<br><br>    def __repr__(self):<br>        return f\"({self.start_x}, {self.start_y}) -&gt; ({self.end_x}, {self.end_y})\"<br><br><br>def dig_trench_simple(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_path = [(start_x, start_y)]<br><br>    for direction, distance, hexcode in dig_plan:<br>        direction = dig_plan_to_direction[direction]<br>        for _ in range(int(distance)):<br>            dx, dy = direction.value<br>            start_x, start_y = start_x + dx, start_y + dy<br>            if (start_x, start_y) not in trench_path:<br>                trench_path.append((start_x, start_y))<br><br>    return trench_path<br><br><br>def parse_hex(hex_code):<br>    # remove parentheses<br>    hex_code = hex_code[1:-1]<br>    # remove hash<br>    hex_code = hex_code[1:]<br><br>    # split into dig_distance(5 chars), dig_direction(last char)<br>    dig_distance_hex, dig_direction_hex = hex_code[:-1], hex_code[-1]<br><br>    # convert dig_distance_hex to decimal<br>    dig_distance = int(dig_distance_hex, 16)<br>    # convert dig_direction_hex to direction<br>    dig_direction = hex_to_directions[dig_direction_hex]<br><br>    return dig_distance, dig_direction<br><br><br>def dig_trench_hex(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_path_ranges = []<br><br>    for _, _, hex_code in dig_plan:<br>        dig_distance, dig_direction = parse_hex(hex_code)<br>        trench_line = TrenchLine(start_x, start_y, dig_direction, dig_distance)<br>        trench_path_ranges.append(trench_line)<br>        start_x, start_y = trench_line.end_x, trench_line.end_y<br><br>    return trench_path_ranges<br><br><br>def get_trench_volume_hex(trench_path_ranges):<br>    trench_area = 0<br><br>    for trench_line in trench_path_ranges:<br>        trench_area += trench_line.distance<br><br>    return trench_area * LAGOON_DEPTH<br><br><br>def create_polygon_from_trench_lines(trench_path_ranges):<br>    # Assuming the trench path forms a simple, closed loop<br>    polygon_points = [(line.start_x, line.start_y) for line in trench_path_ranges]<br>    polygon_points.append(<br>        (trench_path_ranges[-1].end_x, trench_path_ranges[-1].end_y)<br>    )  # Closing the loop<br>    return polygon_points<br><br><br>def get_lagoon_volume_hex(trench_path_ranges):<br>    trench_volume = get_trench_volume_hex(trench_path_ranges)<br>    polygon_points = create_polygon_from_trench_lines(trench_path_ranges)<br><br>    num_of_vertex = len(polygon_points)<br>    lagoon_area = 0.0<br><br>    for i in range(num_of_vertex):<br>        j = (i + 1) % num_of_vertex<br>        lagoon_area += polygon_points[i][0] * polygon_points[j][1]<br>        lagoon_area -= polygon_points[j][0] * polygon_points[i][1]<br><br>    lagoon_area = abs(lagoon_area) / 2.0<br><br>    num_lagoon_tiles = lagoon_area - trench_volume // 2 + 1<br><br>    return int((num_lagoon_tiles + trench_volume) * LAGOON_DEPTH)<br><br><br>def get_trench_volume(trench_path):<br>    return len(trench_path) * LAGOON_DEPTH<br><br><br>def get_lagoon_volume(trench_path):<br>    lagoon_area = 0<br><br>    num_trench_tiles = len(trench_path)<br><br>    # Shoelace formula<br>    for i in range(num_trench_tiles):<br>        j = (i + 1) % num_trench_tiles<br><br>        lagoon_area += trench_path[i][0] * trench_path[j][1]<br>        lagoon_area -= trench_path[j][0] * trench_path[i][1]<br><br>    lagoon_area = abs(lagoon_area) / 2.0<br>    num_lagoon_tiles = lagoon_area - num_trench_tiles // 2 + 1<br><br>    return int((num_lagoon_tiles + num_trench_tiles) * LAGOON_DEPTH)<br><br><br>def test_lavaduct_lagoon():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_path = dig_trench_simple(dig_plan)<br>    trench_volume = get_trench_volume(trench_path)<br>    assert trench_volume == 38, f\"Expected 38, got {trench_volume}\"<br>    print(\"✅ get_trench_volume passed\")<br><br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    assert lagoon_volume == 62, f\"Expected 62, got {lagoon_volume}\"<br>    print(\"✅ get_lagoon_volume passed\")<br><br><br>def test_lavaduct_lagoon_hex():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_path_ranges = dig_trench_hex(dig_plan)<br>    trench_volume = get_trench_volume_hex(trench_path_ranges)<br>    assert trench_volume == 6405262, f\"Expected 6405262, got {trench_volume}\"<br>    print(\"✅ get_trench_volume passed\")<br><br>    lagoon_volume = get_lagoon_volume_hex(trench_path_ranges)<br>    assert lagoon_volume == 952408144115, f\"Expected 952408144115, got {lagoon_volume}\"<br>    print(\"✅ get_lagoon_volume passed\")<br><br><br>def part_one():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_path = dig_trench_simple(dig_plan)<br>    lagoon_volume = get_lagoon_volume(trench_path)<br>    print(f\"❗️ Our lagoon can hold {lagoon_volume} m^3 of lava!\")<br><br>def part_two():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_path_ranges = dig_trench_hex(dig_plan)<br>    lagoon_volume = get_lagoon_volume_hex(trench_path_ranges)<br>    print(f\"❗️❗️ Our lagoon can actually hold {lagoon_volume} m^3 of lava!\")<br><br><br>if __name__ == \"__main__\":<br>    # test_lavaduct_lagoon()<br>    # part_one()<br><br>    # test_lavaduct_lagoon_hex()<br>    part_two()</pre>\n<blockquote>Man! This felt really good. Time complexity optimizations are just black magic!</blockquote>\n<p>I see a couple of improvements in my code to make it even faster, let me do that and then share the pythonic code with you:</p>\n<pre># Day 18: Lavaduct Lagoon<br><br>from enum import Enum<br><br><br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br>dig_plan_to_direction = {<br>    \"U\": Direction.UP,<br>    \"D\": Direction.DOWN,<br>    \"L\": Direction.LEFT,<br>    \"R\": Direction.RIGHT,<br>}<br><br>class TrenchLine:<br>    hex_to_directions = {<br>        \"0\": Direction.RIGHT,<br>        \"1\": Direction.DOWN,<br>        \"2\": Direction.LEFT,<br>        \"3\": Direction.UP,<br>    }<br><br>    def __init__(self, start_x, start_y, direction, distance):<br>        self.start_x = start_x<br>        self.start_y = start_y<br>        self.direction = direction<br>        self.distance = distance<br>        self.end_x, self.end_y = self.calculate_end_coordinates()<br><br>    def calculate_end_coordinates(self):<br>        return (<br>            self.start_x + self.direction.value[0] * self.distance,<br>            self.start_y + self.direction.value[1] * self.distance,<br>        )<br><br>    def __repr__(self):<br>        return f\"({self.start_x}, {self.start_y}) -&gt; ({self.end_x}, {self.end_y})\"<br><br>    @staticmethod<br>    def from_hex_code(start_x, start_y, hex_code):<br>        hex_code = hex_code[1:-1][1:]<br>        dig_distance = int(hex_code[:-1], 16)<br>        dig_direction_hex = hex_code[-1]<br>        dig_direction = TrenchLine.hex_to_directions[<br>            dig_direction_hex<br>        ] <br>        return TrenchLine(start_x, start_y, dig_direction, dig_distance)<br><br><br>class Lagoon:<br>    DEPTH = 1<br><br>    @staticmethod<br>    def get_trench_volume(trench_lines):<br>        return sum(line.distance for line in trench_lines) * Lagoon.DEPTH<br><br>    @staticmethod<br>    def get_lagoon_volume(trench_lines):<br>        polygon_points = [(line.start_x, line.start_y) for line in trench_lines] + [<br>            (trench_lines[-1].end_x, trench_lines[-1].end_y)<br>        ]<br>        lagoon_area = abs(<br>            sum(<br>                polygon_points[i][0] * polygon_points[(i + 1) % len(polygon_points)][1]<br>                - polygon_points[(i + 1) % len(polygon_points)][0]<br>                * polygon_points[i][1]<br>                for i in range(len(polygon_points))<br>            )<br>            / 2.0<br>        )<br>        num_lagoon_tiles = lagoon_area - Lagoon.get_trench_volume(trench_lines) // 2 + 1<br>        return int(<br>            (num_lagoon_tiles + Lagoon.get_trench_volume(trench_lines)) * Lagoon.DEPTH<br>        )<br><br><br>def dig_trench_simple(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_lines = []<br><br>    for direction_key, distance, _ in dig_plan:<br>        direction = dig_plan_to_direction[<br>            direction_key<br>        ] <br>        trench_line = TrenchLine(start_x, start_y, direction, int(distance))<br>        trench_lines.append(trench_line)<br>        start_x, start_y = trench_line.end_x, trench_line.end_y<br><br>    return trench_lines<br><br><br>def dig_trench_hex(dig_plan):<br>    start_x, start_y = 0, 0<br>    trench_lines = []<br><br>    for _, _, hex_code in dig_plan:<br>        trench_line = TrenchLine.from_hex_code(start_x, start_y, hex_code)<br>        trench_lines.append(trench_line)<br>        start_x, start_y = trench_line.end_x, trench_line.end_y<br><br>    return trench_lines<br><br><br>def test_lavaduct_lagoon():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_lines = dig_trench_simple(dig_plan)<br>    trench_volume = Lagoon.get_trench_volume(trench_lines)<br>    assert trench_volume == 38, f\"Expected 38, got {trench_volume}\"<br>    print(\"✅ get_trench_volume passed\")<br><br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    assert lagoon_volume == 62, f\"Expected 62, got {lagoon_volume}\"<br>    print(\"✅ get_lagoon_volume passed\")<br><br><br>def test_lavaduct_lagoon_hex():<br>    input_str = \"\"\"R 6 (#70c710)<br>D 5 (#0dc571)<br>L 2 (#5713f0)<br>D 2 (#d2c081)<br>R 2 (#59c680)<br>D 2 (#411b91)<br>L 5 (#8ceee2)<br>U 2 (#caa173)<br>L 1 (#1b58a2)<br>U 2 (#caa171)<br>R 2 (#7807d2)<br>U 3 (#a77fa3)<br>L 2 (#015232)<br>U 2 (#7a21e3)\"\"\"<br><br>    dig_plan = [line.split() for line in input_str.split(\"\\n\")]<br>    trench_lines = dig_trench_hex(dig_plan)<br>    trench_volume = Lagoon.get_trench_volume(trench_lines)<br>    assert trench_volume == 6405262, f\"Expected 6405262, got {trench_volume}\"<br>    print(\"✅ get_trench_volume passed\")<br><br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    assert lagoon_volume == 952408144115, f\"Expected 952408144115, got {lagoon_volume}\"<br>    print(\"✅ get_lagoon_volume passed\")<br><br><br>def part_one():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_lines = dig_trench_simple(dig_plan)<br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    print(f\"❗️ Our lagoon can hold {lagoon_volume} m^3 of lava!\")<br><br><br>def part_two():<br>    with open(\"day_18/input.txt\", \"r\") as f:<br>        dig_plan = [line.split() for line in f.readlines()]<br><br>    trench_lines = dig_trench_hex(dig_plan)<br>    lagoon_volume = Lagoon.get_lagoon_volume(trench_lines)<br>    print(f\"❗️❗️ Our lagoon can actually hold {lagoon_volume} m^3 of lava!\")<br><br><br>if __name__ == \"__main__\":<br>    test_lavaduct_lagoon()<br>    test_lavaduct_lagoon_hex()<br>    part_one()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine 👇</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! 🎄</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f9413538d1d1\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "advent-of-code-2023",
        "python",
        "programming",
        "advent-of-code",
        "coding"
      ]
    },
    {
      "title": "[Day 17] Clumsy Crucible // Advent of Code 2023 (Python)",
      "pubDate": "2023-12-26 13:04:20",
      "link": "https://medium.com/@jatinkrmalik/day-17-clumsy-crucible-advent-of-code-2023-python-2aade00ab25e?source=rss-ec576e4b06b0------2",
      "guid": "https://medium.com/p/2aade00ab25e",
      "author": "Jatin K Malik",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*yySJqIpnZupAF8I0\"><figcaption>Clumsy Crucible (via DALL-E 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/17\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>The lava starts flowing rapidly once the Lava Production Facility is operational. As you leave, the reindeer offers you a parachute, allowing you to quickly reach Gear Island.</blockquote>\n<blockquote>As you descend, your bird’s-eye view of Gear Island reveals why you had trouble finding anyone on your way up: half of Gear Island is empty, but the half below you is a giant factory city!</blockquote>\n<blockquote>You land near the gradually-filling pool of lava at the base of your new lavafall. Lavaducts will eventually carry the lava throughout the city, but to make use of it immediately, Elves are loading it into large <a href=\"https://en.wikipedia.org/wiki/Crucible\">crucibles</a> on wheels.</blockquote>\n<blockquote>The crucibles are top-heavy and pushed by hand. Unfortunately, the crucibles become very difficult to steer at high speeds, and so it can be hard to go in a straight line for very long.</blockquote>\n<blockquote>To get Desert Island the machine parts it needs as soon as possible, you’ll need to find the best way to get the crucible from the lava pool to the machine parts factory. To do this, you need to minimize heat loss while choosing a route that doesn’t require the crucible to go in a straight linefor too long.</blockquote>\n<blockquote>Fortunately, the Elves here have a map (your puzzle input) that uses traffic patterns, ambient temperature, and hundreds of other parameters to calculate exactly how much heat loss can be expected for a crucible entering any particular city block.</blockquote>\n<blockquote>For example:</blockquote>\n<blockquote>2413432311323<br>3215453535623<br>3255245654254<br>3446585845452<br>4546657867536<br>1438598798454<br>4457876987766<br>3637877979653<br>4654967986887<br>4564679986453<br>1224686865563<br>2546548887735<br>4322674655533</blockquote>\n<blockquote>Each city block is marked by a single digit that represents the amount of heat loss if the crucible enters that block. The starting point, the lava pool, is the top-left city block; the destination, the machine parts factory, is the bottom-right city block. (Because you already start in the top-left block, you don’t incur that block’s heat loss unless you leave that block and then return to it.)</blockquote>\n<blockquote>Because it is difficult to keep the top-heavy crucible going in a straight line for very long, it can move at most three blocks in a single direction before it must turn 90 degrees left or right. The crucible also can’t reverse direction; after entering each city block, it may only turn left, continue straight, or turn right.</blockquote>\n<blockquote>One way to minimize heat loss is this path:</blockquote>\n<blockquote>2&gt;&gt;34^&gt;&gt;&gt;1323<br>32v&gt;&gt;&gt;35v5623<br>32552456v&gt;&gt;54<br>3446585845v52<br>4546657867v&gt;6<br>14385987984v4<br>44578769877v6<br>36378779796v&gt;<br>465496798688v<br>456467998645v<br>12246868655&lt;v<br>25465488877v5<br>43226746555v&gt;</blockquote>\n<blockquote>This path never moves more than three consecutive blocks in the same direction and incurs a heat loss of only 102.</blockquote>\n<blockquote>Directing the crucible from the lava pool to the machine parts factory, but not moving more than three consecutive blocks in the same direction, what is the least heat loss it can incur?</blockquote>\n<blockquote>Yay! Lava Production Facility is operational!</blockquote>\n<p>Seems like now we need to find the best way to get the lava crucible from the lava pool to the machine parts factory!</p>\n<p>We need to <strong><em>minimize </em></strong>heat loss by <strong>NOT</strong> taking a route with a long straight line as supposedly, crucibles become difficult to steer at high speed?! Well, that’s an interesting limitation.</p>\n<p>So, to solve this, we are given a map with traffic patterns, ambient temperature and hundred of other params to help us calculate expected heatloss for the crucible while entering any city block, that look something like this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1016/1*CmYlpzrbuOK0vG7RtHQPwQ.png\"></figure><p><strong>💡�Conditions to remember:</strong></p>\n<ul>\n<li>Because you already start in the <strong>top-left block</strong>, you <strong>don’t</strong> incur that block’s heat loss unless you leave that block and then return to it!</li>\n<li>Because it is difficult to keep the top-heavy crucible going in a straight line for very long, it can move <strong>at most three blocks</strong> in a <strong>single direction</strong> before it must turn <strong>90 degrees left or right.</strong>\n</li>\n<li>The crucible also <strong>can’t reverse direction</strong>; after entering each city block, it may only <strong>turn left, continue straight, or turn right</strong>.</li>\n</ul>\n<p>So, let’s see for the given base case example, what can be a way to minimize the heat loss in the path?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5zgsgBaC0KBm6JXWMl_CDg.gif\"></figure><p>This path never moves more than three consecutive blocks in the same direction. Here we incur a total heat loss of <strong>102 </strong>units.</p>\n<p>Now we need to find the answer similarly in the puzzle input. First things first, let’s write unit test for base case and try to fix that first?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/803/1*fTDdrnXE1FqfGOKG77upSQ.png\"><figcaption>Skelton code</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>Traceback (most recent call last):<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 29, in &lt;module&gt;<br>    test_get_min_heat_loss_path()<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 25, in test_get_min_heat_loss_path<br>    assert min_heat_loss == 102, f\"Expected 102, got {min_heat_loss}\"<br>AssertionError: Expected 102, got 0<br><br>[Done] exited with code=1 in 0.224 seconds</pre>\n<p>Let’s break down the problem!</p>\n<blockquote>It seems very similar to the last few problems, where we need to find path from top left to bottom right while obeying some rules and trying to minimize the heat loss!</blockquote>\n<p>The naive approach is to just explore all possible paths and then just pick the one with the lowest heat loss, but it will lead to a time complexity of: <strong><em>O(2^(N*M)) </em></strong>which means we will have:</p>\n<ul>\n<li>2¹⁶⁹ combinations for our base test case here with 13 x 13 grid</li>\n<li>2¹⁹⁸⁸¹ combinations for puzzle input with a 141 x 141 grid.</li>\n</ul>\n<p><strong><em>Fun fact? It is estimated that there may be ~2²⁵⁶ atoms in the known universe!</em></strong></p>\n<p>So, you can we the problem with the brute force approach here!</p>\n<p>We can reduce our search space by a lot here by following the given constraints!</p>\n<p>💭 One way that crosses my mind is to just do the DFS (Depth first search) by iterating through grid and store result in a var which will update whenever a path reaches bottom right like:</p>\n<p><strong>MIN_HEAT_LOSS = min(MIN_HEAT_LOSS, path_heat_loss)</strong></p>\n<p>And during iteration, on each choice just abandon any path that takes our path_heat_loss &gt; MIN_HEAT_LOSS ! By doing this, we can greatly reduce our search space to opt for more efficient paths on each try!</p>\n<p>Let’s write some code?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6mirpbc9wQv8qSPCtsw-yg.png\"><figcaption>Shit tons of debugging ensued!</figcaption></figure><p>So, we have written functionally correct code, as I can see the output trending towards the intended result, but the problem is our <strong><em>stack </em></strong>keeps increasing as it backtracks for all possible directions! I wrote a small script to visualize the state of my MIN_HEAT_LOSS_PATH, take a look as it optimises the path quickly at start but then gets caught up:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*myypKLXpQZELvZZDSpD69w.gif\"></figure><p>It’s clear that my code as it backtracks, it tries to process same path again as again as in DFS it will keep looping into a subsection of those 2¹⁶⁹ combinations as we discussed above!</p>\n<p>To avoid this, we can use memoization to store the minimum heat loss encountered at <strong>each node</strong>. If a path reaches the same node with a higher heat loss than previously recorded, we can just prune that path early.</p>\n<p>Adding a simple 2D arraymemo of same size as grid just to keep a track of lowest_heat_loss seen at every iteration:</p>\n<pre>memo = [[float('inf') for _ in range(len(grid[0]))] for _ in range(len(grid))]</pre>\n<p>And we can add a simple check in our code to ensure that:</p>\n<pre><br># if heat loss is already greater than min heat loss, continue<br>if next_heat_loss &gt;= memo[next_row][next_col]:<br>  continue</pre>\n<p>Let’s run it? And…</p>\n<pre>New min heat loss: 107<br># # # # . . # # # # . . .<br>. . . # # # # . . # . . .<br>. . . . . . . . . # # . .<br>. . . . . . . . . . # # .<br>. . . . . . . . . . . # .<br>. . . . . . . . . . . # #<br>. . . . . . . . . . . . #<br>. . . . . . . . . . . # #<br>. . . . . . . . . . . # .<br>. . . . . . . . . . . # #<br>. . . . . . . . . . . . #<br>. . . . . . . . . . . . #<br>. . . . . . . . . . . . #<br><br>Traceback (most recent call last):<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 112, in &lt;module&gt;<br>    test_get_min_heat_loss_path()<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 107, in test_get_min_heat_loss_path<br>    assert min_heat_loss == 102, f\"Expected 102, got {min_heat_loss}\"<br>AssertionError: Expected 102, got 107<br><br>[Done] exited with code=1 in 0.251 seconds</pre>\n<p>We are getting close! Atleast our runtime suggests that we have reduced our search space by a lot! We should get 102 but we are getting 107 here.</p>\n<p>Again, some debugging to go:</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>Ah! Found it. Our memo is currently just storing 1 dimension of heat_loss but we can basically get to that cell from any direction which may lead to a shorter path overall! We need to store heat_loss for all 4 directions for each cell</p>\n<pre># Initialize memoization table with dictionaries<br>memo = [[{d: float('inf') for d in Direction} for _ in range(len(grid[0]))] for _ in range(len(grid))]</pre>\n<p>And our memo condition will be modified to:</p>\n<pre># Continue to the next direction if the new path is not better<br>if next_heat_loss &gt; memo[next_row][next_col][direction]:<br>    continue<br>.<br>.<br>.<br># Update memo<br>memo[next_row][next_col][direction] = next_heat_loss  </pre>\n<p>Let’s run the base test case?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>✅ get_min_heat_loss_path() tests passed!<br><br>[Done] exited with code=0 in 0.726 seconds</pre>\n<p>Yas! Now, let’s load up our puzzle input?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>❗️ Minimum heat loss for crucible: XXX<br><br>[Done] exited with code=0 in 0.818 seconds</pre>\n<p>Let’s input the answer and….</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iANd1s2bvHp2YSBOxDSdBw.png\"><figcaption>⭐️</figcaption></figure><p>Our approach is quite messy! I am inclined to also explore this from BFS point of view in next part as I now feel we could have just used Djikstra's algo and called it a day by optimizing for low_heat_loss using a heapq.</p>\n<h3>Part Two</h3>\n<blockquote>The crucibles of lava simply aren’t large enough to provide an adequate supply of lava to the machine parts factory. Instead, the Elves are going to upgrade to ultra crucibles.</blockquote>\n<blockquote>Ultra crucibles are even more difficult to steer than normal crucibles. Not only do they have trouble going in a straight line, but they also have trouble turning!</blockquote>\n<blockquote>Once an ultra crucible starts moving in a direction, it needs to move a minimum of four blocks in that direction before it can turn (or even before it can stop at the end). However, it will eventually start to get wobbly: an ultra crucible can move a maximum of ten consecutive blocks without turning.</blockquote>\n<blockquote>In the above example, an ultra crucible could follow this path to minimize heat loss:</blockquote>\n<blockquote>2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;1323<br>32154535v5623<br>32552456v4254<br>34465858v5452<br>45466578v&gt;&gt;&gt;&gt;<br>143859879845v<br>445787698776v<br>363787797965v<br>465496798688v<br>456467998645v<br>122468686556v<br>254654888773v<br>432267465553v</blockquote>\n<blockquote>In the above example, an ultra crucible would incur the minimum possible heat loss of 94.</blockquote>\n<blockquote>Here’s another example:</blockquote>\n<blockquote>111111111111<br>999999999991<br>999999999991<br>999999999991<br>999999999991</blockquote>\n<blockquote>Sadly, an ultra crucible would need to take an unfortunate path like this one:</blockquote>\n<blockquote>1&gt;&gt;&gt;&gt;&gt;&gt;&gt;1111<br>9999999v9991<br>9999999v9991<br>9999999v9991<br>9999999v&gt;&gt;&gt;&gt;</blockquote>\n<blockquote>This route causes the ultra crucible to incur the minimum possible heat loss of 71.</blockquote>\n<blockquote>Directing the ultra crucible from the lava pool to the machine parts factory, what is the least heat loss it can incur?</blockquote>\n<p>So! We now have <strong>Ultra Crucibles!</strong></p>\n<p>It seems like we need to modifty our code to handle the new conditions:</p>\n<ul>\n<li>once it starts moving in a direction, it needs to move a <strong>minimum of four blocks in that direction</strong> before it can turn.<br>- or even before it can stop at the end.</li>\n<li>can move a <strong>maximum of ten consecutive blocks</strong> without turning.</li>\n</ul>\n<p>So, for the same example like in last part, here’s how the traversal will look like for an Ultra Crucible:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*7djuAO8y7gNYz-uE5XyEgw.gif\"></figure><p>Now, using the similar thinking, all we need to change is blocks_before_turn and max_in_direction for the given crucible where for:</p>\n<ul>\n<li>\n<strong><em>normal crucible</em></strong>: blocks_before_turn=0, max_in_direction=3</li>\n<li>\n<strong><em>ultra crucible: </em></strong>blocks_before_turn=3, max_in_direction=10</li>\n</ul>\n<p>We will try and go for the Dijkstra’s algorithm to solve this one! The idea is that I would like to create memo i.e. a nested dict of dicts which will store heat_loss for the given cell for all 4 directions!</p>\n<p>Something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zODE9y2vAcF91EOrQNpj9w.png\"></figure><p>And to simplify our crucible turning, we can just define a map: ALLOWED_CRUCIBLE_TURNS to keep a track of:</p>\n<pre>ALLOWED_CRUCIBLE_TURNS = {<br>    Direction.RIGHT: [Direction.UP, Direction.DOWN],<br>    Direction.LEFT: [Direction.UP, Direction.DOWN],<br>    Direction.UP: [Direction.LEFT, Direction.RIGHT],<br>    Direction.DOWN: [Direction.LEFT, Direction.RIGHT]<br>}</pre>\n<p>Let’s write some code:</p>\n<p>First, we initialize a nested defaultdict memo with sys.maxsize as the default value. This dictionary will store the minimum heat loss for each position and direction.</p>\n<p>The use of sys.maxsize is a common trick in algorithms that need to find a minimum value - it's the largest possible integer in Python, so any real heat loss will be less than this.</p>\n<pre># Initialize heat loss dictionary with max values for each direction<br>memo = defaultdict(lambda: defaultdict(lambda: sys.maxsize))</pre>\n<p>Next, we initialize the heat loss for each direction at the starting position (0, 0) to be 0. This makes sense because we haven’t moved the crucible yet, so there’s no heat loss.</p>\n<pre>for direction in Direction:<br>  memo[(0, 0)][direction] = 0</pre>\n<p>We can then create a priority queue pq to manage the positions we need to explore. The priority queue is a perfect data structure for <strong>Dijkstra's algorithm</strong> because it allows us to efficiently get the position with the <strong>smallest heat loss</strong>.</p>\n<p>Our pq will store (heat_loss, position, dir_name) where it will be sorted wrt to <em>heat_loss. </em>We can seed the queue with all possible directions from the starting position i.e: <strong>RIGHT</strong> and <strong>DOWN</strong>:</p>\n<pre># Initialize the priority queue for Dijkstra's algorithm<br>pq = PriorityQueue()<br><br># seed pq with all possible directions from the starting position<br>pq.put((0, (0, 0), Direction.RIGHT.name))<br>pq.put((0, (0, 0), Direction.DOWN.name))</pre>\n<p>Now, all we need to do is:</p>\n<ul>\n<li>continually take the position with the smallest heat loss from the queue and explore new positions from there</li>\n<li>if the new position’s heat loss is less than the currently known minimum for that position and direction, we update the minimum and add the new position to the queue.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*ILNsqUT6rK5gGqyNsEUq1Q.png\"></figure><p>Once we are done with this, our memo will have min(heat_loss) from all 4 directions for each cell, something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ayANZkHBUOqd54tuQl-s7A.png\"><figcaption>For (12, 12), we have 4 values: 104, 104, 102, 102</figcaption></figure><p>All we need to do is, return the minimun value!</p>\n<p>Let’s update our base case now for Part 2?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/880/1*1fAUkceIy5qYMP1y1_hz0g.png\"></figure><p>Let’s run it?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>✅ get_min_heat_loss_path() tests passed for Crucible!<br>✅ get_min_heat_loss_path() tests passed for Ultra Crucible!<br><br>[Done] exited with code=0 in 0.227 seconds</pre>\n<p>We can now run for Part 2 for ultra crucible with values: blocks_before_turn=3, max_in_direction=10</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/768/1*83NF71L3n-qYZ4AeWQN5vA.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>❗️❗️ Minimum heat loss for Ultra Crucible: XXX<br><br>[Done] exited with code=0 in 1.337 seconds</pre>\n<p>We have an answer! Let’s input this in our answer box, and:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Q-bwTP-vYtDcHwB-eQSYjw.png\"><figcaption>🌟</figcaption></figure><p>Here’s our final code till now, <em>I am keeping inline comments in for the understanding of the reader:</em></p>\n<pre># Day 17: Clumsy Crucible<br><br>import sys<br>from enum import Enum<br>from queue import PriorityQueue<br>from collections import defaultdict<br><br><br># Define the Direction Enum for clarity and ease of use<br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br># Define allowed turns for the crucible from each direction<br>ALLOWED_CRUCIBLE_TURNS = {<br>    Direction.RIGHT: [Direction.UP, Direction.DOWN],<br>    Direction.LEFT: [Direction.UP, Direction.DOWN],<br>    Direction.UP: [Direction.LEFT, Direction.RIGHT],<br>    Direction.DOWN: [Direction.LEFT, Direction.RIGHT],<br>}<br><br><br># Function to find the minimum heat loss for moving the crucible<br>def find_min_heat_loss(grid, blocks_before_turn, max_in_direction):<br>    # Initialize distance dictionary with max values for each direction<br>    memo = defaultdict(lambda: defaultdict(lambda: sys.maxsize))<br><br>    for direction in Direction:<br>        memo[(0, 0)][direction] = 0<br><br>    # Initialize the priority queue for Dijkstra's algorithm<br>    pq = PriorityQueue()<br><br>    # seed pq with all possible directions from the starting position<br>    pq.put((0, (0, 0), Direction.RIGHT.name))<br>    pq.put((0, (0, 0), Direction.DOWN.name))<br><br>    while not pq.empty():<br>        heat_loss, position, dir_name = pq.get()<br>        direction = Direction[dir_name]  # Convert back to Direction enum<br><br>        # Skip if the current path's heat loss is not better than already known<br>        if heat_loss &gt; memo[position][direction]:<br>            continue<br><br>        x, y = position<br>        for block in range(max_in_direction):<br>            # Move in the current direction<br>            dx, dy = direction.value<br>            x, y = x + dx, y + dy<br><br>            # Check if the new position is out of bounds<br>            if x &lt; 0 or x &gt;= len(grid[0]) or y &lt; 0 or y &gt;= len(grid):<br>                break<br><br>            # Accumulate heat loss<br>            heat_loss += grid[y][x]<br><br>            # Check if the crucible has moved the required blocks before turning<br>            if block &lt; blocks_before_turn:<br>                continue<br><br>            # Explore new directions from the current position<br>            for new_dir in ALLOWED_CRUCIBLE_TURNS[direction]:<br>                if heat_loss &lt; memo[(x, y)][new_dir]:<br>                    memo[(x, y)][new_dir] = heat_loss<br>                    pq.put((heat_loss, (x, y), new_dir.name))<br><br>    # Return the minimum heat loss to reach the bottom-right corner<br>    return min(memo[(len(grid[0]) - 1, len(grid) - 1)].values())<br><br><br>def parse_grid(input_str):<br>    return [[int(x) for x in line] for line in input_str.split(\"\\n\")]<br><br><br>def part_one():<br>    with open(\"day_17/input.txt\", \"r\") as f:<br>        grid = parse_grid(f.read())<br>    min_heat_loss = find_min_heat_loss(grid, 0, 3)<br>    print(f\"❗️ Minimum heat loss for Normal Crucible: {min_heat_loss}\")<br><br><br>def part_two():<br>    with open(\"day_17/input.txt\", \"r\") as f:<br>        grid = parse_grid(f.read())<br>    min_heat_loss = find_min_heat_loss(grid, 3, 10)<br>    print(f\"❗️❗️ Minimum heat loss for Ultra Crucible: {min_heat_loss}\")<br><br><br>def test_get_min_heat_loss_path_normal_crucible():<br>    input_str = \"\"\"2413432311323<br>3215453535623<br>3255245654254<br>3446585845452<br>4546657867536<br>1438598798454<br>4457876987766<br>3637877979653<br>4654967986887<br>4564679986453<br>1224686865563<br>2546548887735<br>4322674655533\"\"\"<br>    grid = parse_grid(input_str)<br>    min_heat_loss = find_min_heat_loss(grid, 0, 3)<br>    assert min_heat_loss == 102, f\"Expected 102, got {min_heat_loss}\"<br>    print(\"✅ get_min_heat_loss_path() tests passed for Crucible!\")<br><br>def test_get_min_heat_loss_path_ultra_crucible():<br>    input_str = \"\"\"2413432311323<br>3215453535623<br>3255245654254<br>3446585845452<br>4546657867536<br>1438598798454<br>4457876987766<br>3637877979653<br>4654967986887<br>4564679986453<br>1224686865563<br>2546548887735<br>4322674655533\"\"\"<br>    grid = parse_grid(input_str)<br>    min_heat_loss = find_min_heat_loss(grid, 3, 10)<br>    assert min_heat_loss == 94, f\"Expected 94, got {min_heat_loss}\"<br>    print(\"✅ get_min_heat_loss_path() tests passed for Ultra Crucible!\")<br><br><br>if __name__ == \"__main__\":<br>    test_get_min_heat_loss_path_normal_crucible()<br>    part_one()<br><br>    test_get_min_heat_loss_path_ultra_crucible()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine 👇</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! 🎄</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=2aade00ab25e\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*yySJqIpnZupAF8I0\"><figcaption>Clumsy Crucible (via DALL-E 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/17\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>The lava starts flowing rapidly once the Lava Production Facility is operational. As you leave, the reindeer offers you a parachute, allowing you to quickly reach Gear Island.</blockquote>\n<blockquote>As you descend, your bird’s-eye view of Gear Island reveals why you had trouble finding anyone on your way up: half of Gear Island is empty, but the half below you is a giant factory city!</blockquote>\n<blockquote>You land near the gradually-filling pool of lava at the base of your new lavafall. Lavaducts will eventually carry the lava throughout the city, but to make use of it immediately, Elves are loading it into large <a href=\"https://en.wikipedia.org/wiki/Crucible\">crucibles</a> on wheels.</blockquote>\n<blockquote>The crucibles are top-heavy and pushed by hand. Unfortunately, the crucibles become very difficult to steer at high speeds, and so it can be hard to go in a straight line for very long.</blockquote>\n<blockquote>To get Desert Island the machine parts it needs as soon as possible, you’ll need to find the best way to get the crucible from the lava pool to the machine parts factory. To do this, you need to minimize heat loss while choosing a route that doesn’t require the crucible to go in a straight linefor too long.</blockquote>\n<blockquote>Fortunately, the Elves here have a map (your puzzle input) that uses traffic patterns, ambient temperature, and hundreds of other parameters to calculate exactly how much heat loss can be expected for a crucible entering any particular city block.</blockquote>\n<blockquote>For example:</blockquote>\n<blockquote>2413432311323<br>3215453535623<br>3255245654254<br>3446585845452<br>4546657867536<br>1438598798454<br>4457876987766<br>3637877979653<br>4654967986887<br>4564679986453<br>1224686865563<br>2546548887735<br>4322674655533</blockquote>\n<blockquote>Each city block is marked by a single digit that represents the amount of heat loss if the crucible enters that block. The starting point, the lava pool, is the top-left city block; the destination, the machine parts factory, is the bottom-right city block. (Because you already start in the top-left block, you don’t incur that block’s heat loss unless you leave that block and then return to it.)</blockquote>\n<blockquote>Because it is difficult to keep the top-heavy crucible going in a straight line for very long, it can move at most three blocks in a single direction before it must turn 90 degrees left or right. The crucible also can’t reverse direction; after entering each city block, it may only turn left, continue straight, or turn right.</blockquote>\n<blockquote>One way to minimize heat loss is this path:</blockquote>\n<blockquote>2&gt;&gt;34^&gt;&gt;&gt;1323<br>32v&gt;&gt;&gt;35v5623<br>32552456v&gt;&gt;54<br>3446585845v52<br>4546657867v&gt;6<br>14385987984v4<br>44578769877v6<br>36378779796v&gt;<br>465496798688v<br>456467998645v<br>12246868655&lt;v<br>25465488877v5<br>43226746555v&gt;</blockquote>\n<blockquote>This path never moves more than three consecutive blocks in the same direction and incurs a heat loss of only 102.</blockquote>\n<blockquote>Directing the crucible from the lava pool to the machine parts factory, but not moving more than three consecutive blocks in the same direction, what is the least heat loss it can incur?</blockquote>\n<blockquote>Yay! Lava Production Facility is operational!</blockquote>\n<p>Seems like now we need to find the best way to get the lava crucible from the lava pool to the machine parts factory!</p>\n<p>We need to <strong><em>minimize </em></strong>heat loss by <strong>NOT</strong> taking a route with a long straight line as supposedly, crucibles become difficult to steer at high speed?! Well, that’s an interesting limitation.</p>\n<p>So, to solve this, we are given a map with traffic patterns, ambient temperature and hundred of other params to help us calculate expected heatloss for the crucible while entering any city block, that look something like this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1016/1*CmYlpzrbuOK0vG7RtHQPwQ.png\"></figure><p><strong>💡�Conditions to remember:</strong></p>\n<ul>\n<li>Because you already start in the <strong>top-left block</strong>, you <strong>don’t</strong> incur that block’s heat loss unless you leave that block and then return to it!</li>\n<li>Because it is difficult to keep the top-heavy crucible going in a straight line for very long, it can move <strong>at most three blocks</strong> in a <strong>single direction</strong> before it must turn <strong>90 degrees left or right.</strong>\n</li>\n<li>The crucible also <strong>can’t reverse direction</strong>; after entering each city block, it may only <strong>turn left, continue straight, or turn right</strong>.</li>\n</ul>\n<p>So, let’s see for the given base case example, what can be a way to minimize the heat loss in the path?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5zgsgBaC0KBm6JXWMl_CDg.gif\"></figure><p>This path never moves more than three consecutive blocks in the same direction. Here we incur a total heat loss of <strong>102 </strong>units.</p>\n<p>Now we need to find the answer similarly in the puzzle input. First things first, let’s write unit test for base case and try to fix that first?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/803/1*fTDdrnXE1FqfGOKG77upSQ.png\"><figcaption>Skelton code</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>Traceback (most recent call last):<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 29, in &lt;module&gt;<br>    test_get_min_heat_loss_path()<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 25, in test_get_min_heat_loss_path<br>    assert min_heat_loss == 102, f\"Expected 102, got {min_heat_loss}\"<br>AssertionError: Expected 102, got 0<br><br>[Done] exited with code=1 in 0.224 seconds</pre>\n<p>Let’s break down the problem!</p>\n<blockquote>It seems very similar to the last few problems, where we need to find path from top left to bottom right while obeying some rules and trying to minimize the heat loss!</blockquote>\n<p>The naive approach is to just explore all possible paths and then just pick the one with the lowest heat loss, but it will lead to a time complexity of: <strong><em>O(2^(N*M)) </em></strong>which means we will have:</p>\n<ul>\n<li>2¹⁶⁹ combinations for our base test case here with 13 x 13 grid</li>\n<li>2¹⁹⁸⁸¹ combinations for puzzle input with a 141 x 141 grid.</li>\n</ul>\n<p><strong><em>Fun fact? It is estimated that there may be ~2²⁵⁶ atoms in the known universe!</em></strong></p>\n<p>So, you can we the problem with the brute force approach here!</p>\n<p>We can reduce our search space by a lot here by following the given constraints!</p>\n<p>💭 One way that crosses my mind is to just do the DFS (Depth first search) by iterating through grid and store result in a var which will update whenever a path reaches bottom right like:</p>\n<p><strong>MIN_HEAT_LOSS = min(MIN_HEAT_LOSS, path_heat_loss)</strong></p>\n<p>And during iteration, on each choice just abandon any path that takes our path_heat_loss &gt; MIN_HEAT_LOSS ! By doing this, we can greatly reduce our search space to opt for more efficient paths on each try!</p>\n<p>Let’s write some code?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6mirpbc9wQv8qSPCtsw-yg.png\"><figcaption>Shit tons of debugging ensued!</figcaption></figure><p>So, we have written functionally correct code, as I can see the output trending towards the intended result, but the problem is our <strong><em>stack </em></strong>keeps increasing as it backtracks for all possible directions! I wrote a small script to visualize the state of my MIN_HEAT_LOSS_PATH, take a look as it optimises the path quickly at start but then gets caught up:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*myypKLXpQZELvZZDSpD69w.gif\"></figure><p>It’s clear that my code as it backtracks, it tries to process same path again as again as in DFS it will keep looping into a subsection of those 2¹⁶⁹ combinations as we discussed above!</p>\n<p>To avoid this, we can use memoization to store the minimum heat loss encountered at <strong>each node</strong>. If a path reaches the same node with a higher heat loss than previously recorded, we can just prune that path early.</p>\n<p>Adding a simple 2D arraymemo of same size as grid just to keep a track of lowest_heat_loss seen at every iteration:</p>\n<pre>memo = [[float('inf') for _ in range(len(grid[0]))] for _ in range(len(grid))]</pre>\n<p>And we can add a simple check in our code to ensure that:</p>\n<pre><br># if heat loss is already greater than min heat loss, continue<br>if next_heat_loss &gt;= memo[next_row][next_col]:<br>  continue</pre>\n<p>Let’s run it? And…</p>\n<pre>New min heat loss: 107<br># # # # . . # # # # . . .<br>. . . # # # # . . # . . .<br>. . . . . . . . . # # . .<br>. . . . . . . . . . # # .<br>. . . . . . . . . . . # .<br>. . . . . . . . . . . # #<br>. . . . . . . . . . . . #<br>. . . . . . . . . . . # #<br>. . . . . . . . . . . # .<br>. . . . . . . . . . . # #<br>. . . . . . . . . . . . #<br>. . . . . . . . . . . . #<br>. . . . . . . . . . . . #<br><br>Traceback (most recent call last):<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 112, in &lt;module&gt;<br>    test_get_min_heat_loss_path()<br>  File \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\", line 107, in test_get_min_heat_loss_path<br>    assert min_heat_loss == 102, f\"Expected 102, got {min_heat_loss}\"<br>AssertionError: Expected 102, got 107<br><br>[Done] exited with code=1 in 0.251 seconds</pre>\n<p>We are getting close! Atleast our runtime suggests that we have reduced our search space by a lot! We should get 102 but we are getting 107 here.</p>\n<p>Again, some debugging to go:</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>Ah! Found it. Our memo is currently just storing 1 dimension of heat_loss but we can basically get to that cell from any direction which may lead to a shorter path overall! We need to store heat_loss for all 4 directions for each cell</p>\n<pre># Initialize memoization table with dictionaries<br>memo = [[{d: float('inf') for d in Direction} for _ in range(len(grid[0]))] for _ in range(len(grid))]</pre>\n<p>And our memo condition will be modified to:</p>\n<pre># Continue to the next direction if the new path is not better<br>if next_heat_loss &gt; memo[next_row][next_col][direction]:<br>    continue<br>.<br>.<br>.<br># Update memo<br>memo[next_row][next_col][direction] = next_heat_loss  </pre>\n<p>Let’s run the base test case?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>✅ get_min_heat_loss_path() tests passed!<br><br>[Done] exited with code=0 in 0.726 seconds</pre>\n<p>Yas! Now, let’s load up our puzzle input?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>❗️ Minimum heat loss for crucible: XXX<br><br>[Done] exited with code=0 in 0.818 seconds</pre>\n<p>Let’s input the answer and….</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iANd1s2bvHp2YSBOxDSdBw.png\"><figcaption>⭐️</figcaption></figure><p>Our approach is quite messy! I am inclined to also explore this from BFS point of view in next part as I now feel we could have just used Djikstra's algo and called it a day by optimizing for low_heat_loss using a heapq.</p>\n<h3>Part Two</h3>\n<blockquote>The crucibles of lava simply aren’t large enough to provide an adequate supply of lava to the machine parts factory. Instead, the Elves are going to upgrade to ultra crucibles.</blockquote>\n<blockquote>Ultra crucibles are even more difficult to steer than normal crucibles. Not only do they have trouble going in a straight line, but they also have trouble turning!</blockquote>\n<blockquote>Once an ultra crucible starts moving in a direction, it needs to move a minimum of four blocks in that direction before it can turn (or even before it can stop at the end). However, it will eventually start to get wobbly: an ultra crucible can move a maximum of ten consecutive blocks without turning.</blockquote>\n<blockquote>In the above example, an ultra crucible could follow this path to minimize heat loss:</blockquote>\n<blockquote>2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;1323<br>32154535v5623<br>32552456v4254<br>34465858v5452<br>45466578v&gt;&gt;&gt;&gt;<br>143859879845v<br>445787698776v<br>363787797965v<br>465496798688v<br>456467998645v<br>122468686556v<br>254654888773v<br>432267465553v</blockquote>\n<blockquote>In the above example, an ultra crucible would incur the minimum possible heat loss of 94.</blockquote>\n<blockquote>Here’s another example:</blockquote>\n<blockquote>111111111111<br>999999999991<br>999999999991<br>999999999991<br>999999999991</blockquote>\n<blockquote>Sadly, an ultra crucible would need to take an unfortunate path like this one:</blockquote>\n<blockquote>1&gt;&gt;&gt;&gt;&gt;&gt;&gt;1111<br>9999999v9991<br>9999999v9991<br>9999999v9991<br>9999999v&gt;&gt;&gt;&gt;</blockquote>\n<blockquote>This route causes the ultra crucible to incur the minimum possible heat loss of 71.</blockquote>\n<blockquote>Directing the ultra crucible from the lava pool to the machine parts factory, what is the least heat loss it can incur?</blockquote>\n<p>So! We now have <strong>Ultra Crucibles!</strong></p>\n<p>It seems like we need to modifty our code to handle the new conditions:</p>\n<ul>\n<li>once it starts moving in a direction, it needs to move a <strong>minimum of four blocks in that direction</strong> before it can turn.<br>- or even before it can stop at the end.</li>\n<li>can move a <strong>maximum of ten consecutive blocks</strong> without turning.</li>\n</ul>\n<p>So, for the same example like in last part, here’s how the traversal will look like for an Ultra Crucible:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*7djuAO8y7gNYz-uE5XyEgw.gif\"></figure><p>Now, using the similar thinking, all we need to change is blocks_before_turn and max_in_direction for the given crucible where for:</p>\n<ul>\n<li>\n<strong><em>normal crucible</em></strong>: blocks_before_turn=0, max_in_direction=3</li>\n<li>\n<strong><em>ultra crucible: </em></strong>blocks_before_turn=3, max_in_direction=10</li>\n</ul>\n<p>We will try and go for the Dijkstra’s algorithm to solve this one! The idea is that I would like to create memo i.e. a nested dict of dicts which will store heat_loss for the given cell for all 4 directions!</p>\n<p>Something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zODE9y2vAcF91EOrQNpj9w.png\"></figure><p>And to simplify our crucible turning, we can just define a map: ALLOWED_CRUCIBLE_TURNS to keep a track of:</p>\n<pre>ALLOWED_CRUCIBLE_TURNS = {<br>    Direction.RIGHT: [Direction.UP, Direction.DOWN],<br>    Direction.LEFT: [Direction.UP, Direction.DOWN],<br>    Direction.UP: [Direction.LEFT, Direction.RIGHT],<br>    Direction.DOWN: [Direction.LEFT, Direction.RIGHT]<br>}</pre>\n<p>Let’s write some code:</p>\n<p>First, we initialize a nested defaultdict memo with sys.maxsize as the default value. This dictionary will store the minimum heat loss for each position and direction.</p>\n<p>The use of sys.maxsize is a common trick in algorithms that need to find a minimum value - it's the largest possible integer in Python, so any real heat loss will be less than this.</p>\n<pre># Initialize heat loss dictionary with max values for each direction<br>memo = defaultdict(lambda: defaultdict(lambda: sys.maxsize))</pre>\n<p>Next, we initialize the heat loss for each direction at the starting position (0, 0) to be 0. This makes sense because we haven’t moved the crucible yet, so there’s no heat loss.</p>\n<pre>for direction in Direction:<br>  memo[(0, 0)][direction] = 0</pre>\n<p>We can then create a priority queue pq to manage the positions we need to explore. The priority queue is a perfect data structure for <strong>Dijkstra's algorithm</strong> because it allows us to efficiently get the position with the <strong>smallest heat loss</strong>.</p>\n<p>Our pq will store (heat_loss, position, dir_name) where it will be sorted wrt to <em>heat_loss. </em>We can seed the queue with all possible directions from the starting position i.e: <strong>RIGHT</strong> and <strong>DOWN</strong>:</p>\n<pre># Initialize the priority queue for Dijkstra's algorithm<br>pq = PriorityQueue()<br><br># seed pq with all possible directions from the starting position<br>pq.put((0, (0, 0), Direction.RIGHT.name))<br>pq.put((0, (0, 0), Direction.DOWN.name))</pre>\n<p>Now, all we need to do is:</p>\n<ul>\n<li>continually take the position with the smallest heat loss from the queue and explore new positions from there</li>\n<li>if the new position’s heat loss is less than the currently known minimum for that position and direction, we update the minimum and add the new position to the queue.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*ILNsqUT6rK5gGqyNsEUq1Q.png\"></figure><p>Once we are done with this, our memo will have min(heat_loss) from all 4 directions for each cell, something like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ayANZkHBUOqd54tuQl-s7A.png\"><figcaption>For (12, 12), we have 4 values: 104, 104, 102, 102</figcaption></figure><p>All we need to do is, return the minimun value!</p>\n<p>Let’s update our base case now for Part 2?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/880/1*1fAUkceIy5qYMP1y1_hz0g.png\"></figure><p>Let’s run it?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>✅ get_min_heat_loss_path() tests passed for Crucible!<br>✅ get_min_heat_loss_path() tests passed for Ultra Crucible!<br><br>[Done] exited with code=0 in 0.227 seconds</pre>\n<p>We can now run for Part 2 for ultra crucible with values: blocks_before_turn=3, max_in_direction=10</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/768/1*83NF71L3n-qYZ4AeWQN5vA.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_17/clumsy_crucible.py\"<br>❗️❗️ Minimum heat loss for Ultra Crucible: XXX<br><br>[Done] exited with code=0 in 1.337 seconds</pre>\n<p>We have an answer! Let’s input this in our answer box, and:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Q-bwTP-vYtDcHwB-eQSYjw.png\"><figcaption>🌟</figcaption></figure><p>Here’s our final code till now, <em>I am keeping inline comments in for the understanding of the reader:</em></p>\n<pre># Day 17: Clumsy Crucible<br><br>import sys<br>from enum import Enum<br>from queue import PriorityQueue<br>from collections import defaultdict<br><br><br># Define the Direction Enum for clarity and ease of use<br>class Direction(Enum):<br>    UP = (-1, 0)<br>    DOWN = (1, 0)<br>    LEFT = (0, -1)<br>    RIGHT = (0, 1)<br><br><br># Define allowed turns for the crucible from each direction<br>ALLOWED_CRUCIBLE_TURNS = {<br>    Direction.RIGHT: [Direction.UP, Direction.DOWN],<br>    Direction.LEFT: [Direction.UP, Direction.DOWN],<br>    Direction.UP: [Direction.LEFT, Direction.RIGHT],<br>    Direction.DOWN: [Direction.LEFT, Direction.RIGHT],<br>}<br><br><br># Function to find the minimum heat loss for moving the crucible<br>def find_min_heat_loss(grid, blocks_before_turn, max_in_direction):<br>    # Initialize distance dictionary with max values for each direction<br>    memo = defaultdict(lambda: defaultdict(lambda: sys.maxsize))<br><br>    for direction in Direction:<br>        memo[(0, 0)][direction] = 0<br><br>    # Initialize the priority queue for Dijkstra's algorithm<br>    pq = PriorityQueue()<br><br>    # seed pq with all possible directions from the starting position<br>    pq.put((0, (0, 0), Direction.RIGHT.name))<br>    pq.put((0, (0, 0), Direction.DOWN.name))<br><br>    while not pq.empty():<br>        heat_loss, position, dir_name = pq.get()<br>        direction = Direction[dir_name]  # Convert back to Direction enum<br><br>        # Skip if the current path's heat loss is not better than already known<br>        if heat_loss &gt; memo[position][direction]:<br>            continue<br><br>        x, y = position<br>        for block in range(max_in_direction):<br>            # Move in the current direction<br>            dx, dy = direction.value<br>            x, y = x + dx, y + dy<br><br>            # Check if the new position is out of bounds<br>            if x &lt; 0 or x &gt;= len(grid[0]) or y &lt; 0 or y &gt;= len(grid):<br>                break<br><br>            # Accumulate heat loss<br>            heat_loss += grid[y][x]<br><br>            # Check if the crucible has moved the required blocks before turning<br>            if block &lt; blocks_before_turn:<br>                continue<br><br>            # Explore new directions from the current position<br>            for new_dir in ALLOWED_CRUCIBLE_TURNS[direction]:<br>                if heat_loss &lt; memo[(x, y)][new_dir]:<br>                    memo[(x, y)][new_dir] = heat_loss<br>                    pq.put((heat_loss, (x, y), new_dir.name))<br><br>    # Return the minimum heat loss to reach the bottom-right corner<br>    return min(memo[(len(grid[0]) - 1, len(grid) - 1)].values())<br><br><br>def parse_grid(input_str):<br>    return [[int(x) for x in line] for line in input_str.split(\"\\n\")]<br><br><br>def part_one():<br>    with open(\"day_17/input.txt\", \"r\") as f:<br>        grid = parse_grid(f.read())<br>    min_heat_loss = find_min_heat_loss(grid, 0, 3)<br>    print(f\"❗️ Minimum heat loss for Normal Crucible: {min_heat_loss}\")<br><br><br>def part_two():<br>    with open(\"day_17/input.txt\", \"r\") as f:<br>        grid = parse_grid(f.read())<br>    min_heat_loss = find_min_heat_loss(grid, 3, 10)<br>    print(f\"❗️❗️ Minimum heat loss for Ultra Crucible: {min_heat_loss}\")<br><br><br>def test_get_min_heat_loss_path_normal_crucible():<br>    input_str = \"\"\"2413432311323<br>3215453535623<br>3255245654254<br>3446585845452<br>4546657867536<br>1438598798454<br>4457876987766<br>3637877979653<br>4654967986887<br>4564679986453<br>1224686865563<br>2546548887735<br>4322674655533\"\"\"<br>    grid = parse_grid(input_str)<br>    min_heat_loss = find_min_heat_loss(grid, 0, 3)<br>    assert min_heat_loss == 102, f\"Expected 102, got {min_heat_loss}\"<br>    print(\"✅ get_min_heat_loss_path() tests passed for Crucible!\")<br><br>def test_get_min_heat_loss_path_ultra_crucible():<br>    input_str = \"\"\"2413432311323<br>3215453535623<br>3255245654254<br>3446585845452<br>4546657867536<br>1438598798454<br>4457876987766<br>3637877979653<br>4654967986887<br>4564679986453<br>1224686865563<br>2546548887735<br>4322674655533\"\"\"<br>    grid = parse_grid(input_str)<br>    min_heat_loss = find_min_heat_loss(grid, 3, 10)<br>    assert min_heat_loss == 94, f\"Expected 94, got {min_heat_loss}\"<br>    print(\"✅ get_min_heat_loss_path() tests passed for Ultra Crucible!\")<br><br><br>if __name__ == \"__main__\":<br>    test_get_min_heat_loss_path_normal_crucible()<br>    part_one()<br><br>    test_get_min_heat_loss_path_ultra_crucible()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine 👇</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! 🎄</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=2aade00ab25e\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "advent-of-code-2023",
        "coding",
        "python",
        "advent-of-code",
        "programming"
      ]
    }
  ]
}