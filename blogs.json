{
  "status": "ok",
  "feed": {
    "url": "https://medium.com/feed/@jatinkrmalik",
    "title": "Stories by Jatin K Malik on Medium",
    "link": "https://medium.com/@jatinkrmalik?source=rss-ec576e4b06b0------2",
    "author": "",
    "description": "Stories by Jatin K Malik on Medium",
    "image": "https://cdn-images-1.medium.com/fit/c/150/150/2*9w8uaQp8uqA5wtRu-DltrQ.png"
  },
  "items": [
    {
      "title": "[Day 14] Parabolic Reflector Dish // Advent of Code 2023 (Python)",
      "pubDate": "2023-12-21 21:01:16",
      "link": "https://medium.com/@jatinkrmalik/day-14-parabolic-reflector-dish-advent-of-code-2023-python-10760f12f5a5?source=rss-ec576e4b06b0------2",
      "guid": "https://medium.com/p/10760f12f5a5",
      "author": "Jatin K Malik",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*zkAVIfrKih2TgfjK\"><figcaption>Parabolic Reflector Dish (via DALL-EÂ 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/14\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You reach the place where all of the mirrors were pointing: a massive <a href=\"https://en.wikipedia.org/wiki/Parabolic_reflector\">parabolic reflector dish</a> attached to the side of another large mountain.</blockquote>\n<blockquote>The dish is made up of many small mirrors, but while the mirrors themselves are roughly in the shape of a parabolic reflector dish, each individual mirror seems to be pointing in slightly the wrong direction. If the dish is meant to focus light, all itâ€™s doing right now is sending it in a vague direction.</blockquote>\n<blockquote>This system must be what provides the energy for the lava! If you focus the reflector dish, maybe you can go where itâ€™s pointing and use the light to fix the lava production.</blockquote>\n<blockquote>Upon closer inspection, the individual mirrors each appear to be connected via an elaborate system of ropes and pulleys to a large metal platform below the dish. The platform is covered in large rocks of various shapes. Depending on their position, the weight of the rocks deforms the platform, and the shape of the platform controls which ropes move and ultimately the focus of theÂ dish.</blockquote>\n<blockquote>In short: if you move the rocks, you can focus the dish. The platform even has a control panel on the side that lets you tilt it in one of four directions! The rounded rocks (O) will roll when the platform is tilted, while the cube-shaped rocks (#) will stay in place. You note the positions of all of the empty spaces (.) and rocks (your puzzle input). ForÂ example:</blockquote>\n<blockquote>O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....</blockquote>\n<blockquote>Start by tilting the lever so all of the rocks will slide north as far as they willÂ go:</blockquote>\n<blockquote>OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....</blockquote>\n<blockquote>You notice that the support beams along the north side of the platform are damaged; to ensure the platform doesnâ€™t collapse, you should calculate the total load on the north supportÂ beams.</blockquote>\n<blockquote>The amount of load caused by a single rounded rock (O) is equal to the number of rows from the rock to the south edge of the platform, including the row the rock is on. (Cube-shaped rocks (#) don't contribute to load.) So, the amount of load caused by each rock in each row is asÂ follows:</blockquote>\n<blockquote>OOOO.#.O.. 10<br>OO..#....# 9<br>OO..O##..O 8<br>O..#.OO... 7<br>........#. 6<br>..#....#.# 5<br>..O..#.O.O 4<br>..O....... 3<br>#....###.. 2<br>#....#.... 1</blockquote>\n<blockquote>The total load is the sum of the load caused by all of the rounded rocks. In this example, the total load isÂ 136.</blockquote>\n<blockquote>Tilt the platform so that the rounded rocks all roll north. Afterward, what is the total load on the north supportÂ beams?</blockquote>\n<p>Cool! Letâ€™s review the problem in terms of <strong><em>chronology</em></strong> and we shall break down what needs to be done to get ourÂ answer?</p>\n<p>We have <strong>2 types ofÂ rocks</strong>:</p>\n<ul>\n<li># <strong>Cube shape rocks</strong>, that stay inÂ place</li>\n<li>O <strong>Rounded rocks</strong>, thatÂ rolls!</li>\n</ul>\n<p>Given an initial state of platform represented by a 2D matrix, we need to ensure that the north side beam <strong>can handle the load</strong> if we start to tilt the platform, so we can need to <strong>calculate the state of platform</strong> when it is tilted towards North direction!</p>\n<p>Letâ€™s see a quickÂ viz:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/733/1*34Iz-l6OzH6JvCKvO1pHvw.png\"></figure><p>We can observe how all O rocks have <strong>moved along their columns towards North</strong> while # have stayedÂ put.</p>\n<p>And then, base case allows us to calculate the load bearing capacity of the north support beam by sum(number of \"Oâ€ rocks * number of rows from the rock to the south edge of the platform), like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/852/1*z7xNWvYhuVnAf6N5fmV2xA.png\"></figure><p>So, we need to write code in 2Â parts:</p>\n<ol>\n<li>To <strong>generate</strong> the north_tilted state</li>\n<li>To <strong>calculate</strong> the total load on northÂ beam</li>\n</ol>\n<p>But first, letâ€™s write the base test case along with some skelton code to structure our thoughtÂ process:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/817/1*dTdlYQQC_kV6EXaKXAOr4g.png\"></figure><p>Perfect, now letâ€™s implement our methods and do some debugging!</p>\n<p>Now for <em>tilting </em>our platform, we can just go through our platform and then for each instance of O we can try to move it upward in column till we get another O or # and then move on the nextÂ one!</p>\n<p>Here, some code for that with an Tile(Enum) to keep codeÂ tidy!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/913/1*fWqLKIbBKhFVktMvw-91yA.png\"></figure><p>Letâ€™s debug and see if it is working correctly, and actually we can write a test case just to verify the tilt_platform function:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*U9TuX8mNBSaOOsBuB6blYg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>âœ… tilt_platform passed<br><br>[Done] exited with code=0 in 0.087 seconds</pre>\n<p>Letâ€™s see a beautiful visualisation of platform tilting to north as we hÌ¶uÌ¶mÌ¶aÌ¶nÌ¶sÌ¶ coders can appreciate:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/904/1*gsgUbXWQEr5EphznMC5EZA.gif\"><figcaption>Beautiful! ğŸ¤©</figcaption></figure><p>Now, letâ€™s implement our load calculation function, as itâ€™s clear from our visualization above, all we need to do is to sum(number of \"Oâ€ rocks * number of rows from the rock to the south edge of the platform)</p>\n<p>Letâ€™s write some code, seems prettyÂ simple:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/714/1*iLx15Och0NPYHbtj8_lScA.png\"></figure><p>And letâ€™s run both of our testÂ cases?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>âœ… tilt_platform passed<br>âœ… calculate_load_on_north_beam passed<br><br>[Done] exited with code=0 in 0.056 seconds</pre>\n<p>Noice! Pretty quick as well. Letâ€™s load up our puzzle input and run thisÂ code?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/864/1*X3PIZqqBOkUklyqIjKRwhg.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>â—ï¸ Total load on the north beam is XXXXXX<br><br>[Done] exited with code=0 in 0.07 seconds</pre>\n<p>We get an answer, letâ€™s input this in our answer box, I have a good feeling about thisÂ one!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/837/1*dnPq69m0hHyjHP_HYBP5WA.png\"><figcaption>Ez! ğŸ•¶</figcaption></figure><p>Hereâ€™s our code till now, we will optimise it in next part, as preoptimization isÂ futile:</p>\n<pre># Day 14 - Parabolic Reflector Dish<br><br>from enum import Enum<br><br><br>class TiltDirection(Enum):<br>    North = 1<br>    South = 2<br>    East = 3<br>    West = 4<br><br><br>class Tile(Enum):<br>    Empty = \".\"<br>    CubeRock = \"#\"<br>    RoundRock = \"O\"<br><br><br>def tilt_platform(platform_state, direction=TiltDirection.North):<br>    # well, we only care about north for now<br>    if direction != TiltDirection.North:<br>        NotImplementedError(\"Only TiltDirection.North is supported for now\")<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    for i, row in enumerate(platform_state):<br>        for j, tile in enumerate(row):<br>            if tile == Tile.RoundRock.value:<br>                # move this rock upwards in column<br>                row_idx, col_idx = i, j<br>                while (<br>                    row_idx - 1 &gt;= 0<br>                    and platform_state[row_idx - 1][col_idx] == Tile.Empty.value<br>                ):<br>                    platform_state[row_idx][col_idx] = Tile.Empty.value<br>                    platform_state[row_idx - 1][col_idx] = Tile.RoundRock.value<br>                    row_idx -= 1<br><br>    return platform_state<br><br><br>def calculate_load_on_north_beam(tilted_platform_state):<br>    total_load = 0<br>    load_factor = len(tilted_platform_state)<br><br>    for row in tilted_platform_state:<br>        total_load += load_factor * row.count(Tile.RoundRock.value)<br>        load_factor -= 1<br><br>    return total_load<br><br><br>def part_one():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"â—ï¸ Total load on the north beam is {total_load}\")<br><br><br>def test_tilt_platform():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state = \"\"\"OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....\"\"\"<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    assert tilted_platform_state == [<br>        list(row) for row in expected_platform_state.split(\"\\n\")<br>    ], f\"Expected {expected_platform_state}, got {tilted_platform_state}\"<br>    print(\"âœ… tilt_platform passed\")<br><br><br>def test_calculate_load_on_north_beam():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 136, f\"Expected 136, got {total_load}\"<br>    print(\"âœ… calculate_load_on_north_beam passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_tilt_platform()<br>    test_calculate_load_on_north_beam()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>The parabolic reflector dish deforms, but not in a way that focuses the beam. To do that, youâ€™ll need to move the rocks to the edges of the platform. Fortunately, a button on the side of the control panel labeled â€œspin cycleâ€ attempts to do justÂ that!</blockquote>\n<blockquote>Each cycle tilts the platform four times so that the rounded rocks roll north, then west, then south, then east. After each tilt, the rounded rocks roll as far as they can before the platform tilts in the next direction. After one cycle, the platform will have finished rolling the rounded rocks in those four directions in thatÂ order.</blockquote>\n<blockquote>Hereâ€™s what happens in the example above after each of the first fewÂ cycles:</blockquote>\n<blockquote>After 1 cycle:<br>.....#....<br>....#...O#<br>...OO##...<br>.OO#......<br>.....OOO#.<br>.O#...O#.#<br>....O#....<br>......OOOO<br>#...O###..<br>#..OO#....</blockquote>\n<blockquote>After 2 cycles:<br>.....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#..OO###..<br>#.OOO#...O</blockquote>\n<blockquote>After 3 cycles:<br>.....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#...O###.O<br>#.OOO#...O</blockquote>\n<blockquote>This process should work if you leave it running long enough, but youâ€™re still worried about the north support beams. To make sure theyâ€™ll survive for a while, you need to calculate the total load on the north support beams after 1000000000 cycles.</blockquote>\n<blockquote>In the above example, after 1000000000 cycles, the total load on the north support beams isÂ 64.</blockquote>\n<blockquote>Run the spin cycle for 1000000000 cycles. Afterward, what is the total load on the north supportÂ beams?</blockquote>\n<p>Well, havenâ€™t we got used to <strong><em>ever increasing exponential scale</em></strong> of Part Two!Â ğŸ‘€</p>\n<blockquote>Letâ€™s diveÂ inâ€¦</blockquote>\n<p>Our foresight of using TiltDirection(Enum) was correct, we do need to tilt in other directions, but thankfully we still only care about north supportÂ beams!</p>\n<p>So, seems like we can to do 1000000000<em>â€Šâ€”â€Š</em>one billion cycles where each cycleÂ means:</p>\n<ul><li>tilts the platform four times so that the rounded rocks roll north, then west, then south, thenÂ east.</li></ul>\n<p>Before thinking how we can optimise without doing 1000000000<em> </em>repeatitions, letâ€™s just implement and test tilt_platform for other 3 directions:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/855/1*MZ2Rq0CVPdg4W7wUW6EUXQ.png\"><figcaption>I know, I know, a lot of dup code, we will fix this in finalÂ code!</figcaption></figure><p>And we can modify our tilt_platform to basically use a switch case to call relevant method. Also, introducing tilt_platform_cycle where we can pass num_cycles where each cycle is definedÂ as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/821/1*fWJS_MwVZqSzcUk7LrUnhQ.png\"></figure><p>Letâ€™s test our tilt code for the base case given in the part 2 of theÂ puzzle:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/945/1*RZdLZKigWqm_uU7xm6zLPQ.png\"></figure><p>Letâ€™s runÂ this?</p>\n<p>Andâ€¦.nope! ItÂ failed!</p>\n<blockquote>ğŸ’¡ Edge case: Well, when we go to tilt_platform_south since itâ€™s traversing from (0,0) -&gt; (i,j) (from top left to bottom right), it wonâ€™t be able to move a O rock if it has another O rock below it, but later in iteration, if we move the bottom most rock of the group, the rocks above it should alsoÂ follow!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OCBi2aYBL7f_-u0WPttdQA.png\"></figure><p>This will never be a problem when we do tilt_platform_north and tilt_platform_west since we are starting from top left aka (0,0) in ourÂ loop.</p>\n<blockquote>ğŸ’­ An easy way to fix this is to, for tilt_platform_south and tilt_platform_east, just iterate from bottom right (i,j) to top left (0,0) and it should automatically take care of the edge cases without having to make our code too complicated!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/340/1*x8Vcicu4SxwSbmynIgbV2w.png\"><figcaption>This shall ensure our group wonâ€™t be blocked by neighbours while tilting east orÂ south.</figcaption></figure><p>After a few debugging sessions! It works!Â ğŸ¤“</p>\n<p>Hereâ€™s a quick visuzliation of 1 cycle, with our platform_state</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/490/1*bwmLqr7lfRMuRQL75ORm6Q.gif\"><figcaption>roll north, then west, then south, thenÂ east.</figcaption></figure><p>Letâ€™s see if our test casesÂ work?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>âœ… tilt_platform_cycle with 1 cycle passed<br>âœ… tilt_platform_cycle with 2 cycles passed<br>âœ… tilt_platform_cycle with 3 cycles passed<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>How about checking our testcaseâ€Šâ€”â€Š1 billion times and see if we get <strong>64 </strong>load as given in theÂ puzzle!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/875/1*c26l8wk3mlidRmkLDsKczQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>âœ… test_calculate_load_on_north_beam passed<br><br>[Done] exited with code=0 in 0.075 seconds</pre>\n<p><strong>0.075 seconds</strong> // Looking at this fast runtime, I am just tempted to run it for <strong>A billion cycles </strong>for the puzzle input as it is just <strong>100x100</strong> and our runtime is justÂ O(nÂ²)!</p>\n<p>Are you game? Yes? Letâ€™s doÂ it!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/890/1*sQ0JUQVJAGh92wVpvW_yag.png\"><figcaption>ğŸ¤</figcaption></figure><p>Well, 3 minutes later, doesnâ€™t seem likely!Â ğŸ¥²</p>\n<p>I should have had put some std::out just to know which cycle our code is on currently! So, added some logging in parallel, just to gauge theÂ speed:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/811/1*FJ_U2UbP7PiDaX8Jhmf6xw.png\"></figure><p>Letâ€™s see how many cycles we do for puzzle input in 10 seconds forÂ fun:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/811/1*FJ_U2UbP7PiDaX8Jhmf6xw.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/922/1*DYYGxjZrRaCwo6PurAc0fw.gif\"><figcaption>~300 cycles in 10Â seconds</figcaption></figure><blockquote>So, it should just take us <strong>33,333,333.33</strong> seconds ~ <strong>555,555.56</strong> minutes ~ <strong>9,259.26</strong> hours ~ <strong>385.80</strong> days, which is just over 1 year!Â ğŸ¤¯</blockquote>\n<p>Yep! Itâ€™s difficult for human brain to estimate large numbers! Letâ€™s optimiseÂ now?!</p>\n<p>One of my early hypothesis is that we are spending so much time tilting our platform_state that we are bound to get repeated inputs for multiple directions! We can probably make it faster by just introducing a cache to track input and output for tilt_platform function!</p>\n<p>Letâ€™s test that, using our same unscientific test above (it will be interesting to see how memory size grows as these are 4 computations per cycle, totalling to <strong>4 billion computations</strong>!):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*shey_5pM8zAz9jdVQeP5Yg.png\"><figcaption>Added cache!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wNLS1z6SOaAlXaFYAsUl2g.gif\"><figcaption>~300 / 10 seconds, noÂ avail!</figcaption></figure><p>Letâ€™s rethink now! Brute force wonâ€™t workÂ clearly!</p>\n<p>I still firmly beleive there has to be some kind of a repeatition after a while and we just need to find the cycleÂ here!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/889/1*7vZuAx0YRT2j69W9IVPM5A.png\"></figure><p>Added some logging, letâ€™s see our testÂ input:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/721/1*1tgBP55O98m1dM-VYS2vrQ.png\"></figure><p>Clearly we can see, there is <strong>some cycle going</strong> onÂ here!</p>\n<blockquote>ğŸ’¡Now, all we need to do is, <strong>find the cycle length</strong> and <strong>find the cycle elements</strong>, and then by the <strong>magic of modulus</strong> % we can directly find the platform_state, as if what it will be after 1000000000 cycles!</blockquote>\n<p>.</p>\n<p>.</p>\n<blockquote>30 minutes and some debugging later!</blockquote>\n<p>.</p>\n<p>.</p>\n<p>Whipped up this <strong>spaghetti</strong> code (I promise, <strong>I will fix</strong>Â this):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yfPl8wqtUZiv9icCAo884g.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>âœ… tilt_platform_cycle with 1 cycle passed<br>âœ… tilt_platform_cycle with 2 cycles passed<br>âœ… tilt_platform_cycle with 3 cycles passed<br>âœ… test_calculate_load_on_north_beam_1000000000_cycles passed<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>Finally! ğŸ™</p>\n<p>Now, letâ€™s run for our puzzleÂ input?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>â€¼ï¸ Total load on the north beam after 1000000000 cycles is XXXXX<br><br>[Done] exited with code=0 in 4.166 seconds</pre>\n<p>We have an answer in <strong>4.166 seconds</strong>, letâ€™s put this in the answer boxÂ andâ€¦</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/957/1*ElrQjU_yhrwuoxyIGDQFWg.png\"><figcaption>Finally ğŸ™</figcaption></figure><p>Hereâ€™s our pythonic and optimized code:</p>\n<pre># Day 14 - Parabolic Reflector Dish<br><br>from enum import Enum<br><br><br>class TiltDirection(Enum):<br>    North = \"NORTH\"<br>    South = \"SOUTH\"<br>    East = \"EAST\"<br>    West = \"WEST\"<br><br><br>class Tile(Enum):<br>    Empty = \".\"<br>    CubeRock = \"#\"<br>    RoundRock = \"O\"<br><br><br>def tilt_platform(platform_state, direction):<br>    rows, cols = len(platform_state), len(platform_state[0])<br>    delta = {<br>        TiltDirection.North: (0, -1),<br>        TiltDirection.South: (0, 1),<br>        TiltDirection.East: (1, 0),<br>        TiltDirection.West: (-1, 0)<br>    }[direction]<br><br>    def is_valid_position(row, col):<br>        return 0 &lt;= row &lt; rows and 0 &lt;= col &lt; cols<br><br>    def move_rock(start_row, start_col):<br>        row, col = start_row, start_col<br>        while is_valid_position(row + delta[1], col + delta[0]) and \\<br>                platform_state[row + delta[1]][col + delta[0]] == Tile.Empty.value:<br>            platform_state[row][col] = Tile.Empty.value<br>            row, col = row + delta[1], col + delta[0]<br>            platform_state[row][col] = Tile.RoundRock.value<br><br>    if direction in [TiltDirection.North, TiltDirection.West]:<br>        range_func = range<br>    else:<br>        range_func = lambda start, end: range(end - 1, start - 1, -1)<br><br>    for i in range_func(0, rows):<br>        for j in range_func(0, cols):<br>            if platform_state[i][j] == Tile.RoundRock.value:<br>                move_rock(i, j)<br><br>    return platform_state<br><br><br>def tilt_platform_cycle(platform_state, num_cycles=1):    <br>    platform_cache = {}  # Cache for storing seen platform states<br>    cycle_patterns = []  # List to store unique states forming a cycle<br>    cycle_start_point = None<br><br><br>    for idx in range(1, num_cycles+1):<br>        # Tilt platform in all directions<br>        for direction in [TiltDirection.North, TiltDirection.West, TiltDirection.South, TiltDirection.East]:<br>            platform_state = tilt_platform(platform_state, direction)<br><br>        # Generate a key for the current state<br>        platform_state_key = \"\\n\".join([\" \".join(map(str, row)) for row in platform_state])<br><br>        # Check if the current state has been seen before<br>        if platform_state_key in platform_cache:<br>            if cycle_start_point is None:<br>                cycle_start_point = platform_cache[platform_state_key]<br>                cycle_patterns.append(platform_state_key)<br>                continue<br><br>            # Start of the cycle found, calculate the index in the cycle pattern<br>            if platform_state_key == cycle_patterns[0]:<br>                cycle_length = len(cycle_patterns)<br>                cycle_index = (num_cycles - cycle_start_point) % cycle_length<br>                return [list(row) for row in cycle_patterns[cycle_index].split(\"\\n\")]<br><br>            # New state in the cycle<br>            if platform_state_key not in cycle_patterns:<br>                cycle_patterns.append(platform_state_key)<br>            continue<br><br>        # Store the new state in the cache<br>        platform_cache[platform_state_key] = idx<br>        if cycle_start_point is not None and platform_state_key not in cycle_patterns:<br>            cycle_patterns.append(platform_state_key)<br><br>    return platform_state<br><br><br>def calculate_load_on_north_beam(tilted_platform_state):<br>    return sum((len(tilted_platform_state) - i) * row.count(Tile.RoundRock.value)<br>               for i, row in enumerate(tilted_platform_state))<br><br><br>def part_one():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"â—ï¸ Total load on the north beam is {total_load}\")<br><br><br>def part_two():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1000000000)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"â€¼ï¸ Total load on the north beam after 1000000000 cycles is {total_load}\")<br><br><br>def test_tilt_platform_cycle():<br>    platform_state_og = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state_with_1_cycle = \"\"\".....#....<br>....#...O#<br>...OO##...<br>.OO#......<br>.....OOO#.<br>.O#...O#.#<br>....O#....<br>......OOOO<br>#...O###..<br>#..OO#....\"\"\"<br><br>    expected_platform_state_with_2_cycles = \"\"\".....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#..OO###..<br>#.OOO#...O\"\"\"<br><br>    expected_platform_state_with_3_cycles = \"\"\".....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#...O###.O<br>#.OOO#...O\"\"\"<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_1_cycle = [<br>        list(row) for row in expected_platform_state_with_1_cycle.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_1_cycle<br>    ), f\"Expected {expected_platform_state_with_1_cycle}, got {tilted_platform_state}\"<br>    print(\"âœ… tilt_platform_cycle with 1 cycle passed\")<br><br>    # reseting platform_state<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_2_cycles = [<br>        list(row) for row in expected_platform_state_with_2_cycles.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 2)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_2_cycles<br>    ), f\"Expected {expected_platform_state_with_2_cycles}, got {tilted_platform_state}\"<br>    print(\"âœ… tilt_platform_cycle with 2 cycles passed\")<br><br>    # reseting platform_state<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_3_cycles = [<br>        list(row) for row in expected_platform_state_with_3_cycles.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 3)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_3_cycles<br>    ), f\"Expected {expected_platform_state_with_3_cycles}, got {tilted_platform_state}\"<br>    print(\"âœ… tilt_platform_cycle with 3 cycles passed\")<br><br><br>def test_tilt_platform():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state = \"\"\"OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    assert tilted_platform_state == [<br>        list(row) for row in expected_platform_state.split(\"\\n\")<br>    ], f\"Expected {expected_platform_state}, got {tilted_platform_state}\"<br>    print(\"âœ… tilt_platform passed\")<br><br><br>def test_calculate_load_on_north_beam():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 136, f\"Expected 136, got {total_load}\"<br>    print(\"âœ… test_calculate_load_on_north_beam passed\")<br><br><br>def test_calculate_load_on_north_beam_1000000000_cycles():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1000000000)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 64, f\"Expected 64, got {total_load}\"<br>    print(\"âœ… test_calculate_load_on_north_beam_1000000000_cycles passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_tilt_platform()<br>    test_calculate_load_on_north_beam()<br>    part_one()<br><br>    test_tilt_platform_cycle()<br>    test_calculate_load_on_north_beam_1000000000_cycles()<br>    part_two()</pre>\n<p>I am sure there is more juice left to squeeze as we can further optimize this, but I am tired now! I will most likely <strong>come back</strong> during holidays to optimise this to atleast <strong>sub-second computeÂ time</strong>.</p>\n<p>Stay tuned!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved theÂ problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machineÂ ğŸ‘‡</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! ğŸ„</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=10760f12f5a5\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*zkAVIfrKih2TgfjK\"><figcaption>Parabolic Reflector Dish (via DALL-EÂ 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/14\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You reach the place where all of the mirrors were pointing: a massive <a href=\"https://en.wikipedia.org/wiki/Parabolic_reflector\">parabolic reflector dish</a> attached to the side of another large mountain.</blockquote>\n<blockquote>The dish is made up of many small mirrors, but while the mirrors themselves are roughly in the shape of a parabolic reflector dish, each individual mirror seems to be pointing in slightly the wrong direction. If the dish is meant to focus light, all itâ€™s doing right now is sending it in a vague direction.</blockquote>\n<blockquote>This system must be what provides the energy for the lava! If you focus the reflector dish, maybe you can go where itâ€™s pointing and use the light to fix the lava production.</blockquote>\n<blockquote>Upon closer inspection, the individual mirrors each appear to be connected via an elaborate system of ropes and pulleys to a large metal platform below the dish. The platform is covered in large rocks of various shapes. Depending on their position, the weight of the rocks deforms the platform, and the shape of the platform controls which ropes move and ultimately the focus of theÂ dish.</blockquote>\n<blockquote>In short: if you move the rocks, you can focus the dish. The platform even has a control panel on the side that lets you tilt it in one of four directions! The rounded rocks (O) will roll when the platform is tilted, while the cube-shaped rocks (#) will stay in place. You note the positions of all of the empty spaces (.) and rocks (your puzzle input). ForÂ example:</blockquote>\n<blockquote>O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....</blockquote>\n<blockquote>Start by tilting the lever so all of the rocks will slide north as far as they willÂ go:</blockquote>\n<blockquote>OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....</blockquote>\n<blockquote>You notice that the support beams along the north side of the platform are damaged; to ensure the platform doesnâ€™t collapse, you should calculate the total load on the north supportÂ beams.</blockquote>\n<blockquote>The amount of load caused by a single rounded rock (O) is equal to the number of rows from the rock to the south edge of the platform, including the row the rock is on. (Cube-shaped rocks (#) don't contribute to load.) So, the amount of load caused by each rock in each row is asÂ follows:</blockquote>\n<blockquote>OOOO.#.O.. 10<br>OO..#....# 9<br>OO..O##..O 8<br>O..#.OO... 7<br>........#. 6<br>..#....#.# 5<br>..O..#.O.O 4<br>..O....... 3<br>#....###.. 2<br>#....#.... 1</blockquote>\n<blockquote>The total load is the sum of the load caused by all of the rounded rocks. In this example, the total load isÂ 136.</blockquote>\n<blockquote>Tilt the platform so that the rounded rocks all roll north. Afterward, what is the total load on the north supportÂ beams?</blockquote>\n<p>Cool! Letâ€™s review the problem in terms of <strong><em>chronology</em></strong> and we shall break down what needs to be done to get ourÂ answer?</p>\n<p>We have <strong>2 types ofÂ rocks</strong>:</p>\n<ul>\n<li># <strong>Cube shape rocks</strong>, that stay inÂ place</li>\n<li>O <strong>Rounded rocks</strong>, thatÂ rolls!</li>\n</ul>\n<p>Given an initial state of platform represented by a 2D matrix, we need to ensure that the north side beam <strong>can handle the load</strong> if we start to tilt the platform, so we can need to <strong>calculate the state of platform</strong> when it is tilted towards North direction!</p>\n<p>Letâ€™s see a quickÂ viz:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/733/1*34Iz-l6OzH6JvCKvO1pHvw.png\"></figure><p>We can observe how all O rocks have <strong>moved along their columns towards North</strong> while # have stayedÂ put.</p>\n<p>And then, base case allows us to calculate the load bearing capacity of the north support beam by sum(number of \"Oâ€ rocks * number of rows from the rock to the south edge of the platform), like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/852/1*z7xNWvYhuVnAf6N5fmV2xA.png\"></figure><p>So, we need to write code in 2Â parts:</p>\n<ol>\n<li>To <strong>generate</strong> the north_tilted state</li>\n<li>To <strong>calculate</strong> the total load on northÂ beam</li>\n</ol>\n<p>But first, letâ€™s write the base test case along with some skelton code to structure our thoughtÂ process:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/817/1*dTdlYQQC_kV6EXaKXAOr4g.png\"></figure><p>Perfect, now letâ€™s implement our methods and do some debugging!</p>\n<p>Now for <em>tilting </em>our platform, we can just go through our platform and then for each instance of O we can try to move it upward in column till we get another O or # and then move on the nextÂ one!</p>\n<p>Here, some code for that with an Tile(Enum) to keep codeÂ tidy!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/913/1*fWqLKIbBKhFVktMvw-91yA.png\"></figure><p>Letâ€™s debug and see if it is working correctly, and actually we can write a test case just to verify the tilt_platform function:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*U9TuX8mNBSaOOsBuB6blYg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>âœ… tilt_platform passed<br><br>[Done] exited with code=0 in 0.087 seconds</pre>\n<p>Letâ€™s see a beautiful visualisation of platform tilting to north as we hÌ¶uÌ¶mÌ¶aÌ¶nÌ¶sÌ¶ coders can appreciate:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/904/1*gsgUbXWQEr5EphznMC5EZA.gif\"><figcaption>Beautiful! ğŸ¤©</figcaption></figure><p>Now, letâ€™s implement our load calculation function, as itâ€™s clear from our visualization above, all we need to do is to sum(number of \"Oâ€ rocks * number of rows from the rock to the south edge of the platform)</p>\n<p>Letâ€™s write some code, seems prettyÂ simple:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/714/1*iLx15Och0NPYHbtj8_lScA.png\"></figure><p>And letâ€™s run both of our testÂ cases?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>âœ… tilt_platform passed<br>âœ… calculate_load_on_north_beam passed<br><br>[Done] exited with code=0 in 0.056 seconds</pre>\n<p>Noice! Pretty quick as well. Letâ€™s load up our puzzle input and run thisÂ code?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/864/1*X3PIZqqBOkUklyqIjKRwhg.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>â—ï¸ Total load on the north beam is XXXXXX<br><br>[Done] exited with code=0 in 0.07 seconds</pre>\n<p>We get an answer, letâ€™s input this in our answer box, I have a good feeling about thisÂ one!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/837/1*dnPq69m0hHyjHP_HYBP5WA.png\"><figcaption>Ez! ğŸ•¶</figcaption></figure><p>Hereâ€™s our code till now, we will optimise it in next part, as preoptimization isÂ futile:</p>\n<pre># Day 14 - Parabolic Reflector Dish<br><br>from enum import Enum<br><br><br>class TiltDirection(Enum):<br>    North = 1<br>    South = 2<br>    East = 3<br>    West = 4<br><br><br>class Tile(Enum):<br>    Empty = \".\"<br>    CubeRock = \"#\"<br>    RoundRock = \"O\"<br><br><br>def tilt_platform(platform_state, direction=TiltDirection.North):<br>    # well, we only care about north for now<br>    if direction != TiltDirection.North:<br>        NotImplementedError(\"Only TiltDirection.North is supported for now\")<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    for i, row in enumerate(platform_state):<br>        for j, tile in enumerate(row):<br>            if tile == Tile.RoundRock.value:<br>                # move this rock upwards in column<br>                row_idx, col_idx = i, j<br>                while (<br>                    row_idx - 1 &gt;= 0<br>                    and platform_state[row_idx - 1][col_idx] == Tile.Empty.value<br>                ):<br>                    platform_state[row_idx][col_idx] = Tile.Empty.value<br>                    platform_state[row_idx - 1][col_idx] = Tile.RoundRock.value<br>                    row_idx -= 1<br><br>    return platform_state<br><br><br>def calculate_load_on_north_beam(tilted_platform_state):<br>    total_load = 0<br>    load_factor = len(tilted_platform_state)<br><br>    for row in tilted_platform_state:<br>        total_load += load_factor * row.count(Tile.RoundRock.value)<br>        load_factor -= 1<br><br>    return total_load<br><br><br>def part_one():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"â—ï¸ Total load on the north beam is {total_load}\")<br><br><br>def test_tilt_platform():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state = \"\"\"OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....\"\"\"<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    assert tilted_platform_state == [<br>        list(row) for row in expected_platform_state.split(\"\\n\")<br>    ], f\"Expected {expected_platform_state}, got {tilted_platform_state}\"<br>    print(\"âœ… tilt_platform passed\")<br><br><br>def test_calculate_load_on_north_beam():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 136, f\"Expected 136, got {total_load}\"<br>    print(\"âœ… calculate_load_on_north_beam passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_tilt_platform()<br>    test_calculate_load_on_north_beam()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>The parabolic reflector dish deforms, but not in a way that focuses the beam. To do that, youâ€™ll need to move the rocks to the edges of the platform. Fortunately, a button on the side of the control panel labeled â€œspin cycleâ€ attempts to do justÂ that!</blockquote>\n<blockquote>Each cycle tilts the platform four times so that the rounded rocks roll north, then west, then south, then east. After each tilt, the rounded rocks roll as far as they can before the platform tilts in the next direction. After one cycle, the platform will have finished rolling the rounded rocks in those four directions in thatÂ order.</blockquote>\n<blockquote>Hereâ€™s what happens in the example above after each of the first fewÂ cycles:</blockquote>\n<blockquote>After 1 cycle:<br>.....#....<br>....#...O#<br>...OO##...<br>.OO#......<br>.....OOO#.<br>.O#...O#.#<br>....O#....<br>......OOOO<br>#...O###..<br>#..OO#....</blockquote>\n<blockquote>After 2 cycles:<br>.....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#..OO###..<br>#.OOO#...O</blockquote>\n<blockquote>After 3 cycles:<br>.....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#...O###.O<br>#.OOO#...O</blockquote>\n<blockquote>This process should work if you leave it running long enough, but youâ€™re still worried about the north support beams. To make sure theyâ€™ll survive for a while, you need to calculate the total load on the north support beams after 1000000000 cycles.</blockquote>\n<blockquote>In the above example, after 1000000000 cycles, the total load on the north support beams isÂ 64.</blockquote>\n<blockquote>Run the spin cycle for 1000000000 cycles. Afterward, what is the total load on the north supportÂ beams?</blockquote>\n<p>Well, havenâ€™t we got used to <strong><em>ever increasing exponential scale</em></strong> of Part Two!Â ğŸ‘€</p>\n<blockquote>Letâ€™s diveÂ inâ€¦</blockquote>\n<p>Our foresight of using TiltDirection(Enum) was correct, we do need to tilt in other directions, but thankfully we still only care about north supportÂ beams!</p>\n<p>So, seems like we can to do 1000000000<em>â€Šâ€”â€Š</em>one billion cycles where each cycleÂ means:</p>\n<ul><li>tilts the platform four times so that the rounded rocks roll north, then west, then south, thenÂ east.</li></ul>\n<p>Before thinking how we can optimise without doing 1000000000<em> </em>repeatitions, letâ€™s just implement and test tilt_platform for other 3 directions:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/855/1*MZ2Rq0CVPdg4W7wUW6EUXQ.png\"><figcaption>I know, I know, a lot of dup code, we will fix this in finalÂ code!</figcaption></figure><p>And we can modify our tilt_platform to basically use a switch case to call relevant method. Also, introducing tilt_platform_cycle where we can pass num_cycles where each cycle is definedÂ as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/821/1*fWJS_MwVZqSzcUk7LrUnhQ.png\"></figure><p>Letâ€™s test our tilt code for the base case given in the part 2 of theÂ puzzle:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/945/1*RZdLZKigWqm_uU7xm6zLPQ.png\"></figure><p>Letâ€™s runÂ this?</p>\n<p>Andâ€¦.nope! ItÂ failed!</p>\n<blockquote>ğŸ’¡ Edge case: Well, when we go to tilt_platform_south since itâ€™s traversing from (0,0) -&gt; (i,j) (from top left to bottom right), it wonâ€™t be able to move a O rock if it has another O rock below it, but later in iteration, if we move the bottom most rock of the group, the rocks above it should alsoÂ follow!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OCBi2aYBL7f_-u0WPttdQA.png\"></figure><p>This will never be a problem when we do tilt_platform_north and tilt_platform_west since we are starting from top left aka (0,0) in ourÂ loop.</p>\n<blockquote>ğŸ’­ An easy way to fix this is to, for tilt_platform_south and tilt_platform_east, just iterate from bottom right (i,j) to top left (0,0) and it should automatically take care of the edge cases without having to make our code too complicated!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/340/1*x8Vcicu4SxwSbmynIgbV2w.png\"><figcaption>This shall ensure our group wonâ€™t be blocked by neighbours while tilting east orÂ south.</figcaption></figure><p>After a few debugging sessions! It works!Â ğŸ¤“</p>\n<p>Hereâ€™s a quick visuzliation of 1 cycle, with our platform_state</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/490/1*bwmLqr7lfRMuRQL75ORm6Q.gif\"><figcaption>roll north, then west, then south, thenÂ east.</figcaption></figure><p>Letâ€™s see if our test casesÂ work?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>âœ… tilt_platform_cycle with 1 cycle passed<br>âœ… tilt_platform_cycle with 2 cycles passed<br>âœ… tilt_platform_cycle with 3 cycles passed<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>How about checking our testcaseâ€Šâ€”â€Š1 billion times and see if we get <strong>64 </strong>load as given in theÂ puzzle!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/875/1*c26l8wk3mlidRmkLDsKczQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>âœ… test_calculate_load_on_north_beam passed<br><br>[Done] exited with code=0 in 0.075 seconds</pre>\n<p><strong>0.075 seconds</strong> // Looking at this fast runtime, I am just tempted to run it for <strong>A billion cycles </strong>for the puzzle input as it is just <strong>100x100</strong> and our runtime is justÂ O(nÂ²)!</p>\n<p>Are you game? Yes? Letâ€™s doÂ it!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/890/1*sQ0JUQVJAGh92wVpvW_yag.png\"><figcaption>ğŸ¤</figcaption></figure><p>Well, 3 minutes later, doesnâ€™t seem likely!Â ğŸ¥²</p>\n<p>I should have had put some std::out just to know which cycle our code is on currently! So, added some logging in parallel, just to gauge theÂ speed:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/811/1*FJ_U2UbP7PiDaX8Jhmf6xw.png\"></figure><p>Letâ€™s see how many cycles we do for puzzle input in 10 seconds forÂ fun:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/811/1*FJ_U2UbP7PiDaX8Jhmf6xw.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/922/1*DYYGxjZrRaCwo6PurAc0fw.gif\"><figcaption>~300 cycles in 10Â seconds</figcaption></figure><blockquote>So, it should just take us <strong>33,333,333.33</strong> seconds ~ <strong>555,555.56</strong> minutes ~ <strong>9,259.26</strong> hours ~ <strong>385.80</strong> days, which is just over 1 year!Â ğŸ¤¯</blockquote>\n<p>Yep! Itâ€™s difficult for human brain to estimate large numbers! Letâ€™s optimiseÂ now?!</p>\n<p>One of my early hypothesis is that we are spending so much time tilting our platform_state that we are bound to get repeated inputs for multiple directions! We can probably make it faster by just introducing a cache to track input and output for tilt_platform function!</p>\n<p>Letâ€™s test that, using our same unscientific test above (it will be interesting to see how memory size grows as these are 4 computations per cycle, totalling to <strong>4 billion computations</strong>!):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*shey_5pM8zAz9jdVQeP5Yg.png\"><figcaption>Added cache!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wNLS1z6SOaAlXaFYAsUl2g.gif\"><figcaption>~300 / 10 seconds, noÂ avail!</figcaption></figure><p>Letâ€™s rethink now! Brute force wonâ€™t workÂ clearly!</p>\n<p>I still firmly beleive there has to be some kind of a repeatition after a while and we just need to find the cycleÂ here!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/889/1*7vZuAx0YRT2j69W9IVPM5A.png\"></figure><p>Added some logging, letâ€™s see our testÂ input:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/721/1*1tgBP55O98m1dM-VYS2vrQ.png\"></figure><p>Clearly we can see, there is <strong>some cycle going</strong> onÂ here!</p>\n<blockquote>ğŸ’¡Now, all we need to do is, <strong>find the cycle length</strong> and <strong>find the cycle elements</strong>, and then by the <strong>magic of modulus</strong> % we can directly find the platform_state, as if what it will be after 1000000000 cycles!</blockquote>\n<p>.</p>\n<p>.</p>\n<blockquote>30 minutes and some debugging later!</blockquote>\n<p>.</p>\n<p>.</p>\n<p>Whipped up this <strong>spaghetti</strong> code (I promise, <strong>I will fix</strong>Â this):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yfPl8wqtUZiv9icCAo884g.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>âœ… tilt_platform_cycle with 1 cycle passed<br>âœ… tilt_platform_cycle with 2 cycles passed<br>âœ… tilt_platform_cycle with 3 cycles passed<br>âœ… test_calculate_load_on_north_beam_1000000000_cycles passed<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>Finally! ğŸ™</p>\n<p>Now, letâ€™s run for our puzzleÂ input?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>â€¼ï¸ Total load on the north beam after 1000000000 cycles is XXXXX<br><br>[Done] exited with code=0 in 4.166 seconds</pre>\n<p>We have an answer in <strong>4.166 seconds</strong>, letâ€™s put this in the answer boxÂ andâ€¦</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/957/1*ElrQjU_yhrwuoxyIGDQFWg.png\"><figcaption>Finally ğŸ™</figcaption></figure><p>Hereâ€™s our pythonic and optimized code:</p>\n<pre># Day 14 - Parabolic Reflector Dish<br><br>from enum import Enum<br><br><br>class TiltDirection(Enum):<br>    North = \"NORTH\"<br>    South = \"SOUTH\"<br>    East = \"EAST\"<br>    West = \"WEST\"<br><br><br>class Tile(Enum):<br>    Empty = \".\"<br>    CubeRock = \"#\"<br>    RoundRock = \"O\"<br><br><br>def tilt_platform(platform_state, direction):<br>    rows, cols = len(platform_state), len(platform_state[0])<br>    delta = {<br>        TiltDirection.North: (0, -1),<br>        TiltDirection.South: (0, 1),<br>        TiltDirection.East: (1, 0),<br>        TiltDirection.West: (-1, 0)<br>    }[direction]<br><br>    def is_valid_position(row, col):<br>        return 0 &lt;= row &lt; rows and 0 &lt;= col &lt; cols<br><br>    def move_rock(start_row, start_col):<br>        row, col = start_row, start_col<br>        while is_valid_position(row + delta[1], col + delta[0]) and \\<br>                platform_state[row + delta[1]][col + delta[0]] == Tile.Empty.value:<br>            platform_state[row][col] = Tile.Empty.value<br>            row, col = row + delta[1], col + delta[0]<br>            platform_state[row][col] = Tile.RoundRock.value<br><br>    if direction in [TiltDirection.North, TiltDirection.West]:<br>        range_func = range<br>    else:<br>        range_func = lambda start, end: range(end - 1, start - 1, -1)<br><br>    for i in range_func(0, rows):<br>        for j in range_func(0, cols):<br>            if platform_state[i][j] == Tile.RoundRock.value:<br>                move_rock(i, j)<br><br>    return platform_state<br><br><br>def tilt_platform_cycle(platform_state, num_cycles=1):    <br>    platform_cache = {}  # Cache for storing seen platform states<br>    cycle_patterns = []  # List to store unique states forming a cycle<br>    cycle_start_point = None<br><br><br>    for idx in range(1, num_cycles+1):<br>        # Tilt platform in all directions<br>        for direction in [TiltDirection.North, TiltDirection.West, TiltDirection.South, TiltDirection.East]:<br>            platform_state = tilt_platform(platform_state, direction)<br><br>        # Generate a key for the current state<br>        platform_state_key = \"\\n\".join([\" \".join(map(str, row)) for row in platform_state])<br><br>        # Check if the current state has been seen before<br>        if platform_state_key in platform_cache:<br>            if cycle_start_point is None:<br>                cycle_start_point = platform_cache[platform_state_key]<br>                cycle_patterns.append(platform_state_key)<br>                continue<br><br>            # Start of the cycle found, calculate the index in the cycle pattern<br>            if platform_state_key == cycle_patterns[0]:<br>                cycle_length = len(cycle_patterns)<br>                cycle_index = (num_cycles - cycle_start_point) % cycle_length<br>                return [list(row) for row in cycle_patterns[cycle_index].split(\"\\n\")]<br><br>            # New state in the cycle<br>            if platform_state_key not in cycle_patterns:<br>                cycle_patterns.append(platform_state_key)<br>            continue<br><br>        # Store the new state in the cache<br>        platform_cache[platform_state_key] = idx<br>        if cycle_start_point is not None and platform_state_key not in cycle_patterns:<br>            cycle_patterns.append(platform_state_key)<br><br>    return platform_state<br><br><br>def calculate_load_on_north_beam(tilted_platform_state):<br>    return sum((len(tilted_platform_state) - i) * row.count(Tile.RoundRock.value)<br>               for i, row in enumerate(tilted_platform_state))<br><br><br>def part_one():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"â—ï¸ Total load on the north beam is {total_load}\")<br><br><br>def part_two():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1000000000)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"â€¼ï¸ Total load on the north beam after 1000000000 cycles is {total_load}\")<br><br><br>def test_tilt_platform_cycle():<br>    platform_state_og = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state_with_1_cycle = \"\"\".....#....<br>....#...O#<br>...OO##...<br>.OO#......<br>.....OOO#.<br>.O#...O#.#<br>....O#....<br>......OOOO<br>#...O###..<br>#..OO#....\"\"\"<br><br>    expected_platform_state_with_2_cycles = \"\"\".....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#..OO###..<br>#.OOO#...O\"\"\"<br><br>    expected_platform_state_with_3_cycles = \"\"\".....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#...O###.O<br>#.OOO#...O\"\"\"<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_1_cycle = [<br>        list(row) for row in expected_platform_state_with_1_cycle.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_1_cycle<br>    ), f\"Expected {expected_platform_state_with_1_cycle}, got {tilted_platform_state}\"<br>    print(\"âœ… tilt_platform_cycle with 1 cycle passed\")<br><br>    # reseting platform_state<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_2_cycles = [<br>        list(row) for row in expected_platform_state_with_2_cycles.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 2)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_2_cycles<br>    ), f\"Expected {expected_platform_state_with_2_cycles}, got {tilted_platform_state}\"<br>    print(\"âœ… tilt_platform_cycle with 2 cycles passed\")<br><br>    # reseting platform_state<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_3_cycles = [<br>        list(row) for row in expected_platform_state_with_3_cycles.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 3)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_3_cycles<br>    ), f\"Expected {expected_platform_state_with_3_cycles}, got {tilted_platform_state}\"<br>    print(\"âœ… tilt_platform_cycle with 3 cycles passed\")<br><br><br>def test_tilt_platform():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state = \"\"\"OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    assert tilted_platform_state == [<br>        list(row) for row in expected_platform_state.split(\"\\n\")<br>    ], f\"Expected {expected_platform_state}, got {tilted_platform_state}\"<br>    print(\"âœ… tilt_platform passed\")<br><br><br>def test_calculate_load_on_north_beam():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 136, f\"Expected 136, got {total_load}\"<br>    print(\"âœ… test_calculate_load_on_north_beam passed\")<br><br><br>def test_calculate_load_on_north_beam_1000000000_cycles():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1000000000)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 64, f\"Expected 64, got {total_load}\"<br>    print(\"âœ… test_calculate_load_on_north_beam_1000000000_cycles passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_tilt_platform()<br>    test_calculate_load_on_north_beam()<br>    part_one()<br><br>    test_tilt_platform_cycle()<br>    test_calculate_load_on_north_beam_1000000000_cycles()<br>    part_two()</pre>\n<p>I am sure there is more juice left to squeeze as we can further optimize this, but I am tired now! I will most likely <strong>come back</strong> during holidays to optimise this to atleast <strong>sub-second computeÂ time</strong>.</p>\n<p>Stay tuned!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved theÂ problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machineÂ ğŸ‘‡</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! ğŸ„</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=10760f12f5a5\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "python",
        "christmas",
        "advent-of-code",
        "problem-solving",
        "advent-of-code-2023"
      ]
    },
    {
      "title": "[Day 13] Point of Incidence // Advent of Code 2023 (Python)",
      "pubDate": "2023-12-20 19:03:57",
      "link": "https://medium.com/@jatinkrmalik/day-13-point-of-incidence-advent-of-code-2023-python-4fea00eb98fb?source=rss-ec576e4b06b0------2",
      "guid": "https://medium.com/p/4fea00eb98fb",
      "author": "Jatin K Malik",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*rfUmh-2ouPC2eg70\"><figcaption>Point of Incidence</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/13\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>With your help, the hot springs team locates an appropriate spring which launches you neatly and precisely up to the edge of LavaÂ Island.</blockquote>\n<blockquote>Thereâ€™s just one problem: you donâ€™t see anyÂ lava.</blockquote>\n<blockquote>You do see a lot of ash and igneous rock; there are even what look like gray mountains scattered around. After a while, you make your way to a nearby cluster of mountains only to discover that the valley between them is completely full of large mirrors. Most of the mirrors seem to be aligned in a consistent way; perhaps you should head in that direction?</blockquote>\n<blockquote>As you move through the valley of mirrors, you find that several of them have fallen from the large metal frames keeping them in place. The mirrors are extremely flat and shiny, and many of the fallen mirrors have lodged into the ash at strange angles. Because the terrain is all one color, itâ€™s hard to tell where itâ€™s safe to walk or where youâ€™re about to run into aÂ mirror.</blockquote>\n<blockquote>You note down the patterns of ash (.) and rocks (#) that you see as you walk (your puzzle input); perhaps by carefully analyzing these patterns, you can figure out where the mirrorsÂ are!</blockquote>\n<blockquote>For example:</blockquote>\n<blockquote>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</blockquote>\n<blockquote>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</blockquote>\n<blockquote>To find the reflection in each pattern, you need to find a perfect reflection across either a horizontal line between two rows or across a vertical line between twoÂ columns.</blockquote>\n<blockquote>In the first pattern, the reflection is across a vertical line between two columns; arrows on each of the two columns point at the line between theÂ columns:</blockquote>\n<blockquote>123456789<br> &gt;&lt; <br>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br> &gt;&lt; <br>123456789</blockquote>\n<blockquote>In this pattern, the line of reflection is the vertical line between columns 5 and 6. Because the vertical line is not perfectly in the middle of the pattern, part of the pattern (column 1) has nowhere to reflect onto and can be ignored; every other column has a reflected column within the pattern and must match exactly: column 2 matches column 9, column 3 matches 8, 4 matches 7, and 5 matchesÂ 6.</blockquote>\n<blockquote>The second pattern reflects across a horizontal lineÂ instead:</blockquote>\n<blockquote>1 #...##..# 1<br>2 #....#..# 2<br>3Â ..##..### 3<br>4v#####.##.v4<br>5^#####.##.^5<br>6Â ..##..### 6<br>7 #....#..# 7</blockquote>\n<blockquote>This pattern reflects across the horizontal line between rows 4 and 5. Row 1 would reflect with a hypothetical row 8, but since thatâ€™s not in the pattern, row 1 doesnâ€™t need to match anything. The remaining rows match: row 2 matches row 7, row 3 matches row 6, and row 4 matches rowÂ 5.</blockquote>\n<blockquote>To summarize your pattern notes, add up the number of columns to the left of each vertical line of reflection; to that, also add 100 multiplied by the number of rows above each horizontal line of reflection. In the above example, the first patternâ€™s vertical line has 5 columns to its left and the second pattern's horizontal line has 4 rows above it, a total ofÂ 405.</blockquote>\n<blockquote>Find the line of reflection in each of the patterns in your notes. What number do you get after summarizing all of yourÂ notes?</blockquote>\n<blockquote>A mirror maze?! I have always loved them since childhood!</blockquote>\n<p>Letâ€™s understand the problem! We are given a pattern of ash (.) and rocks (#) and we need to figure out a line of mirrors which can be either be in between rows or columns casting a perfect reflection in ourÂ pattern!</p>\n<p>Letâ€™s study the example with a visualization, for the givenÂ input:</p>\n<pre>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</pre>\n<p>We can observe that the line of reflection is in b/w 5th and 6th column and our 1st column can beÂ ignored!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/858/1*w9RqnyQzNe7fby2oGhrycw.png\"><figcaption>Pattern 1</figcaption></figure><p>Similarly, for anotherÂ example:</p>\n<pre>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</pre>\n<p>We can see that line of reflection is in b/w 4th and 5th row and our 1st row can beÂ ignored!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/523/1*OpsohpC1DbR87xeu16gqMw.png\"><figcaption>Pattern 2</figcaption></figure><p>Now, the puzzle wants us to summarize these patterns and addÂ up:</p>\n<ul>\n<li>the <strong>number of columns</strong> to the <strong>left of each vertical line of reflection</strong>\n</li>\n<li>add <strong>100 multiplied</strong> by the number of <strong>rows</strong> <strong>above each horizontal line of reflection</strong>\n</li>\n</ul>\n<p>So, for the given example, the answerÂ becomes:</p>\n<blockquote>5 (pattern 1) + 4 (pattern 2) * 100 =Â 405</blockquote>\n<p>This is pretty interesting! My mind is trying to wander toward the Palindrome approach, especially for even numbers, but let me first write some test code for the base case givenÂ above!</p>\n<blockquote>ğŸ’¡ A quick analysis of puzzle input shows that we will have multiple patterns to process, so we will structure our code accordingly!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/543/1*e2OU1KdkRb9On0B06VUUQQ.png\"></figure><p>Letâ€™s write code now, as mentioned, my initial idea is to just follow the naive palindrome approach, where I will try to compare ch[i] == ch[i-1] and will do a fan out approach to go both ways till we run out ofÂ bounds:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/583/1*OV0bZhDBM5J44Ujz5284JA.png\"></figure><p>Now we can adapt the same approach to go <strong>row by row</strong>, and then if not found, we go <strong>column by column </strong>and then return the point as per the calculation for horizontal line v/s vertical line as per theÂ puzzle.</p>\n<p>.</p>\n<p>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*kwZ5gQR1bAGMWsA00gb9ow.png\"></figure><p>Few debugging sessionsÂ later!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>âœ… summarize_pattern passed<br><br>[Done] exited with code=0 in 0.065 seconds</pre>\n<p>This is a bit bruteforce approach, but seems pretty fast for 2 patterns, 0.065 seconds, letâ€™s load up our puzzle input and see how it runs as we seem to only have 100 patterns!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iAnwZ7o1zY1wgny3evWzyQ.png\"><figcaption>I am sure there will be a nutty edge case somewhere inÂ here!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/682/1*tysBMJDX-Q6_Mfq1wSeY4Q.png\"><figcaption>Letâ€™s run this!Â ğŸ¤</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>â—ï¸ Summarizing all patterns in Part 1: XXXXXX<br><br>[Done] exited with code=0 in 0.051 seconds</pre>\n<p>Woah! We have an answer in just <strong>0.051</strong> seconds!Â ğŸ¤¯</p>\n<p>Letâ€™s input this in the answer boxÂ andâ€¦.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/879/1*H4vBV50RauNGTNK_qEO3aA.png\"><figcaption>ğŸ‘¯â€â™€ï¸ğŸ‘¯â€â™€ï¸ğŸ‘¯â€â™€ï¸</figcaption></figure><p>Correct in first try and with an amazing runtime! Though I am sure as soon as I click on Part Two, itâ€™s going to wreck our code!Â ğŸ¤“</p>\n<p>Hereâ€™s our raw code till now, we will optimise it in Part 2, likeÂ always:</p>\n<pre># Day 13 - Point of Incidence<br><br>from enum import Enum<br><br>class Mode(Enum):<br>    ROW = \"row\"<br>    COLUMN = \"column\"<br><br>def is_perfect_reflection(prev, next, pattern, mode):<br>    if mode == Mode.ROW:<br>        while prev &gt;= 0 and next &lt; len(pattern):<br>            if pattern[prev] != pattern[next]:<br>                return False<br>            prev -= 1<br>            next += 1<br><br>        return True<br><br>    elif mode == Mode.COLUMN:<br>        while prev &gt;= 0 and next &lt; len(pattern[0]):<br>            for i in range(len(pattern)):<br>                if pattern[i][prev] != pattern[i][next]:<br>                    return False<br>            prev -= 1<br>            next += 1<br><br>        return True<br><br>    raise Exception(\"Invalid mode\")<br><br>def find_point_of_reflection(pattern, mode):<br>    if mode == Mode.ROW:<br>        for i in range(1, len(pattern)):<br>            if pattern[i-1] == pattern[i]:<br>                if is_perfect_reflection(i-1, i, pattern, Mode.ROW):<br>                    return i<br><br>    if mode == Mode.COLUMN:<br>        for j in range(1, len(pattern[0])):<br>            prev_col, next_col = [], []<br>            for i in range(0, len(pattern)):<br>                prev_col.append(pattern[i][j-1])<br>                next_col.append(pattern[i][j])<br>            if prev_col == next_col:<br>                if is_perfect_reflection(j-1, j, pattern, Mode.COLUMN):<br>                    return j<br><br>def analyze_pattern(pattern):<br>    pattern_grid = [list(row) for row in pattern.strip().split(\"\\n\")]<br><br>    # Find the point of reflection row by row<br>    point = find_point_of_reflection(pattern_grid, Mode.ROW)<br>    if point:<br>        return point * 100<br><br>    # Find the point of reflection column by column<br>    point = find_point_of_reflection(pattern_grid, Mode.COLUMN)<br>    if point:<br>        return point<br><br>    raise Exception(\"No point of reflection found\")<br><br>def summarize_patterns(patterns):<br>    sum = 0<br>    for pattern in patterns.split(\"\\n\\n\"):<br>        sum += analyze_pattern(pattern)<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns)<br><br>    print(f\"â—ï¸ Summarizing all patterns in Part 1: {sum}\")<br><br>def test_summarize_patterns():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br>    sum = summarize_patterns(patterns)<br>    assert sum == 405, f\"Expected 405, got {sum}\"<br>    print(\"âœ… summarize_pattern passed\")<br><br>if __name__ == \"__main__\":<br>    test_summarize_patterns()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>You resume walking through the valley of mirrors andâ€Šâ€”â€ŠSMACK!â€Šâ€”â€Šrun directly into one. Hopefully nobody was watching, because that must have been pretty embarrassing.</blockquote>\n<blockquote>Upon closer inspection, you discover that every mirror has exactly one smudge: exactly oneÂ . or # should be the oppositeÂ type.</blockquote>\n<blockquote>In each pattern, youâ€™ll need to locate and fix the smudge that causes a different reflection line to be valid. (The old reflection line wonâ€™t necessarily continue being valid after the smudge isÂ fixed.)</blockquote>\n<blockquote>Hereâ€™s the above exampleÂ again:</blockquote>\n<blockquote>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</blockquote>\n<blockquote>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</blockquote>\n<blockquote>The first patternâ€™s smudge is in the top-left corner. If the top-left #were insteadÂ ., it would have a different, horizontal line of reflection:</blockquote>\n<blockquote>1Â ..##..##. 1<br>2Â ..#.##.#. 2<br>3v##......#v3<br>4^##......#^4<br>5Â ..#.##.#. 5<br>6Â ..##..##. 6<br>7 #.#.##.#. 7</blockquote>\n<blockquote>With the smudge in the top-left corner repaired, a new horizontal line of reflection between rows 3 and 4 now exists. Row 7 has no corresponding reflected row and can be ignored, but every other row matches exactly: row 1 matches row 6, row 2 matches row 5, and row 3 matches rowÂ 4.</blockquote>\n<blockquote>In the second pattern, the smudge can be fixed by changing the fifth symbol on row 2 fromÂ . toÂ #:</blockquote>\n<blockquote>1v#...##..#v1<br>2^#...##..#^2<br>3Â ..##..### 3<br>4 #####.##. 4<br>5 #####.##. 5<br>6Â ..##..### 6<br>7 #....#..# 7</blockquote>\n<blockquote>Now, the pattern has a different horizontal line of reflection between rows 1 andÂ 2.</blockquote>\n<blockquote>Summarize your notes as before, but instead use the new different reflection lines. In this example, the first patternâ€™s new horizontal line has 3 rows above it and the second patternâ€™s new horizontal line has 1 row above it, summarizing to the valueÂ 400.</blockquote>\n<blockquote>In each pattern, fix the smudge and find the different line of reflection. What number do you get after summarizing the new reflection line in each pattern in yourÂ notes?</blockquote>\n<p>Andâ€¦</p>\n<blockquote>every mirror has exactly one smudge: exactly oneÂ . or # should be the oppositeÂ type.</blockquote>\n<p>We are back to permutations and combinations! ğŸª¦</p>\n<p>ğŸ’­ Carrying on with our brute force approach, since our code was pretty blazing fast, we can extend our solution by adding some extra steps andÂ loops.</p>\n<p>Introducing â€˜smudgesâ€™, where exactly one character in each pattern is incorrect and needs to be flipped to find a new line of reflection. We can follow theseÂ steps:</p>\n<ol>\n<li>\n<strong>Identify the Smudge</strong>: Iterate through each cell of the pattern. <br> a. For each cell, flip its value (fromÂ . to # or vice versa) <br> b. then check if this change results in a <strong>valid reflection line different from the original</strong>. <br> c. if <strong>yes</strong>, this is the <strong>smudge</strong> we need to fix, else <strong>continue</strong>Â loop</li>\n<li>\n<strong>Summarize the Patterns</strong>: Calculate the summary based on the new reflection lines.</li>\n</ol>\n<p>Letâ€™s tryÂ this?</p>\n<blockquote>ğŸ’¡This approaches hinges upon the fact that puzzle states, thereâ€™s exactly 1 smudge in eachÂ pattern!</blockquote>\n<blockquote>â—ï¸Edge case: We need to ensure, that everytime we find a new reflection point, we need to compare it with original reflection point along with the mode, as sometimes the value can be same, but it can be for rows and columns respectively.<br>(new_reflection_point, mode)Â != (original_reflection_point, original_mode)</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IZm5QwQGOZ_qbTGbAbsJKg.png\"><figcaption>Tons of debugging later!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SB6a_qv-iqZ9-sSvoaGStw.png\"><figcaption>Masterpiece!</figcaption></figure><p>Letâ€™s see if it works for our new testÂ case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/579/1*ozPJTOamPgPqdVYvEUUHUQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>âœ… summarize_pattern_with_smudges passed<br><br>[Done] exited with code=0 in 0.071 seconds</pre>\n<p>âœ… in just <strong>0.071 seconds</strong>! This gives meÂ hope!</p>\n<p>Letâ€™s run it for the puzzleÂ input?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>â€¼ï¸ Summarizing all patterns in Part 2: XXXXX<br><br>[Done] exited with code=0 in 0.281 seconds</pre>\n<p>Done! Letâ€™s see if our answer is correct?Â ğŸ‘€</p>\n<p>Andâ€¦</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*-GgwQaaV9TTLNX0awHsjbg.png\"><figcaption>ğŸ¥</figcaption></figure><p>Hereâ€™s our code with a bruteforce approach, works pretty quick on my M1 Macbook Pro. I might come back later to solve this in a more novel way, but since I am already running behind in AdventOfCode, I will just move on!Â ğŸ˜ƒ</p>\n<pre># Day 13 - Point of Incidence<br><br>from enum import Enum<br>import itertools<br><br><br>class Mode(Enum):<br>    ROW = \"row\"<br>    COLUMN = \"column\"<br><br><br>class MirrorPatternAnalyzer:<br>    def __init__(self, pattern):<br>        self.pattern = [list(row) for row in pattern.strip().split(\"\\n\")]<br><br>    @staticmethod<br>    def flip_char(char):<br>        return \"#\" if char == \".\" else \".\"<br><br>    def is_perfect_reflection(self, index, mode):<br>        if mode == Mode.ROW:<br>            prev, next = index - 1, index<br>            while prev &gt;= 0 and next &lt; len(self.pattern):<br>                if self.pattern[prev] != self.pattern[next]:<br>                    return False<br>                prev -= 1<br>                next += 1<br>            return True<br><br>        elif mode == Mode.COLUMN:<br>            prev, next = index - 1, index<br>            while prev &gt;= 0 and next &lt; len(self.pattern[0]):<br>                if any(<br>                    self.pattern[row][prev] != self.pattern[row][next]<br>                    for row in range(len(self.pattern))<br>                ):<br>                    return False<br>                prev -= 1<br>                next += 1<br>            return True<br><br>        raise ValueError(\"Invalid mode\")<br><br>    def find_point_of_reflection(self, mode):<br>        range_to_check = range(<br>            1, len(self.pattern) if mode == Mode.ROW else len(self.pattern[0])<br>        )<br>        for i in range_to_check:<br>            if self.is_perfect_reflection(i, mode):<br>                return i<br>        return None<br><br>    def try_fix_smudge_and_find_reflection(<br>        self, original_reflection_point, original_mode<br>    ):<br>        for i in range(len(self.pattern)):<br>            for j in range(len(self.pattern[i])):<br>                self.pattern[i][j] = MirrorPatternAnalyzer.flip_char(self.pattern[i][j])<br>                for mode in [Mode.ROW, Mode.COLUMN]:<br>                    new_reflection_point = self.find_point_of_reflection(mode)<br>                    if new_reflection_point and (new_reflection_point, mode) != (<br>                        original_reflection_point,<br>                        original_mode,<br>                    ):<br>                        return new_reflection_point, mode<br>                self.pattern[i][j] = MirrorPatternAnalyzer.flip_char(self.pattern[i][j])<br>        return original_reflection_point, original_mode<br><br>    def analyze(self, with_smudge=False):<br>        for mode in [Mode.ROW, Mode.COLUMN]:<br>            reflection_point = self.find_point_of_reflection(mode)<br>            if reflection_point is not None:<br>                if with_smudge:<br>                    (<br>                        new_reflection_point,<br>                        new_mode,<br>                    ) = self.try_fix_smudge_and_find_reflection(reflection_point, mode)<br>                    if new_mode == Mode.ROW:<br>                        return new_reflection_point * 100<br>                    else:<br>                        return new_reflection_point<br>                else:<br>                    return (<br>                        reflection_point * 100 if mode == Mode.ROW else reflection_point<br>                    )<br>        raise Exception(\"No valid reflection line found\")<br><br><br>def summarize_patterns(patterns, with_smudges=False):<br>    total_sum = 0<br>    for i, pattern in enumerate(patterns.split(\"\\n\\n\")):<br>        analyzer = MirrorPatternAnalyzer(pattern)<br>        total_sum += analyzer.analyze(with_smudge=with_smudges)<br>    return total_sum<br><br><br>def part_one():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns)<br><br>    print(f\"â—ï¸ Summarizing all patterns in Part 1: {sum}\")<br><br><br>def test_summarize_patterns():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br>    sum = summarize_patterns(patterns)<br>    assert sum == 405, f\"Expected 405, got {sum}\"<br>    print(\"âœ… summarize_pattern passed\")<br><br><br>def part_two():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns, with_smudges=True)<br>    print(f\"â€¼ï¸ Summarizing all patterns in Part 2: {sum}\")<br><br><br>def test_summarize_patterns_with_smudges():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br><br>    sum = summarize_patterns(patterns, with_smudges=True)<br>    assert sum == 400, f\"Expected 400, got {sum}\"<br>    print(\"âœ… summarize_pattern_with_smudges passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_summarize_patterns()<br>    part_one()<br><br>    test_summarize_patterns_with_smudges()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved theÂ problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machineÂ ğŸ‘‡</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! ğŸ„</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4fea00eb98fb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*rfUmh-2ouPC2eg70\"><figcaption>Point of Incidence</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/13\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>With your help, the hot springs team locates an appropriate spring which launches you neatly and precisely up to the edge of LavaÂ Island.</blockquote>\n<blockquote>Thereâ€™s just one problem: you donâ€™t see anyÂ lava.</blockquote>\n<blockquote>You do see a lot of ash and igneous rock; there are even what look like gray mountains scattered around. After a while, you make your way to a nearby cluster of mountains only to discover that the valley between them is completely full of large mirrors. Most of the mirrors seem to be aligned in a consistent way; perhaps you should head in that direction?</blockquote>\n<blockquote>As you move through the valley of mirrors, you find that several of them have fallen from the large metal frames keeping them in place. The mirrors are extremely flat and shiny, and many of the fallen mirrors have lodged into the ash at strange angles. Because the terrain is all one color, itâ€™s hard to tell where itâ€™s safe to walk or where youâ€™re about to run into aÂ mirror.</blockquote>\n<blockquote>You note down the patterns of ash (.) and rocks (#) that you see as you walk (your puzzle input); perhaps by carefully analyzing these patterns, you can figure out where the mirrorsÂ are!</blockquote>\n<blockquote>For example:</blockquote>\n<blockquote>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</blockquote>\n<blockquote>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</blockquote>\n<blockquote>To find the reflection in each pattern, you need to find a perfect reflection across either a horizontal line between two rows or across a vertical line between twoÂ columns.</blockquote>\n<blockquote>In the first pattern, the reflection is across a vertical line between two columns; arrows on each of the two columns point at the line between theÂ columns:</blockquote>\n<blockquote>123456789<br> &gt;&lt; <br>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br> &gt;&lt; <br>123456789</blockquote>\n<blockquote>In this pattern, the line of reflection is the vertical line between columns 5 and 6. Because the vertical line is not perfectly in the middle of the pattern, part of the pattern (column 1) has nowhere to reflect onto and can be ignored; every other column has a reflected column within the pattern and must match exactly: column 2 matches column 9, column 3 matches 8, 4 matches 7, and 5 matchesÂ 6.</blockquote>\n<blockquote>The second pattern reflects across a horizontal lineÂ instead:</blockquote>\n<blockquote>1 #...##..# 1<br>2 #....#..# 2<br>3Â ..##..### 3<br>4v#####.##.v4<br>5^#####.##.^5<br>6Â ..##..### 6<br>7 #....#..# 7</blockquote>\n<blockquote>This pattern reflects across the horizontal line between rows 4 and 5. Row 1 would reflect with a hypothetical row 8, but since thatâ€™s not in the pattern, row 1 doesnâ€™t need to match anything. The remaining rows match: row 2 matches row 7, row 3 matches row 6, and row 4 matches rowÂ 5.</blockquote>\n<blockquote>To summarize your pattern notes, add up the number of columns to the left of each vertical line of reflection; to that, also add 100 multiplied by the number of rows above each horizontal line of reflection. In the above example, the first patternâ€™s vertical line has 5 columns to its left and the second pattern's horizontal line has 4 rows above it, a total ofÂ 405.</blockquote>\n<blockquote>Find the line of reflection in each of the patterns in your notes. What number do you get after summarizing all of yourÂ notes?</blockquote>\n<blockquote>A mirror maze?! I have always loved them since childhood!</blockquote>\n<p>Letâ€™s understand the problem! We are given a pattern of ash (.) and rocks (#) and we need to figure out a line of mirrors which can be either be in between rows or columns casting a perfect reflection in ourÂ pattern!</p>\n<p>Letâ€™s study the example with a visualization, for the givenÂ input:</p>\n<pre>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</pre>\n<p>We can observe that the line of reflection is in b/w 5th and 6th column and our 1st column can beÂ ignored!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/858/1*w9RqnyQzNe7fby2oGhrycw.png\"><figcaption>Pattern 1</figcaption></figure><p>Similarly, for anotherÂ example:</p>\n<pre>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</pre>\n<p>We can see that line of reflection is in b/w 4th and 5th row and our 1st row can beÂ ignored!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/523/1*OpsohpC1DbR87xeu16gqMw.png\"><figcaption>Pattern 2</figcaption></figure><p>Now, the puzzle wants us to summarize these patterns and addÂ up:</p>\n<ul>\n<li>the <strong>number of columns</strong> to the <strong>left of each vertical line of reflection</strong>\n</li>\n<li>add <strong>100 multiplied</strong> by the number of <strong>rows</strong> <strong>above each horizontal line of reflection</strong>\n</li>\n</ul>\n<p>So, for the given example, the answerÂ becomes:</p>\n<blockquote>5 (pattern 1) + 4 (pattern 2) * 100 =Â 405</blockquote>\n<p>This is pretty interesting! My mind is trying to wander toward the Palindrome approach, especially for even numbers, but let me first write some test code for the base case givenÂ above!</p>\n<blockquote>ğŸ’¡ A quick analysis of puzzle input shows that we will have multiple patterns to process, so we will structure our code accordingly!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/543/1*e2OU1KdkRb9On0B06VUUQQ.png\"></figure><p>Letâ€™s write code now, as mentioned, my initial idea is to just follow the naive palindrome approach, where I will try to compare ch[i] == ch[i-1] and will do a fan out approach to go both ways till we run out ofÂ bounds:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/583/1*OV0bZhDBM5J44Ujz5284JA.png\"></figure><p>Now we can adapt the same approach to go <strong>row by row</strong>, and then if not found, we go <strong>column by column </strong>and then return the point as per the calculation for horizontal line v/s vertical line as per theÂ puzzle.</p>\n<p>.</p>\n<p>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*kwZ5gQR1bAGMWsA00gb9ow.png\"></figure><p>Few debugging sessionsÂ later!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>âœ… summarize_pattern passed<br><br>[Done] exited with code=0 in 0.065 seconds</pre>\n<p>This is a bit bruteforce approach, but seems pretty fast for 2 patterns, 0.065 seconds, letâ€™s load up our puzzle input and see how it runs as we seem to only have 100 patterns!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iAnwZ7o1zY1wgny3evWzyQ.png\"><figcaption>I am sure there will be a nutty edge case somewhere inÂ here!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/682/1*tysBMJDX-Q6_Mfq1wSeY4Q.png\"><figcaption>Letâ€™s run this!Â ğŸ¤</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>â—ï¸ Summarizing all patterns in Part 1: XXXXXX<br><br>[Done] exited with code=0 in 0.051 seconds</pre>\n<p>Woah! We have an answer in just <strong>0.051</strong> seconds!Â ğŸ¤¯</p>\n<p>Letâ€™s input this in the answer boxÂ andâ€¦.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/879/1*H4vBV50RauNGTNK_qEO3aA.png\"><figcaption>ğŸ‘¯â€â™€ï¸ğŸ‘¯â€â™€ï¸ğŸ‘¯â€â™€ï¸</figcaption></figure><p>Correct in first try and with an amazing runtime! Though I am sure as soon as I click on Part Two, itâ€™s going to wreck our code!Â ğŸ¤“</p>\n<p>Hereâ€™s our raw code till now, we will optimise it in Part 2, likeÂ always:</p>\n<pre># Day 13 - Point of Incidence<br><br>from enum import Enum<br><br>class Mode(Enum):<br>    ROW = \"row\"<br>    COLUMN = \"column\"<br><br>def is_perfect_reflection(prev, next, pattern, mode):<br>    if mode == Mode.ROW:<br>        while prev &gt;= 0 and next &lt; len(pattern):<br>            if pattern[prev] != pattern[next]:<br>                return False<br>            prev -= 1<br>            next += 1<br><br>        return True<br><br>    elif mode == Mode.COLUMN:<br>        while prev &gt;= 0 and next &lt; len(pattern[0]):<br>            for i in range(len(pattern)):<br>                if pattern[i][prev] != pattern[i][next]:<br>                    return False<br>            prev -= 1<br>            next += 1<br><br>        return True<br><br>    raise Exception(\"Invalid mode\")<br><br>def find_point_of_reflection(pattern, mode):<br>    if mode == Mode.ROW:<br>        for i in range(1, len(pattern)):<br>            if pattern[i-1] == pattern[i]:<br>                if is_perfect_reflection(i-1, i, pattern, Mode.ROW):<br>                    return i<br><br>    if mode == Mode.COLUMN:<br>        for j in range(1, len(pattern[0])):<br>            prev_col, next_col = [], []<br>            for i in range(0, len(pattern)):<br>                prev_col.append(pattern[i][j-1])<br>                next_col.append(pattern[i][j])<br>            if prev_col == next_col:<br>                if is_perfect_reflection(j-1, j, pattern, Mode.COLUMN):<br>                    return j<br><br>def analyze_pattern(pattern):<br>    pattern_grid = [list(row) for row in pattern.strip().split(\"\\n\")]<br><br>    # Find the point of reflection row by row<br>    point = find_point_of_reflection(pattern_grid, Mode.ROW)<br>    if point:<br>        return point * 100<br><br>    # Find the point of reflection column by column<br>    point = find_point_of_reflection(pattern_grid, Mode.COLUMN)<br>    if point:<br>        return point<br><br>    raise Exception(\"No point of reflection found\")<br><br>def summarize_patterns(patterns):<br>    sum = 0<br>    for pattern in patterns.split(\"\\n\\n\"):<br>        sum += analyze_pattern(pattern)<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns)<br><br>    print(f\"â—ï¸ Summarizing all patterns in Part 1: {sum}\")<br><br>def test_summarize_patterns():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br>    sum = summarize_patterns(patterns)<br>    assert sum == 405, f\"Expected 405, got {sum}\"<br>    print(\"âœ… summarize_pattern passed\")<br><br>if __name__ == \"__main__\":<br>    test_summarize_patterns()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>You resume walking through the valley of mirrors andâ€Šâ€”â€ŠSMACK!â€Šâ€”â€Šrun directly into one. Hopefully nobody was watching, because that must have been pretty embarrassing.</blockquote>\n<blockquote>Upon closer inspection, you discover that every mirror has exactly one smudge: exactly oneÂ . or # should be the oppositeÂ type.</blockquote>\n<blockquote>In each pattern, youâ€™ll need to locate and fix the smudge that causes a different reflection line to be valid. (The old reflection line wonâ€™t necessarily continue being valid after the smudge isÂ fixed.)</blockquote>\n<blockquote>Hereâ€™s the above exampleÂ again:</blockquote>\n<blockquote>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</blockquote>\n<blockquote>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</blockquote>\n<blockquote>The first patternâ€™s smudge is in the top-left corner. If the top-left #were insteadÂ ., it would have a different, horizontal line of reflection:</blockquote>\n<blockquote>1Â ..##..##. 1<br>2Â ..#.##.#. 2<br>3v##......#v3<br>4^##......#^4<br>5Â ..#.##.#. 5<br>6Â ..##..##. 6<br>7 #.#.##.#. 7</blockquote>\n<blockquote>With the smudge in the top-left corner repaired, a new horizontal line of reflection between rows 3 and 4 now exists. Row 7 has no corresponding reflected row and can be ignored, but every other row matches exactly: row 1 matches row 6, row 2 matches row 5, and row 3 matches rowÂ 4.</blockquote>\n<blockquote>In the second pattern, the smudge can be fixed by changing the fifth symbol on row 2 fromÂ . toÂ #:</blockquote>\n<blockquote>1v#...##..#v1<br>2^#...##..#^2<br>3Â ..##..### 3<br>4 #####.##. 4<br>5 #####.##. 5<br>6Â ..##..### 6<br>7 #....#..# 7</blockquote>\n<blockquote>Now, the pattern has a different horizontal line of reflection between rows 1 andÂ 2.</blockquote>\n<blockquote>Summarize your notes as before, but instead use the new different reflection lines. In this example, the first patternâ€™s new horizontal line has 3 rows above it and the second patternâ€™s new horizontal line has 1 row above it, summarizing to the valueÂ 400.</blockquote>\n<blockquote>In each pattern, fix the smudge and find the different line of reflection. What number do you get after summarizing the new reflection line in each pattern in yourÂ notes?</blockquote>\n<p>Andâ€¦</p>\n<blockquote>every mirror has exactly one smudge: exactly oneÂ . or # should be the oppositeÂ type.</blockquote>\n<p>We are back to permutations and combinations! ğŸª¦</p>\n<p>ğŸ’­ Carrying on with our brute force approach, since our code was pretty blazing fast, we can extend our solution by adding some extra steps andÂ loops.</p>\n<p>Introducing â€˜smudgesâ€™, where exactly one character in each pattern is incorrect and needs to be flipped to find a new line of reflection. We can follow theseÂ steps:</p>\n<ol>\n<li>\n<strong>Identify the Smudge</strong>: Iterate through each cell of the pattern. <br> a. For each cell, flip its value (fromÂ . to # or vice versa) <br> b. then check if this change results in a <strong>valid reflection line different from the original</strong>. <br> c. if <strong>yes</strong>, this is the <strong>smudge</strong> we need to fix, else <strong>continue</strong>Â loop</li>\n<li>\n<strong>Summarize the Patterns</strong>: Calculate the summary based on the new reflection lines.</li>\n</ol>\n<p>Letâ€™s tryÂ this?</p>\n<blockquote>ğŸ’¡This approaches hinges upon the fact that puzzle states, thereâ€™s exactly 1 smudge in eachÂ pattern!</blockquote>\n<blockquote>â—ï¸Edge case: We need to ensure, that everytime we find a new reflection point, we need to compare it with original reflection point along with the mode, as sometimes the value can be same, but it can be for rows and columns respectively.<br>(new_reflection_point, mode)Â != (original_reflection_point, original_mode)</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IZm5QwQGOZ_qbTGbAbsJKg.png\"><figcaption>Tons of debugging later!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SB6a_qv-iqZ9-sSvoaGStw.png\"><figcaption>Masterpiece!</figcaption></figure><p>Letâ€™s see if it works for our new testÂ case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/579/1*ozPJTOamPgPqdVYvEUUHUQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>âœ… summarize_pattern_with_smudges passed<br><br>[Done] exited with code=0 in 0.071 seconds</pre>\n<p>âœ… in just <strong>0.071 seconds</strong>! This gives meÂ hope!</p>\n<p>Letâ€™s run it for the puzzleÂ input?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>â€¼ï¸ Summarizing all patterns in Part 2: XXXXX<br><br>[Done] exited with code=0 in 0.281 seconds</pre>\n<p>Done! Letâ€™s see if our answer is correct?Â ğŸ‘€</p>\n<p>Andâ€¦</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*-GgwQaaV9TTLNX0awHsjbg.png\"><figcaption>ğŸ¥</figcaption></figure><p>Hereâ€™s our code with a bruteforce approach, works pretty quick on my M1 Macbook Pro. I might come back later to solve this in a more novel way, but since I am already running behind in AdventOfCode, I will just move on!Â ğŸ˜ƒ</p>\n<pre># Day 13 - Point of Incidence<br><br>from enum import Enum<br>import itertools<br><br><br>class Mode(Enum):<br>    ROW = \"row\"<br>    COLUMN = \"column\"<br><br><br>class MirrorPatternAnalyzer:<br>    def __init__(self, pattern):<br>        self.pattern = [list(row) for row in pattern.strip().split(\"\\n\")]<br><br>    @staticmethod<br>    def flip_char(char):<br>        return \"#\" if char == \".\" else \".\"<br><br>    def is_perfect_reflection(self, index, mode):<br>        if mode == Mode.ROW:<br>            prev, next = index - 1, index<br>            while prev &gt;= 0 and next &lt; len(self.pattern):<br>                if self.pattern[prev] != self.pattern[next]:<br>                    return False<br>                prev -= 1<br>                next += 1<br>            return True<br><br>        elif mode == Mode.COLUMN:<br>            prev, next = index - 1, index<br>            while prev &gt;= 0 and next &lt; len(self.pattern[0]):<br>                if any(<br>                    self.pattern[row][prev] != self.pattern[row][next]<br>                    for row in range(len(self.pattern))<br>                ):<br>                    return False<br>                prev -= 1<br>                next += 1<br>            return True<br><br>        raise ValueError(\"Invalid mode\")<br><br>    def find_point_of_reflection(self, mode):<br>        range_to_check = range(<br>            1, len(self.pattern) if mode == Mode.ROW else len(self.pattern[0])<br>        )<br>        for i in range_to_check:<br>            if self.is_perfect_reflection(i, mode):<br>                return i<br>        return None<br><br>    def try_fix_smudge_and_find_reflection(<br>        self, original_reflection_point, original_mode<br>    ):<br>        for i in range(len(self.pattern)):<br>            for j in range(len(self.pattern[i])):<br>                self.pattern[i][j] = MirrorPatternAnalyzer.flip_char(self.pattern[i][j])<br>                for mode in [Mode.ROW, Mode.COLUMN]:<br>                    new_reflection_point = self.find_point_of_reflection(mode)<br>                    if new_reflection_point and (new_reflection_point, mode) != (<br>                        original_reflection_point,<br>                        original_mode,<br>                    ):<br>                        return new_reflection_point, mode<br>                self.pattern[i][j] = MirrorPatternAnalyzer.flip_char(self.pattern[i][j])<br>        return original_reflection_point, original_mode<br><br>    def analyze(self, with_smudge=False):<br>        for mode in [Mode.ROW, Mode.COLUMN]:<br>            reflection_point = self.find_point_of_reflection(mode)<br>            if reflection_point is not None:<br>                if with_smudge:<br>                    (<br>                        new_reflection_point,<br>                        new_mode,<br>                    ) = self.try_fix_smudge_and_find_reflection(reflection_point, mode)<br>                    if new_mode == Mode.ROW:<br>                        return new_reflection_point * 100<br>                    else:<br>                        return new_reflection_point<br>                else:<br>                    return (<br>                        reflection_point * 100 if mode == Mode.ROW else reflection_point<br>                    )<br>        raise Exception(\"No valid reflection line found\")<br><br><br>def summarize_patterns(patterns, with_smudges=False):<br>    total_sum = 0<br>    for i, pattern in enumerate(patterns.split(\"\\n\\n\")):<br>        analyzer = MirrorPatternAnalyzer(pattern)<br>        total_sum += analyzer.analyze(with_smudge=with_smudges)<br>    return total_sum<br><br><br>def part_one():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns)<br><br>    print(f\"â—ï¸ Summarizing all patterns in Part 1: {sum}\")<br><br><br>def test_summarize_patterns():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br>    sum = summarize_patterns(patterns)<br>    assert sum == 405, f\"Expected 405, got {sum}\"<br>    print(\"âœ… summarize_pattern passed\")<br><br><br>def part_two():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns, with_smudges=True)<br>    print(f\"â€¼ï¸ Summarizing all patterns in Part 2: {sum}\")<br><br><br>def test_summarize_patterns_with_smudges():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br><br>    sum = summarize_patterns(patterns, with_smudges=True)<br>    assert sum == 400, f\"Expected 400, got {sum}\"<br>    print(\"âœ… summarize_pattern_with_smudges passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_summarize_patterns()<br>    part_one()<br><br>    test_summarize_patterns_with_smudges()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved theÂ problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machineÂ ğŸ‘‡</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! ğŸ„</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4fea00eb98fb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "python",
        "advent-of-code-2023",
        "advent-of-code",
        "christmas"
      ]
    },
    {
      "title": "[Day 12] Hot Springs // Advent of Code 2023 (Python)",
      "pubDate": "2023-12-19 14:46:59",
      "link": "https://medium.com/@jatinkrmalik/day-12-hot-springs-advent-of-code-2023-python-77506773abfb?source=rss-ec576e4b06b0------2",
      "guid": "https://medium.com/p/77506773abfb",
      "author": "Jatin K Malik",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*2qyq_T4PoQxHVYw9\"><figcaption>Hot Springs (via DALL-EÂ 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/12\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You finally reach the hot springs! You can see steam rising from secluded areas attached to the primary, ornate building.</blockquote>\n<blockquote>As you turn to enter, the <a href=\"https://adventofcode.com/2023/day/11\">researcher</a> stops you. â€œWaitâ€Šâ€”â€ŠI thought you were looking for the hot springs, werenâ€™t you?â€ You indicate that this definitely looks like hot springs toÂ you.</blockquote>\n<blockquote>â€œOh, sorry, common mistake! This is actually the <a href=\"https://en.wikipedia.org/wiki/Onsen\">onsen</a>! The hot springs are nextÂ door.â€</blockquote>\n<blockquote>You look in the direction the researcher is pointing and suddenly notice the massive metal helixes towering overhead. â€œThisÂ way!â€</blockquote>\n<blockquote>It only takes you a few more steps to reach the main gate of the massive fenced-off area containing the springs. You go through the gate and into a small administrative building.</blockquote>\n<blockquote>â€œHello! What brings you to the hot springs today? Sorry theyâ€™re not very hot right now; weâ€™re having a lava shortage at the moment.â€ You ask about the missing machine parts for DesertÂ Island.</blockquote>\n<blockquote>â€œOh, all of Gear Island is currently offline! Nothing is being manufactured at the moment, not until we get more lava to heat our forges. And our springs. The springs arenâ€™t very springy unless theyâ€™reÂ hot!â€</blockquote>\n<blockquote>â€œSay, could you go up and see why the lava stopped flowing? The springs are too cold for normal operation, but we should be able to find one springy enough to launch you upÂ there!â€</blockquote>\n<blockquote>Thereâ€™s just one problemâ€Šâ€”â€Šmany of the springs have fallen into disrepair, so theyâ€™re not actually sure which springs would even be safe to use! Worse yet, their condition records of which springs are damaged (your puzzle input) are also damaged! Youâ€™ll need to help them repair the damagedÂ records.</blockquote>\n<blockquote>In the giant field just outside, the springs are arranged into rows. For each row, the condition records show every spring and whether it is operational (.) or damaged (#). This is the part of the condition records that is itself damaged; for some springs, it is simply unknown (?) whether the spring is operational orÂ damaged.</blockquote>\n<blockquote>However, the engineer that produced the condition records also duplicated some of this information in a different format! After the list of springs for a given row, the size of each contiguous group of damaged springs is listed in the order those groups appear in the row. This list always accounts for every damaged spring, and each number is the entire size of its contiguous group (that is, groups are always separated by at least one operational spring: #### would always be 4, neverÂ 2,2).</blockquote>\n<blockquote>So, condition records with no unknown spring conditions might look likeÂ this:</blockquote>\n<blockquote>#.#.### 1,1,3<br>.#...#....###. 1,1,3<br>.#.###.#.###### 1,3,1,6<br>####.#...#... 4,1,1<br>#....######..#####. 1,6,5<br>.###.##....# 3,2,1</blockquote>\n<blockquote>However, the condition records are partially damaged; some of the springsâ€™ conditions are actually unknown (?). ForÂ example:</blockquote>\n<blockquote>???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1</blockquote>\n<blockquote>Equipped with this information, it is your job to figure out how many different arrangements of operational and broken springs fit the given criteria in eachÂ row.</blockquote>\n<blockquote>In the first line (???.### 1,1,3), there is exactly one way separate groups of one, one, and three broken springs (in that order) can appear in that row: the first three unknown springs must be broken, then operational, then broken (#.#), making the whole rowÂ #.#.###.</blockquote>\n<blockquote>The second line is more interesting:Â .??..??...?##. 1,1,3 could be a total of four different arrangements. The lastÂ ? must always be broken (to satisfy the final contiguous group of three broken springs), and eachÂ ??must hide exactly one of the two broken springs. (NeitherÂ ?? could be both broken springs or they would form a single contiguous group of two; if that were true, the numbers afterward would have been 2,3 instead.) Since eachÂ ?? can either be #. orÂ .#, there are four possible arrangements ofÂ springs.</blockquote>\n<blockquote>The last line is actually consistent with ten different arrangements! Because the first number is 3, the first and secondÂ ? must both beÂ . (if either were #, the first number would have to be 4 or higher). However, the remaining run of unknown spring conditions have many different ways they could hold groups of two and one brokenÂ springs:</blockquote>\n<blockquote>?###???????? 3,2,1<br>.###.##.#...<br>.###.##..#..<br>.###.##...#.<br>.###.##....#<br>.###..##.#..<br>.###..##..#.<br>.###..##...#<br>.###...##.#.<br>.###...##..#<br>.###....##.#</blockquote>\n<blockquote>In this example, the number of possible arrangements for each rowÂ is:</blockquote>\n<blockquote>???.### 1,1,3 - 1 arrangement</blockquote>\n<blockquote>.??..??...?##. 1,1,3 - 4 arrangements</blockquote>\n<blockquote>?#?#?#?#?#?#?#? 1,3,1,6 - 1 arrangement</blockquote>\n<blockquote>????.#...#... 4,1,1 - 1 arrangement</blockquote>\n<blockquote>????.######..#####. 1,6,5 - 4 arrangements</blockquote>\n<blockquote>?###???????? 3,2,1 - 10 arrangements</blockquote>\n<blockquote>Adding all of the possible arrangement counts together produces a total of 21 arrangements.</blockquote>\n<blockquote>For each row, count all of the different arrangements of operational and broken springs that meet the given criteria. What is the sum of thoseÂ counts?</blockquote>\n<p>Man! Another permutation and combination problem! It seems like Santa knows what I used to hate during my engineering days!Â ğŸ¤“</p>\n<p>So..letâ€™s break the problem down, and try not to get ahead of ourself unlike <a href=\"https://medium.com/@jatinkrmalik/day-11-cosmic-expansion-advent-of-code-2023-python-6e545dad06bb\">DayÂ 11</a>!</p>\n<p>In an ideal world, our spring records look something likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HEfawkgl3UkaXOujYeYvhQ.png\"></figure><p>But, since the condition records are partially damaged, some of the springsâ€™ conditions are actually unknownÂ (?):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/988/1*msCo829KuU8oXkABUT8D0w.png\"><figcaption>where `?` denotes the unknownÂ state</figcaption></figure><p>ğŸ’¡ So, before we start talking about combinations possible and all, I think we should assume the ideal case, and write a simple validator that validates the spring_state (left) with damaged_spring_record (right). And this case be our baseÂ case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*cs0D_12A8fOC34O7FBHgWg.png\"><figcaption>Quick prototying inÂ REPL</figcaption></figure><p>Hereâ€™s our testÂ case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/795/1*6xYRS2whEuMWeyeqQwio_Q.png\"></figure><p>And hereâ€™s some shabby code just to validate theÂ idea:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/774/1*7IpkGhEBWW00mcYWRbWosQ.png\"></figure><p>Letâ€™s run this, and we can validate that it indeedÂ works!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>âœ… OK: #.#.### 1,1,3<br>âœ… OK: .#...#....###. 1,1,3<br>âœ… OK: .#.###.#.###### 1,3,1,6<br>âœ… OK: ####.#...#... 4,1,1<br>âœ… OK: #....######..#####. 1,6,5<br>âœ… OK: .###.##....# 3,2,1<br><br>[Done] exited with code=0 in 0.097 seconds</pre>\n<p>So, now that we know the records are not ideal, but indeed damaged and has a lot of unknowns, we will expand the scope of our thinking.</p>\n<p>Well, itâ€™s clear that our validate_spring_record(spring_record) bool function will play a pivotal role to solve the problem as for an example row from damagedÂ records:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/987/1*yPP9z0Et7UBNJgad-tIfBw.png\"><figcaption>We can use our validator function to help verify correct combinations</figcaption></figure><blockquote>Now, to get all possible combinations, we need to consider eachÂ ? as a place where 2 choices are possible: eitherÂ . or #. This is a classic problem of combinatorics where eachÂ ? represents a <strong>binaryÂ choice</strong>.</blockquote>\n<p>In the example row taken above:Â .??..??â€¦?##.Â , we have a total of 5Â ? present, where each can be replaced byÂ . or # so, mathematically speaking, that yields: <strong><em>2âµ combinations ==Â 32.</em></strong></p>\n<p>ğŸ’­ We can write a function that replaces eachÂ ? in the record with eitherÂ . or #, and then calls itself recursively until allÂ ? have been replaced, using that we can generate all the combinations!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zt0yeaKGXxSM6uAVI9KrNg.png\"></figure><p>Letâ€™s do a quick scriptÂ test?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*oszF9BgfE6OlziW0E3YOyA.png\"><figcaption>Looks good!</figcaption></figure><p>Now, all we need to doÂ is:</p>\n<ol>\n<li>For each spring_state record, generate all_combinations</li>\n<li>For each combination in all_combinations, count validate_spring_record(combination) ==Â true</li>\n<li>sum(for each count of valid combination)</li>\n<li>???</li>\n<li>Profit!</li>\n</ol>\n<blockquote>â—ï¸ Disclaimer: I know this is not the most efficient way, but as always, my first approach is to match a solution to a problem and then try to find optimisations! We will probably have to do that as well, as we are currently generating 2^n combinations where the valid combinations will be superÂ low!</blockquote>\n<p>So, letâ€™s writeÂ ğŸ‘†code:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/957/1*m_JTU9Mlkhm02vv22-ZzFw.png\"></figure><p>And letâ€™s run for our base test case as given in the question:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>Found 1 valid combinations for ???.### 1,1,3<br>Found 4 valid combinations for .??..??...?##. 1,1,3<br>Found 1 valid combinations for ?#?#?#?#?#?#?#? 1,3,1,6<br>Found 1 valid combinations for ????.#...#... 4,1,1<br>Found 4 valid combinations for ????.######..#####. 1,6,5<br>Found 10 valid combinations for ?###???????? 3,2,1<br>âœ… OK - test_sum_spring_record_combinations<br><br>[Done] exited with code=0 in 0.066 seconds</pre>\n<p>Yes!!! Now, letâ€™s load up the puzzle input and try to get an answer?Â ğŸ¤</p>\n<p>Ah, wellâ€¦.this might take some timeâ€¦andâ€¦</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>Found 4 valid combinations for .???#??????#. 6,1<br>Found 2 valid combinations for ???##???##?#??#?#..# 1,14,1<br>Found 2 valid combinations for #??????#????#?###?# 3,1,10,1<br>Found 13 valid combinations for .???????#????. 1,2,1,2<br>Found 4 valid combinations for ?##?.??.???.. 3,2,2<br>Found 1 valid combinations for #.?###?#??. 1,5<br>Found 12 valid combinations for ?#??#??????????.??.? 7,2,3,1<br>Found 1 valid combinations for ???###?#.##??? 8,3<br>...<br>1000 lines later<br>...<br>â—ï¸ Total valid combinations: XXXX<br><br>[Done] exited with code=0 in 49.445 seconds</pre>\n<p>Not bad! An answer in 49.445 seconds shall be considered a win comapred to last fewÂ days!</p>\n<p>Letâ€™s see if this is the corectÂ answers?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/830/1*a3NavRUiuC2ujHUK9wXbRw.png\"><figcaption>YASS!</figcaption></figure><p>Hereâ€™s my code tillÂ now:</p>\n<pre># Day 12: Hot Springs<br><br>from enum import Enum<br><br><br>class SpringState(Enum):<br>    OPERATIONAL = \".\"<br>    DAMAGED = \"#\"<br>    UNKNOWN = \"?\"<br><br><br>def generate_spring_record_combinations(spring_record, index=0):<br>    if index &gt;= len(spring_record):<br>        return [spring_record]<br><br>    if spring_record[index] == SpringState.UNKNOWN.value:<br>        # replace '?' with '.' and combine results<br>        with_operational = generate_spring_record_combinations(<br>            spring_record[:index]<br>            + SpringState.OPERATIONAL.value<br>            + spring_record[index + 1 :],<br>            index + 1,<br>        )<br>        # replace '?' with '#' and combine results<br>        with_damaged = generate_spring_record_combinations(<br>            spring_record[:index]<br>            + SpringState.DAMAGED.value<br>            + spring_record[index + 1 :],<br>            index + 1,<br>        )<br>        return with_operational + with_damaged<br>    else:<br>        # continue recursion for next index<br>        return generate_spring_record_combinations(spring_record, index + 1)<br><br><br>def validate_spring_record(spring_state, damaged_spring_record):<br>    damaged_spring_record = damaged_spring_record.split(\",\")<br>    spring_state = list(spring_state)<br><br>    replica_damaged_spring_record = []<br>    damaged_count = 0<br>    for spring in spring_state:<br>        if spring == SpringState.DAMAGED.value:<br>            damaged_count += 1<br>        else:<br>            if damaged_count &gt; 0:<br>                replica_damaged_spring_record.append(str(damaged_count))<br>                damaged_count = 0<br><br>    if damaged_count &gt; 0:<br>        replica_damaged_spring_record.append(str(damaged_count))<br><br>    return replica_damaged_spring_record == damaged_spring_record<br><br><br>def sum_spring_record_combinations(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        combinations = generate_spring_record_combinations(spring_state)<br>        valid_combinations_length = len(<br>            [<br>                c for c in combinations<br>                if validate_spring_record(c, damaged_spring_record)<br>            ]<br>        )<br>        print(f\"Found {valid_combinations_length} valid combinations for {spring_record}\")<br>        total_combinations += valid_combinations_length<br>    return total_combinations<br><br>def part_one():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    print(f\"â—ï¸ Total valid combinations: {sum}\")<br><br>def test_sum_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    assert sum == 21, f\"âŒ Expected: 21, Actual: {sum}\"<br>    print(\"âœ… OK - test_sum_spring_record_combinations\")<br><br><br>def test_validate_spring_record_ideal():<br>    ideal_spring_condition_records = \"\"\"#.#.### 1,1,3<br>.#...#....###. 1,1,3<br>.#.###.#.###### 1,3,1,6<br>####.#...#... 4,1,1<br>#....######..#####. 1,6,5<br>.###.##....# 3,2,1<br>\"\"\"<br>    for spring_record in ideal_spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        ok = validate_spring_record(spring_state, damaged_spring_record)<br>        assert ok, f\"âŒ Expected: True, Actual: {ok}\"<br>        print(f\"âœ… OK: {spring_record}\")<br>    print(\"âœ… OK - test_validate_spring_record_ideal\")<br><br><br><br>if __name__ == \"__main__\":<br>    # test_validate_spring_record_ideal()<br>    test_sum_spring_record_combinations()<br>    part_one()</pre>\n<blockquote>I am aware that we have a lot of wasted compute that we can optimise here, but letâ€™s move on to part 2 as that usually changes the requirements drastically and then we will combine refactor ourÂ code.</blockquote>\n<h3>Part Two</h3>\n<blockquote>As you look out at the field of springs, you feel like there are way more springs than the condition records list. When you examine the records, you discover that they were actually folded up this wholeÂ time!</blockquote>\n<blockquote>To unfold the records, on each row, replace the list of spring conditions with five copies of itself (separated byÂ ?) and replace the list of contiguous groups of damaged springs with five copies of itself (separated byÂ ,).</blockquote>\n<blockquote>So, thisÂ row:</blockquote>\n<blockquote>.# 1</blockquote>\n<blockquote>Would become:</blockquote>\n<blockquote>.#?.#?.#?.#?.# 1,1,1,1,1</blockquote>\n<blockquote>The first line of the above example wouldÂ become:</blockquote>\n<blockquote>???.###????.###????.###????.###????.### 1,1,3,1,1,3,1,1,3,1,1,3,1,1,3</blockquote>\n<blockquote>In the above example, after unfolding, the number of possible arrangements for some rows is now muchÂ larger:</blockquote>\n<blockquote>???.### 1,1,3 - 1 arrangement</blockquote>\n<blockquote>.??..??...?##. 1,1,3 - 16384 arrangements</blockquote>\n<blockquote>?#?#?#?#?#?#?#? 1,3,1,6 - 1 arrangement</blockquote>\n<blockquote>????.#...#... 4,1,1 - 16 arrangements</blockquote>\n<blockquote>????.######..#####. 1,6,5 - 2500 arrangements</blockquote>\n<blockquote>?###???????? 3,2,1 - 506250 arrangements</blockquote>\n<blockquote>After unfolding, adding all of the possible arrangement counts together producesÂ 525152.</blockquote>\n<blockquote>Unfold your condition records; what is the new sum of possible arrangement counts?</blockquote>\n<p>Aha! Told you. So, now conviniently, springs were actually <strong>folded up </strong>this wholeÂ time!</p>\n<p>To unfold the sequence, we just need to 5x each row of the record, forÂ example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/966/1*s4MTuZ3zRalGpICJhrhfJQ.png\"></figure><p>Clearly, our inefficient code will now not work, as our possible combinations will increase exponentially!</p>\n<blockquote>ğŸ’¡Well, one simple way I can see to reduce computations isÂ to:</blockquote>\n<blockquote>- just integrate the validation logic directly into the combination generation process</blockquote>\n<blockquote>- instead of store all the combinations and then computing length, we can just return the <strong>valid</strong> number of combinations.</blockquote>\n<p>This way, we only generate valid combinations from the start, significantly reducing the number of combinations we need toÂ handle.</p>\n<p>Updating code for that, letâ€™s runÂ it!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>âœ… OK - test_sum_spring_record_combinations<br>â—ï¸ Total valid combinations: 7599<br><br>[Done] exited with code=0 in 48.915 seconds</pre>\n<p>And it saved us a grand total of 49.445â€“48.915 = <strong>~530 msÂ ğŸ˜‚</strong></p>\n<a href=\"https://medium.com/media/05826d1b7bcf41e217ad095add326244/href\">https://medium.com/media/05826d1b7bcf41e217ad095add326244/href</a><p>Breaking down the computation, itâ€™s clear that we are <strong>spending a lot of time in</strong> generating â€œallâ€ the possible combinations of the record. Since we already have the damaged_spring_record, we should be able to use it to basically just generate correct combinations? Or at the least, do an <strong>early return</strong> for the all incorrect ones!Â ğŸ¤”</p>\n<blockquote>The complexity of this problem lies in correctly interpreting the â€˜?â€™ characters while adhering to the constraints set by the <strong><em>damaged_spring_record</em></strong>.</blockquote>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>ğŸ’¡ We need to find a way to <strong>prune of our search space early</strong> when a rule from damaged_spring_record is violated in our recursive process itself! Letâ€™s write our early return conditions using our record while navigating through all possible combinations in our recursive function:</p>\n<ul>\n<li>If the damaged_spring_record is empty, <br>- if any spring is damaged: return 0 <br>- else, returnÂ 1.</li>\n<li>If the spring_state string is empty, <br>- if there are no damaged spring records left to process: return 1<br>- else, returnÂ 0.</li>\n<li>recursively check each spring state and calculate the total number of valid combinations based on whether the current spring is operational, damaged, orÂ unknown.</li>\n</ul>\n<p>And since now alot of search space will have repeated calculations, we can use @cache decorator from functools to memoize the results of the recursive function get_valid_spring_record_combinations in an LRU cache with no sizeÂ limit!</p>\n<blockquote>Python does make caching absolutely simple with these nifty OOTB decorators! ğŸ¤Œ</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SOZFKjkeUP6fDZF42V4Ffw.png\"></figure><p>And here, our is_valid_condition would lookÂ like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/882/1*9jeKFExvbHulJLyT9qmFQQ.png\"></figure><p>â—ï¸ Here, _is_valid_condition returns a boolean value that indicates whether the given spring_state and damaged_spring_record meet the following conditions:</p>\n<ol>\n<li>The first element of damaged_spring_record (which represents the number of damaged springs in the first group) is less than or equal to the length of spring_state. This ensures that there are enough springs in spring_state to account for the first group of damagedÂ springs.</li>\n<li>All springs in spring_state up to the index equal to the first element of damaged_spring_record are not operational. This is checked by ensuring that the OPERATIONAL value of the SpringState Enum is not found in the substring of spring_state that ends at the index equal to the first element of damaged_spring_record.</li>\n<li>Either the first element of damaged_spring_record is equal to the length of spring_state (which means that all springs are damaged), or the spring at the index equal to the first element of damaged_spring_record is not damaged. This ensures that there is no damaged spring immediately after the first group of damagedÂ springs.</li>\n</ol>\n<p>Letâ€™s run this code for our base test case of partÂ 1:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/748/1*Hw9kB_F1vPM-PDxQxMNqwQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>âœ… OK - test_sum_spring_record_combinations<br><br>[Done] exited with code=0 in 0.109 seconds</pre>\n<p>And puzzle input for partÂ 1:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*R7ko8-beeAmE7h8LOHK8ig.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>â—ï¸ Total valid combinations: XXXX<br><br>[Done] exited with code=0 in 0.134 seconds</pre>\n<p>Wow! We get the correct answer in just <strong>0.134 seconds </strong>compare this to our previous brute force approach that took <strong>~49 secondsÂ ğŸ˜¯</strong></p>\n<p>Now, letâ€™s also write our base test case for part 2, where all we need to do is, just increase our input per spring_record * 5Â :</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/796/1*1tR0tV2M9F1FkhO9YmgEhg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>âœ… OK - test_sum_unfolded_spring_record_combinations<br><br>[Done] exited with code=0 in 0.11 seconds</pre>\n<p>Phew! And now letâ€™s do it for part 2, puzzleÂ input:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*KwV2lKEhMMicGv2y4jS69Q.png\"><figcaption>* 5 for unfolding ê©œ</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>â—ï¸ Total valid combinations: XXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.693 seconds</pre>\n<p><strong>Yes! Look at that runtime!Â ğŸš€</strong></p>\n<p>Letâ€™s put this answer in the text box?Â Andâ€¦</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/950/1*HfuXqBmUaJQdhPzx1YC98w.png\"><figcaption>ğŸ’¥</figcaption></figure><p>Hereâ€™s our super optimised code till now, I am not doing object oriented for this one!Â :P</p>\n<pre>from enum import Enum<br>from functools import cache<br><br><br>class SpringState(Enum):<br>    OPERATIONAL = \".\"<br>    DAMAGED = \"#\"<br>    UNKNOWN = \"?\"<br><br><br>@cache<br>def get_valid_spring_record_combinations(spring_state, damaged_spring_record):<br>    if not damaged_spring_record:<br>        if SpringState.DAMAGED.value in spring_state:<br>            return 0<br>        else:<br>            return 1<br><br>    if not spring_state:<br>        if not damaged_spring_record:<br>            return 1<br>        else:<br>            return 0<br><br>    total_combinations = 0<br><br>    # if \".\" or \"?\"<br>    if spring_state[0] in [SpringState.OPERATIONAL.value, SpringState.UNKNOWN.value]:<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state[1:], damaged_spring_record<br>        )<br><br>    # if \"#\" or \"?\"<br>    if spring_state[0] in [SpringState.DAMAGED.value, SpringState.UNKNOWN.value]:<br>        if is_valid_condition(spring_state, damaged_spring_record):<br>            total_combinations += get_valid_spring_record_combinations(<br>                spring_state[damaged_spring_record[0] + 1 :], damaged_spring_record[1:]<br>            )<br><br>    return total_combinations<br><br><br>def is_valid_condition(spring_state, damaged_spring_record):<br>    return (<br>        damaged_spring_record[0] &lt;= len(spring_state)<br>        and SpringState.OPERATIONAL.value<br>        not in spring_state[: damaged_spring_record[0]]<br>        and (<br>            damaged_spring_record[0] == len(spring_state)<br>            or spring_state[damaged_spring_record[0]] != SpringState.DAMAGED.value<br>        )<br>    )<br><br><br>def sum_spring_record_combinations(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        damaged_spring_record = tuple(map(int, damaged_spring_record.split(\",\")))<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state, damaged_spring_record<br>        )<br><br>    return total_combinations<br><br><br>def part_one():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    print(f\"â—ï¸ Total valid combinations: {sum}\")<br><br><br>def sum_spring_record_combinations_unfold(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        damaged_spring_record = tuple(map(int, damaged_spring_record.split(\",\")))<br>        spring_state = \"?\".join([spring_state] * 5)  # unfolding<br>        damaged_spring_record = damaged_spring_record * 5  # unfolding<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state, damaged_spring_record<br>        )<br><br>    return total_combinations<br><br><br>def part_two():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations_unfold(spring_condition_records)<br>    print(f\"â—ï¸ Total valid combinations: {sum}\")<br><br><br>def test_sum_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    assert sum == 21, f\"âŒ Expected: 21, Actual: {sum}\"<br>    print(\"âœ… OK - test_sum_spring_record_combinations\")<br><br><br>def test_sum_unfolded_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations_unfold(spring_condition_records)<br>    assert sum == 525152, f\"âŒ Expected: 525152, Actual: {sum}\"<br>    print(\"âœ… OK - test_sum_unfolded_spring_record_combinations\")<br><br><br>if __name__ == \"__main__\":<br>    test_sum_spring_record_combinations()<br>    part_one()<br><br>    test_sum_unfolded_spring_record_combinations()<br>    part_two()</pre>\n<p>Man! I am learning so much with <strong>#AdventOfCode2023</strong>, itâ€™s beautiful that I am getting to revisit a lot of my engineering days concepts that I donâ€™t get to use in my day to day work while building CRUD apps!Â ğŸ¤“</p>\n<p>Onto the next dayÂ then?!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved theÂ problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machineÂ ğŸ‘‡</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! ğŸ„</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=77506773abfb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*2qyq_T4PoQxHVYw9\"><figcaption>Hot Springs (via DALL-EÂ 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/12\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You finally reach the hot springs! You can see steam rising from secluded areas attached to the primary, ornate building.</blockquote>\n<blockquote>As you turn to enter, the <a href=\"https://adventofcode.com/2023/day/11\">researcher</a> stops you. â€œWaitâ€Šâ€”â€ŠI thought you were looking for the hot springs, werenâ€™t you?â€ You indicate that this definitely looks like hot springs toÂ you.</blockquote>\n<blockquote>â€œOh, sorry, common mistake! This is actually the <a href=\"https://en.wikipedia.org/wiki/Onsen\">onsen</a>! The hot springs are nextÂ door.â€</blockquote>\n<blockquote>You look in the direction the researcher is pointing and suddenly notice the massive metal helixes towering overhead. â€œThisÂ way!â€</blockquote>\n<blockquote>It only takes you a few more steps to reach the main gate of the massive fenced-off area containing the springs. You go through the gate and into a small administrative building.</blockquote>\n<blockquote>â€œHello! What brings you to the hot springs today? Sorry theyâ€™re not very hot right now; weâ€™re having a lava shortage at the moment.â€ You ask about the missing machine parts for DesertÂ Island.</blockquote>\n<blockquote>â€œOh, all of Gear Island is currently offline! Nothing is being manufactured at the moment, not until we get more lava to heat our forges. And our springs. The springs arenâ€™t very springy unless theyâ€™reÂ hot!â€</blockquote>\n<blockquote>â€œSay, could you go up and see why the lava stopped flowing? The springs are too cold for normal operation, but we should be able to find one springy enough to launch you upÂ there!â€</blockquote>\n<blockquote>Thereâ€™s just one problemâ€Šâ€”â€Šmany of the springs have fallen into disrepair, so theyâ€™re not actually sure which springs would even be safe to use! Worse yet, their condition records of which springs are damaged (your puzzle input) are also damaged! Youâ€™ll need to help them repair the damagedÂ records.</blockquote>\n<blockquote>In the giant field just outside, the springs are arranged into rows. For each row, the condition records show every spring and whether it is operational (.) or damaged (#). This is the part of the condition records that is itself damaged; for some springs, it is simply unknown (?) whether the spring is operational orÂ damaged.</blockquote>\n<blockquote>However, the engineer that produced the condition records also duplicated some of this information in a different format! After the list of springs for a given row, the size of each contiguous group of damaged springs is listed in the order those groups appear in the row. This list always accounts for every damaged spring, and each number is the entire size of its contiguous group (that is, groups are always separated by at least one operational spring: #### would always be 4, neverÂ 2,2).</blockquote>\n<blockquote>So, condition records with no unknown spring conditions might look likeÂ this:</blockquote>\n<blockquote>#.#.### 1,1,3<br>.#...#....###. 1,1,3<br>.#.###.#.###### 1,3,1,6<br>####.#...#... 4,1,1<br>#....######..#####. 1,6,5<br>.###.##....# 3,2,1</blockquote>\n<blockquote>However, the condition records are partially damaged; some of the springsâ€™ conditions are actually unknown (?). ForÂ example:</blockquote>\n<blockquote>???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1</blockquote>\n<blockquote>Equipped with this information, it is your job to figure out how many different arrangements of operational and broken springs fit the given criteria in eachÂ row.</blockquote>\n<blockquote>In the first line (???.### 1,1,3), there is exactly one way separate groups of one, one, and three broken springs (in that order) can appear in that row: the first three unknown springs must be broken, then operational, then broken (#.#), making the whole rowÂ #.#.###.</blockquote>\n<blockquote>The second line is more interesting:Â .??..??...?##. 1,1,3 could be a total of four different arrangements. The lastÂ ? must always be broken (to satisfy the final contiguous group of three broken springs), and eachÂ ??must hide exactly one of the two broken springs. (NeitherÂ ?? could be both broken springs or they would form a single contiguous group of two; if that were true, the numbers afterward would have been 2,3 instead.) Since eachÂ ?? can either be #. orÂ .#, there are four possible arrangements ofÂ springs.</blockquote>\n<blockquote>The last line is actually consistent with ten different arrangements! Because the first number is 3, the first and secondÂ ? must both beÂ . (if either were #, the first number would have to be 4 or higher). However, the remaining run of unknown spring conditions have many different ways they could hold groups of two and one brokenÂ springs:</blockquote>\n<blockquote>?###???????? 3,2,1<br>.###.##.#...<br>.###.##..#..<br>.###.##...#.<br>.###.##....#<br>.###..##.#..<br>.###..##..#.<br>.###..##...#<br>.###...##.#.<br>.###...##..#<br>.###....##.#</blockquote>\n<blockquote>In this example, the number of possible arrangements for each rowÂ is:</blockquote>\n<blockquote>???.### 1,1,3 - 1 arrangement</blockquote>\n<blockquote>.??..??...?##. 1,1,3 - 4 arrangements</blockquote>\n<blockquote>?#?#?#?#?#?#?#? 1,3,1,6 - 1 arrangement</blockquote>\n<blockquote>????.#...#... 4,1,1 - 1 arrangement</blockquote>\n<blockquote>????.######..#####. 1,6,5 - 4 arrangements</blockquote>\n<blockquote>?###???????? 3,2,1 - 10 arrangements</blockquote>\n<blockquote>Adding all of the possible arrangement counts together produces a total of 21 arrangements.</blockquote>\n<blockquote>For each row, count all of the different arrangements of operational and broken springs that meet the given criteria. What is the sum of thoseÂ counts?</blockquote>\n<p>Man! Another permutation and combination problem! It seems like Santa knows what I used to hate during my engineering days!Â ğŸ¤“</p>\n<p>So..letâ€™s break the problem down, and try not to get ahead of ourself unlike <a href=\"https://medium.com/@jatinkrmalik/day-11-cosmic-expansion-advent-of-code-2023-python-6e545dad06bb\">DayÂ 11</a>!</p>\n<p>In an ideal world, our spring records look something likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HEfawkgl3UkaXOujYeYvhQ.png\"></figure><p>But, since the condition records are partially damaged, some of the springsâ€™ conditions are actually unknownÂ (?):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/988/1*msCo829KuU8oXkABUT8D0w.png\"><figcaption>where `?` denotes the unknownÂ state</figcaption></figure><p>ğŸ’¡ So, before we start talking about combinations possible and all, I think we should assume the ideal case, and write a simple validator that validates the spring_state (left) with damaged_spring_record (right). And this case be our baseÂ case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*cs0D_12A8fOC34O7FBHgWg.png\"><figcaption>Quick prototying inÂ REPL</figcaption></figure><p>Hereâ€™s our testÂ case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/795/1*6xYRS2whEuMWeyeqQwio_Q.png\"></figure><p>And hereâ€™s some shabby code just to validate theÂ idea:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/774/1*7IpkGhEBWW00mcYWRbWosQ.png\"></figure><p>Letâ€™s run this, and we can validate that it indeedÂ works!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>âœ… OK: #.#.### 1,1,3<br>âœ… OK: .#...#....###. 1,1,3<br>âœ… OK: .#.###.#.###### 1,3,1,6<br>âœ… OK: ####.#...#... 4,1,1<br>âœ… OK: #....######..#####. 1,6,5<br>âœ… OK: .###.##....# 3,2,1<br><br>[Done] exited with code=0 in 0.097 seconds</pre>\n<p>So, now that we know the records are not ideal, but indeed damaged and has a lot of unknowns, we will expand the scope of our thinking.</p>\n<p>Well, itâ€™s clear that our validate_spring_record(spring_record) bool function will play a pivotal role to solve the problem as for an example row from damagedÂ records:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/987/1*yPP9z0Et7UBNJgad-tIfBw.png\"><figcaption>We can use our validator function to help verify correct combinations</figcaption></figure><blockquote>Now, to get all possible combinations, we need to consider eachÂ ? as a place where 2 choices are possible: eitherÂ . or #. This is a classic problem of combinatorics where eachÂ ? represents a <strong>binaryÂ choice</strong>.</blockquote>\n<p>In the example row taken above:Â .??..??â€¦?##.Â , we have a total of 5Â ? present, where each can be replaced byÂ . or # so, mathematically speaking, that yields: <strong><em>2âµ combinations ==Â 32.</em></strong></p>\n<p>ğŸ’­ We can write a function that replaces eachÂ ? in the record with eitherÂ . or #, and then calls itself recursively until allÂ ? have been replaced, using that we can generate all the combinations!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zt0yeaKGXxSM6uAVI9KrNg.png\"></figure><p>Letâ€™s do a quick scriptÂ test?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*oszF9BgfE6OlziW0E3YOyA.png\"><figcaption>Looks good!</figcaption></figure><p>Now, all we need to doÂ is:</p>\n<ol>\n<li>For each spring_state record, generate all_combinations</li>\n<li>For each combination in all_combinations, count validate_spring_record(combination) ==Â true</li>\n<li>sum(for each count of valid combination)</li>\n<li>???</li>\n<li>Profit!</li>\n</ol>\n<blockquote>â—ï¸ Disclaimer: I know this is not the most efficient way, but as always, my first approach is to match a solution to a problem and then try to find optimisations! We will probably have to do that as well, as we are currently generating 2^n combinations where the valid combinations will be superÂ low!</blockquote>\n<p>So, letâ€™s writeÂ ğŸ‘†code:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/957/1*m_JTU9Mlkhm02vv22-ZzFw.png\"></figure><p>And letâ€™s run for our base test case as given in the question:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>Found 1 valid combinations for ???.### 1,1,3<br>Found 4 valid combinations for .??..??...?##. 1,1,3<br>Found 1 valid combinations for ?#?#?#?#?#?#?#? 1,3,1,6<br>Found 1 valid combinations for ????.#...#... 4,1,1<br>Found 4 valid combinations for ????.######..#####. 1,6,5<br>Found 10 valid combinations for ?###???????? 3,2,1<br>âœ… OK - test_sum_spring_record_combinations<br><br>[Done] exited with code=0 in 0.066 seconds</pre>\n<p>Yes!!! Now, letâ€™s load up the puzzle input and try to get an answer?Â ğŸ¤</p>\n<p>Ah, wellâ€¦.this might take some timeâ€¦andâ€¦</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>Found 4 valid combinations for .???#??????#. 6,1<br>Found 2 valid combinations for ???##???##?#??#?#..# 1,14,1<br>Found 2 valid combinations for #??????#????#?###?# 3,1,10,1<br>Found 13 valid combinations for .???????#????. 1,2,1,2<br>Found 4 valid combinations for ?##?.??.???.. 3,2,2<br>Found 1 valid combinations for #.?###?#??. 1,5<br>Found 12 valid combinations for ?#??#??????????.??.? 7,2,3,1<br>Found 1 valid combinations for ???###?#.##??? 8,3<br>...<br>1000 lines later<br>...<br>â—ï¸ Total valid combinations: XXXX<br><br>[Done] exited with code=0 in 49.445 seconds</pre>\n<p>Not bad! An answer in 49.445 seconds shall be considered a win comapred to last fewÂ days!</p>\n<p>Letâ€™s see if this is the corectÂ answers?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/830/1*a3NavRUiuC2ujHUK9wXbRw.png\"><figcaption>YASS!</figcaption></figure><p>Hereâ€™s my code tillÂ now:</p>\n<pre># Day 12: Hot Springs<br><br>from enum import Enum<br><br><br>class SpringState(Enum):<br>    OPERATIONAL = \".\"<br>    DAMAGED = \"#\"<br>    UNKNOWN = \"?\"<br><br><br>def generate_spring_record_combinations(spring_record, index=0):<br>    if index &gt;= len(spring_record):<br>        return [spring_record]<br><br>    if spring_record[index] == SpringState.UNKNOWN.value:<br>        # replace '?' with '.' and combine results<br>        with_operational = generate_spring_record_combinations(<br>            spring_record[:index]<br>            + SpringState.OPERATIONAL.value<br>            + spring_record[index + 1 :],<br>            index + 1,<br>        )<br>        # replace '?' with '#' and combine results<br>        with_damaged = generate_spring_record_combinations(<br>            spring_record[:index]<br>            + SpringState.DAMAGED.value<br>            + spring_record[index + 1 :],<br>            index + 1,<br>        )<br>        return with_operational + with_damaged<br>    else:<br>        # continue recursion for next index<br>        return generate_spring_record_combinations(spring_record, index + 1)<br><br><br>def validate_spring_record(spring_state, damaged_spring_record):<br>    damaged_spring_record = damaged_spring_record.split(\",\")<br>    spring_state = list(spring_state)<br><br>    replica_damaged_spring_record = []<br>    damaged_count = 0<br>    for spring in spring_state:<br>        if spring == SpringState.DAMAGED.value:<br>            damaged_count += 1<br>        else:<br>            if damaged_count &gt; 0:<br>                replica_damaged_spring_record.append(str(damaged_count))<br>                damaged_count = 0<br><br>    if damaged_count &gt; 0:<br>        replica_damaged_spring_record.append(str(damaged_count))<br><br>    return replica_damaged_spring_record == damaged_spring_record<br><br><br>def sum_spring_record_combinations(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        combinations = generate_spring_record_combinations(spring_state)<br>        valid_combinations_length = len(<br>            [<br>                c for c in combinations<br>                if validate_spring_record(c, damaged_spring_record)<br>            ]<br>        )<br>        print(f\"Found {valid_combinations_length} valid combinations for {spring_record}\")<br>        total_combinations += valid_combinations_length<br>    return total_combinations<br><br>def part_one():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    print(f\"â—ï¸ Total valid combinations: {sum}\")<br><br>def test_sum_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    assert sum == 21, f\"âŒ Expected: 21, Actual: {sum}\"<br>    print(\"âœ… OK - test_sum_spring_record_combinations\")<br><br><br>def test_validate_spring_record_ideal():<br>    ideal_spring_condition_records = \"\"\"#.#.### 1,1,3<br>.#...#....###. 1,1,3<br>.#.###.#.###### 1,3,1,6<br>####.#...#... 4,1,1<br>#....######..#####. 1,6,5<br>.###.##....# 3,2,1<br>\"\"\"<br>    for spring_record in ideal_spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        ok = validate_spring_record(spring_state, damaged_spring_record)<br>        assert ok, f\"âŒ Expected: True, Actual: {ok}\"<br>        print(f\"âœ… OK: {spring_record}\")<br>    print(\"âœ… OK - test_validate_spring_record_ideal\")<br><br><br><br>if __name__ == \"__main__\":<br>    # test_validate_spring_record_ideal()<br>    test_sum_spring_record_combinations()<br>    part_one()</pre>\n<blockquote>I am aware that we have a lot of wasted compute that we can optimise here, but letâ€™s move on to part 2 as that usually changes the requirements drastically and then we will combine refactor ourÂ code.</blockquote>\n<h3>Part Two</h3>\n<blockquote>As you look out at the field of springs, you feel like there are way more springs than the condition records list. When you examine the records, you discover that they were actually folded up this wholeÂ time!</blockquote>\n<blockquote>To unfold the records, on each row, replace the list of spring conditions with five copies of itself (separated byÂ ?) and replace the list of contiguous groups of damaged springs with five copies of itself (separated byÂ ,).</blockquote>\n<blockquote>So, thisÂ row:</blockquote>\n<blockquote>.# 1</blockquote>\n<blockquote>Would become:</blockquote>\n<blockquote>.#?.#?.#?.#?.# 1,1,1,1,1</blockquote>\n<blockquote>The first line of the above example wouldÂ become:</blockquote>\n<blockquote>???.###????.###????.###????.###????.### 1,1,3,1,1,3,1,1,3,1,1,3,1,1,3</blockquote>\n<blockquote>In the above example, after unfolding, the number of possible arrangements for some rows is now muchÂ larger:</blockquote>\n<blockquote>???.### 1,1,3 - 1 arrangement</blockquote>\n<blockquote>.??..??...?##. 1,1,3 - 16384 arrangements</blockquote>\n<blockquote>?#?#?#?#?#?#?#? 1,3,1,6 - 1 arrangement</blockquote>\n<blockquote>????.#...#... 4,1,1 - 16 arrangements</blockquote>\n<blockquote>????.######..#####. 1,6,5 - 2500 arrangements</blockquote>\n<blockquote>?###???????? 3,2,1 - 506250 arrangements</blockquote>\n<blockquote>After unfolding, adding all of the possible arrangement counts together producesÂ 525152.</blockquote>\n<blockquote>Unfold your condition records; what is the new sum of possible arrangement counts?</blockquote>\n<p>Aha! Told you. So, now conviniently, springs were actually <strong>folded up </strong>this wholeÂ time!</p>\n<p>To unfold the sequence, we just need to 5x each row of the record, forÂ example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/966/1*s4MTuZ3zRalGpICJhrhfJQ.png\"></figure><p>Clearly, our inefficient code will now not work, as our possible combinations will increase exponentially!</p>\n<blockquote>ğŸ’¡Well, one simple way I can see to reduce computations isÂ to:</blockquote>\n<blockquote>- just integrate the validation logic directly into the combination generation process</blockquote>\n<blockquote>- instead of store all the combinations and then computing length, we can just return the <strong>valid</strong> number of combinations.</blockquote>\n<p>This way, we only generate valid combinations from the start, significantly reducing the number of combinations we need toÂ handle.</p>\n<p>Updating code for that, letâ€™s runÂ it!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>âœ… OK - test_sum_spring_record_combinations<br>â—ï¸ Total valid combinations: 7599<br><br>[Done] exited with code=0 in 48.915 seconds</pre>\n<p>And it saved us a grand total of 49.445â€“48.915 = <strong>~530 msÂ ğŸ˜‚</strong></p>\n<a href=\"https://medium.com/media/05826d1b7bcf41e217ad095add326244/href\">https://medium.com/media/05826d1b7bcf41e217ad095add326244/href</a><p>Breaking down the computation, itâ€™s clear that we are <strong>spending a lot of time in</strong> generating â€œallâ€ the possible combinations of the record. Since we already have the damaged_spring_record, we should be able to use it to basically just generate correct combinations? Or at the least, do an <strong>early return</strong> for the all incorrect ones!Â ğŸ¤”</p>\n<blockquote>The complexity of this problem lies in correctly interpreting the â€˜?â€™ characters while adhering to the constraints set by the <strong><em>damaged_spring_record</em></strong>.</blockquote>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>ğŸ’¡ We need to find a way to <strong>prune of our search space early</strong> when a rule from damaged_spring_record is violated in our recursive process itself! Letâ€™s write our early return conditions using our record while navigating through all possible combinations in our recursive function:</p>\n<ul>\n<li>If the damaged_spring_record is empty, <br>- if any spring is damaged: return 0 <br>- else, returnÂ 1.</li>\n<li>If the spring_state string is empty, <br>- if there are no damaged spring records left to process: return 1<br>- else, returnÂ 0.</li>\n<li>recursively check each spring state and calculate the total number of valid combinations based on whether the current spring is operational, damaged, orÂ unknown.</li>\n</ul>\n<p>And since now alot of search space will have repeated calculations, we can use @cache decorator from functools to memoize the results of the recursive function get_valid_spring_record_combinations in an LRU cache with no sizeÂ limit!</p>\n<blockquote>Python does make caching absolutely simple with these nifty OOTB decorators! ğŸ¤Œ</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SOZFKjkeUP6fDZF42V4Ffw.png\"></figure><p>And here, our is_valid_condition would lookÂ like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/882/1*9jeKFExvbHulJLyT9qmFQQ.png\"></figure><p>â—ï¸ Here, _is_valid_condition returns a boolean value that indicates whether the given spring_state and damaged_spring_record meet the following conditions:</p>\n<ol>\n<li>The first element of damaged_spring_record (which represents the number of damaged springs in the first group) is less than or equal to the length of spring_state. This ensures that there are enough springs in spring_state to account for the first group of damagedÂ springs.</li>\n<li>All springs in spring_state up to the index equal to the first element of damaged_spring_record are not operational. This is checked by ensuring that the OPERATIONAL value of the SpringState Enum is not found in the substring of spring_state that ends at the index equal to the first element of damaged_spring_record.</li>\n<li>Either the first element of damaged_spring_record is equal to the length of spring_state (which means that all springs are damaged), or the spring at the index equal to the first element of damaged_spring_record is not damaged. This ensures that there is no damaged spring immediately after the first group of damagedÂ springs.</li>\n</ol>\n<p>Letâ€™s run this code for our base test case of partÂ 1:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/748/1*Hw9kB_F1vPM-PDxQxMNqwQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>âœ… OK - test_sum_spring_record_combinations<br><br>[Done] exited with code=0 in 0.109 seconds</pre>\n<p>And puzzle input for partÂ 1:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*R7ko8-beeAmE7h8LOHK8ig.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>â—ï¸ Total valid combinations: XXXX<br><br>[Done] exited with code=0 in 0.134 seconds</pre>\n<p>Wow! We get the correct answer in just <strong>0.134 seconds </strong>compare this to our previous brute force approach that took <strong>~49 secondsÂ ğŸ˜¯</strong></p>\n<p>Now, letâ€™s also write our base test case for part 2, where all we need to do is, just increase our input per spring_record * 5Â :</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/796/1*1tR0tV2M9F1FkhO9YmgEhg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>âœ… OK - test_sum_unfolded_spring_record_combinations<br><br>[Done] exited with code=0 in 0.11 seconds</pre>\n<p>Phew! And now letâ€™s do it for part 2, puzzleÂ input:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*KwV2lKEhMMicGv2y4jS69Q.png\"><figcaption>* 5 for unfolding ê©œ</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>â—ï¸ Total valid combinations: XXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.693 seconds</pre>\n<p><strong>Yes! Look at that runtime!Â ğŸš€</strong></p>\n<p>Letâ€™s put this answer in the text box?Â Andâ€¦</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/950/1*HfuXqBmUaJQdhPzx1YC98w.png\"><figcaption>ğŸ’¥</figcaption></figure><p>Hereâ€™s our super optimised code till now, I am not doing object oriented for this one!Â :P</p>\n<pre>from enum import Enum<br>from functools import cache<br><br><br>class SpringState(Enum):<br>    OPERATIONAL = \".\"<br>    DAMAGED = \"#\"<br>    UNKNOWN = \"?\"<br><br><br>@cache<br>def get_valid_spring_record_combinations(spring_state, damaged_spring_record):<br>    if not damaged_spring_record:<br>        if SpringState.DAMAGED.value in spring_state:<br>            return 0<br>        else:<br>            return 1<br><br>    if not spring_state:<br>        if not damaged_spring_record:<br>            return 1<br>        else:<br>            return 0<br><br>    total_combinations = 0<br><br>    # if \".\" or \"?\"<br>    if spring_state[0] in [SpringState.OPERATIONAL.value, SpringState.UNKNOWN.value]:<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state[1:], damaged_spring_record<br>        )<br><br>    # if \"#\" or \"?\"<br>    if spring_state[0] in [SpringState.DAMAGED.value, SpringState.UNKNOWN.value]:<br>        if is_valid_condition(spring_state, damaged_spring_record):<br>            total_combinations += get_valid_spring_record_combinations(<br>                spring_state[damaged_spring_record[0] + 1 :], damaged_spring_record[1:]<br>            )<br><br>    return total_combinations<br><br><br>def is_valid_condition(spring_state, damaged_spring_record):<br>    return (<br>        damaged_spring_record[0] &lt;= len(spring_state)<br>        and SpringState.OPERATIONAL.value<br>        not in spring_state[: damaged_spring_record[0]]<br>        and (<br>            damaged_spring_record[0] == len(spring_state)<br>            or spring_state[damaged_spring_record[0]] != SpringState.DAMAGED.value<br>        )<br>    )<br><br><br>def sum_spring_record_combinations(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        damaged_spring_record = tuple(map(int, damaged_spring_record.split(\",\")))<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state, damaged_spring_record<br>        )<br><br>    return total_combinations<br><br><br>def part_one():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    print(f\"â—ï¸ Total valid combinations: {sum}\")<br><br><br>def sum_spring_record_combinations_unfold(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        damaged_spring_record = tuple(map(int, damaged_spring_record.split(\",\")))<br>        spring_state = \"?\".join([spring_state] * 5)  # unfolding<br>        damaged_spring_record = damaged_spring_record * 5  # unfolding<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state, damaged_spring_record<br>        )<br><br>    return total_combinations<br><br><br>def part_two():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations_unfold(spring_condition_records)<br>    print(f\"â—ï¸ Total valid combinations: {sum}\")<br><br><br>def test_sum_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    assert sum == 21, f\"âŒ Expected: 21, Actual: {sum}\"<br>    print(\"âœ… OK - test_sum_spring_record_combinations\")<br><br><br>def test_sum_unfolded_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations_unfold(spring_condition_records)<br>    assert sum == 525152, f\"âŒ Expected: 525152, Actual: {sum}\"<br>    print(\"âœ… OK - test_sum_unfolded_spring_record_combinations\")<br><br><br>if __name__ == \"__main__\":<br>    test_sum_spring_record_combinations()<br>    part_one()<br><br>    test_sum_unfolded_spring_record_combinations()<br>    part_two()</pre>\n<p>Man! I am learning so much with <strong>#AdventOfCode2023</strong>, itâ€™s beautiful that I am getting to revisit a lot of my engineering days concepts that I donâ€™t get to use in my day to day work while building CRUD apps!Â ğŸ¤“</p>\n<p>Onto the next dayÂ then?!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved theÂ problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machineÂ ğŸ‘‡</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! ğŸ„</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=77506773abfb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "advent-of-code-2023",
        "python",
        "christmas",
        "advent-of-code"
      ]
    },
    {
      "title": "[Day 11] Cosmic Expansion // Advent of Code 2023 (Python)",
      "pubDate": "2023-12-18 10:39:36",
      "link": "https://medium.com/@jatinkrmalik/day-11-cosmic-expansion-advent-of-code-2023-python-6e545dad06bb?source=rss-ec576e4b06b0------2",
      "guid": "https://medium.com/p/6e545dad06bb",
      "author": "Jatin K Malik",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*WU-oHlsxWjavblYa\"><figcaption>Cosmic Expansion (via DALL-EÂ 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/11\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You continue following signs for â€œHot Springsâ€ and eventually come across an <a href=\"https://en.wikipedia.org/wiki/Observatory\">observatory</a>. The Elf within turns out to be a researcher studying cosmic expansion using the giant telescope here.</blockquote>\n<blockquote>He doesnâ€™t know anything about the missing machine parts; heâ€™s only visiting for this research project. However, he confirms that the hot springs are the next-closest area likely to have people; heâ€™ll even take you straight there once heâ€™s done with todayâ€™s observation analysis.</blockquote>\n<blockquote>Maybe you can help him with the analysis to speed thingsÂ up?</blockquote>\n<blockquote>The researcher has collected a bunch of data and compiled the data into a single giant image (your puzzle input). The image includes empty space (.) and galaxies (#). ForÂ example:</blockquote>\n<blockquote>...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....</blockquote>\n<blockquote>The researcher is trying to figure out the sum of the lengths of the shortest path between every pair of galaxies. However, thereâ€™s a catch: the universe expanded in the time it took the light from those galaxies to reach the observatory.</blockquote>\n<blockquote>Due to something involving gravitational effects, only some space expands. In fact, the result is that any rows or columns that contain no galaxiesshould all actually be twice asÂ big.</blockquote>\n<blockquote>In the above example, three columns and two rows contain no galaxies:</blockquote>\n<blockquote>v v v<br>Â ...#......<br>Â .......#..<br> #.........<br>&gt;..........&lt;<br>Â ......#...<br>Â .#........<br>Â .........#<br>&gt;..........&lt;<br>Â .......#..<br> #...#.....<br> ^ ^Â ^</blockquote>\n<blockquote>These rows and columns need to be twice as big; the result of cosmic expansion therefore looks likeÂ this:</blockquote>\n<blockquote>....#........<br>.........#...<br>#............<br>.............<br>.............<br>........#....<br>.#...........<br>............#<br>.............<br>.............<br>.........#...<br>#....#.......</blockquote>\n<blockquote>Equipped with this expanded universe, the shortest path between every pair of galaxies can be found. It can help to assign every galaxy a uniqueÂ number:</blockquote>\n<blockquote>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>............6<br>.............<br>.............<br>.........7...<br>8....9.......</blockquote>\n<blockquote>In these 9 galaxies, there are 36 pairs. Only count each pair once; order within the pair doesnâ€™t matter. For each pair, find any shortest path between the two galaxies using only steps that move up, down, left, or right exactly oneÂ . or # at a time. (The shortest path between two galaxies is allowed to pass through anotherÂ galaxy.)</blockquote>\n<blockquote>For example, here is one of the shortest paths between galaxies 5 andÂ 9:</blockquote>\n<blockquote>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>.##.........6<br>..##.........<br>...##........<br>....##...7...<br>8....9.......</blockquote>\n<blockquote>This path has length 9 because it takes a minimum of nine steps to get from galaxy 5 to galaxy 9 (the eight locations marked # plus the step onto galaxy 9 itself). Here are some other example shortest pathÂ lengths:</blockquote>\n<blockquote>Between galaxy 1 and galaxy 7:Â 15</blockquote>\n<blockquote>Between galaxy 3 and galaxy 6:Â 17</blockquote>\n<blockquote>Between galaxy 8 and galaxy 9:Â 5</blockquote>\n<blockquote>In this example, after expanding the universe, the sum of the shortest path between all 36 pairs of galaxies isÂ 374.</blockquote>\n<blockquote>Expand the universe, then find the length of the shortest path between every pair of galaxies. What is the sum of theseÂ lengths?</blockquote>\n<p><em>Finally! A space exploration problem. I am a sucker forÂ those!</em></p>\n<p>So, letâ€™s look at the problem, we have an image of space from the observatory and it looks something likeÂ this:</p>\n<pre>...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....</pre>\n<p>And we need to compute the sum of the lengths of the shortest path between every pair of galaxies!</p>\n<blockquote>â—ï¸The catch being, that by the time light reaches to us, the space expands due to ever expanding universe, but only some part, resulting in any <strong>rows or columns</strong> that contain <strong>no galaxies</strong> should all actually be <strong>twice asÂ big.</strong>\n</blockquote>\n<p>Letâ€™s visualise this?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lUFvdLG-8zW-7eo4Vvl74w.png\"><figcaption>This seems like a good firstÂ step</figcaption></figure><p>Once we have the final image! We can just number the galaxiesÂ like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*hZRn53JjHjOFcBspyvzYLA.png\"></figure><p>And then we can just find the shortest distance from each pair of galaxies!</p>\n<p>Seems pretty straight forward right? Letâ€™sÂ code!</p>\n<p>As usual, I will begin with writing our base case as the ultimate validator!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/528/1*wpLfzZ-B7q-gkt46Zka26A.png\"></figure><p>And now letâ€™s start expanding! Itâ€™s clear we first need to <strong><em>expand</em></strong> space by finding empty rows and columns and doubling it. So, letâ€™s first just doÂ that.</p>\n<p>Hereâ€™s a simple function expand_space that just doesÂ that:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IvD01NKWBgQB3m5LNNoSOQ.png\"></figure><blockquote>ğŸ’¡ Caught a bug, as if we modify the space_map while iterating through it, the empty_rows elements start to point to an incorrect index. To fix that, we can just introduce something like a mod_count which can help us keep a track of original index in modified space_map.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VoSoXFEiPUwgq5Kqi7hERw.png\"><figcaption>Fixed!</figcaption></figure><p>Now we can find all the galaxies locations in the expanded_space_map with a simple function:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/471/1*LszcXw2pLv5S_15-MqpBCQ.png\"></figure><p>ğŸ’­ The last step is to now take 1 galaxy and find its shortest distance from all other galaxies and then repeat this process for all galaxies!</p>\n<p>Well, before even touching the code, I can already see a lot of steps to optimise this one! For example: If we have found the shortest distance from Galaxy_1 to Galaxy_2Â , it will be same other way around, so we can save extra compute by just refering to aÂ cache.</p>\n<pre>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>............6<br>.............<br>.............<br>.........7...<br>8....9.......</pre>\n<p>So, in case of this example, where we have 9 galaxies can could have 81 combinations, since we canâ€™t repeat a pair, the formulaÂ becomes:</p>\n<blockquote>Number of combinations= <em>n</em>! / <em>r</em>!(<em>n</em>âˆ’<em>r</em>)!â€‹</blockquote>\n<p>Solving for ourÂ case:</p>\n<blockquote>\n<em>9C</em>2â€‹ = 9! / 2!(9âˆ’2)! â€‹=Â 36</blockquote>\n<p><strong>36 combinations!</strong></p>\n<p>Letâ€™s write some code? I will be using goodâ€™ol <strong>BFS (breadth first search)</strong> to find the shortest path for each pair of galaxies. <em>We may come back and optimise this to a more greedy approach for faster computation!</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fnAe9-H1FYiZRcnQHgc26Q.png\"><figcaption>Classic BFS!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*2_MOrRwleCiWT4-DMKLxNg.png\"><figcaption>Ofcourse, I forgot `list` is unhashable ğŸ¤¦â€â™‚ï¸</figcaption></figure><p>We can always hash a tupple though!Â ;)</p>\n<p>Finally after a lot of iterations:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HOtCjKwT6txXLOfaCZCd9w.png\"><figcaption>36!</figcaption></figure><p>Letâ€™s check our test caseÂ now?</p>\n<p>Hereâ€™s our MVP code tillÂ now:</p>\n<pre># Day 11: Cosmic Expansion<br><br>from enum import Enum<br><br><br>EMPTY_SPACE = \".\"<br>GALAXY = \"#\"<br>DISTANCE_MAP = {}<br><br>class Direction(Enum):<br>        RIGHT = (0, 1)<br>        LEFT = (0, -1)<br>        DOWN = (1, 0)<br>        UP = (-1, 0)<br><br><br>def expand_space_map(space_map):<br>    empty_rows, empty_cols = [], []<br><br>    for i, row in enumerate(space_map):<br>        if GALAXY not in row:<br>            empty_rows.append(i)<br><br>    for i, col in enumerate(space_map[0]):<br>        if GALAXY not in [row[i] for row in space_map]:<br>            empty_cols.append(i)<br><br>    mod_count = 0<br>    for i in empty_rows:<br>        space_map.insert(i + mod_count, EMPTY_SPACE * len(space_map[i]))<br>        mod_count += 1<br><br>    mod_count = 0<br>    for i in empty_cols:<br>        for j, row in enumerate(space_map):<br>            space_map[j] = row[: i + mod_count] + EMPTY_SPACE + row[i + mod_count :]<br>        mod_count += 1<br><br>    return space_map<br><br><br>def find_shortest_distance(galaxy1, galaxy2, space_map):<br>    print(f\"Finding shortest distance between {galaxy1} and {galaxy2}\")<br>    # check if the distance between the two galaxies is already calculated<br>    distance = DISTANCE_MAP.get(galaxy1, {}).get(galaxy2) or DISTANCE_MAP.get(<br>        galaxy2, {}<br>    ).get(galaxy1)<br>    if distance:<br>        return distance<br><br>    # using BFS to find the shortest path between two galaxies<br>    queue = [galaxy1]  # initialize the queue with the starting galaxy<br>    visited = set()  # set to keep track of visited galaxies<br>    distance = 0  # initialize the distance to 0<br>    while queue:<br>        for _ in range(len(queue)):<br>            current = queue.pop(0)  # get the next galaxy from the queue<br>            if current == galaxy2:  # if we reach the destination galaxy<br>                if galaxy1 not in DISTANCE_MAP:<br>                    DISTANCE_MAP[galaxy1] = {}<br>                DISTANCE_MAP[galaxy1][galaxy2] = distance  # store the distance between the galaxies<br>                return distance<br>            visited.add(current)  # mark the current galaxy as visited<br><br>            for direction in Direction:  # explore all possible directions<br>                i, j = current[0] + direction.value[0], current[1] + direction.value[1]<br>                if (<br>                    0 &lt;= i &lt; len(space_map)<br>                    and 0 &lt;= j &lt; len(space_map[0])<br>                    and (i, j) not in visited<br>                ):<br>                    queue.append((i, j))  # add the neighboring galaxy to the queue<br>        distance += 1  # increment the distance after exploring all galaxies at the current level<br><br>    raise Exception(\"No path found between the two galaxies\")<br><br><br>def find_all_galaxies(space_map):<br>    galaxies = []<br>    for i, row in enumerate(space_map):<br>        for j, col in enumerate(row):<br>            if col == GALAXY:<br>                galaxies.append((i, j))<br>    return galaxies<br><br><br>def analyze_space(space_map):<br>    expanded_space_map = expand_space_map(space_map)<br>    print(f\"Expanded space map is {len(expanded_space_map)} x {len(expanded_space_map[0])}\")<br>    galaxies_locations = find_all_galaxies(expanded_space_map)<br>    print(f\"Number of galaxies: {len(galaxies_locations)}\")<br><br>    for galaxy1 in galaxies_locations:<br>        for galaxy2 in galaxies_locations:<br>            if galaxy1 != galaxy2:<br>                find_shortest_distance(galaxy1, galaxy2, expanded_space_map)<br><br>    sum = 0 <br>    for k,v in DISTANCE_MAP.items():<br>        for k1,v1 in v.items():<br>            sum += v1<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br>    sum =  analyze_space(space_map)<br>    print(f\"â—ï¸ Sum of the lengths of the shortest path between every pair of galaxies: {sum}\")<br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br><br>    sum = analyze_space(space_map.splitlines())<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"âœ… Passed test_analyze_observation()\")<br><br><br>if __name__ == \"__main__\":<br>    test_analyze_space()<br>    # part_one()</pre>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>âœ… Passed test_analyze_observation()<br><br>[Done] exited with code=0 in 7.131 seconds</pre>\n<p>Well, it did took 7.131 seconds to compute for a simple testcase, letâ€™s see if it can do it for puzzleÂ input?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/991/1*qsb5pCVb9HnxVVOv7uzGzQ.png\"></figure><p>And compute!!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*NTrAEUF4t-HG-9FlN3uA6Q.png\"><figcaption>2 mins in, doesnâ€™t seemÂ likely!</figcaption></figure><p>Letâ€™s add some logging to understand the scale of theÂ problem?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/896/1*KatgSN7P3HCewqc06-gjLw.gif\"><figcaption>Yeahâ€¦.this is not gonnaÂ compute!</figcaption></figure><p>We have 426 Galaxies in a map of size 151 x 147 which gives us 426C2 combinations, equaling 90525 possible pairs! We need to make it more efficient!</p>\n<blockquote>While, I can take the easy path of just doings the <strong>Bi-directional BFS</strong> where I can look up from both Galaxy 1 and Galaxy 2, I feels itâ€™s better to take a peak into <strong>A* or Dijkstraâ€™s </strong>Algorithm for our shortest path finding to be more efficient!</blockquote>\n<p>I am bit rusty donâ€™t remember A* algo exactly but I do remember that A* is a type of <strong>greedy approch</strong> which does a <strong>smart search</strong> through a maze, where at each step it makes an <strong>informed guess</strong> about the best next step based on <em>how far it has already traveled</em> and <em>how far it still has to go</em>, according to the map. Itâ€™s a blend of exploring and using what you know to make good guesses, which makes it efficient and effective for findingÂ paths.</p>\n<p>Letâ€™s use Github Copilot to quickly generate a A* method for searching and then refactor it to suit our galaxy and space_map problem:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YrmYmgoRwh7xZY6OUTjUHQ.png\"><figcaption>Looks good!</figcaption></figure><p>Now, letâ€™s run for the base test case with our loggingÂ enabled?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>Expanded space map is 12 x 13<br>Number of galaxies: 9<br>Finding shortest distance between (0, 4) and (1, 9)<br>Finding shortest distance between (0, 4) and (2, 0)<br>Finding shortest distance between (0, 4) and (5, 8)<br>Finding shortest distance between (0, 4) and (6, 1)<br>Finding shortest distance between (0, 4) and (7, 12)<br>Finding shortest distance between (0, 4) and (10, 9)<br>Finding shortest distance between (0, 4) and (11, 0)<br>Finding shortest distance between (0, 4) and (11, 5)<br>Finding shortest distance between (1, 9) and (0, 4)<br>Finding shortest distance between (1, 9) and (2, 0)<br>Finding shortest distance between (1, 9) and (5, 8)<br>Finding shortest distance between (1, 9) and (6, 1)<br>Finding shortest distance between (1, 9) and (7, 12)<br>Finding shortest distance between (1, 9) and (10, 9)<br>Finding shortest distance between (1, 9) and (11, 0)<br>Finding shortest distance between (1, 9) and (11, 5)<br>Finding shortest distance between (2, 0) and (0, 4)<br>Finding shortest distance between (2, 0) and (1, 9)<br>Finding shortest distance between (2, 0) and (5, 8)<br>Finding shortest distance between (2, 0) and (6, 1)<br>Finding shortest distance between (2, 0) and (7, 12)<br>Finding shortest distance between (2, 0) and (10, 9)<br>Finding shortest distance between (2, 0) and (11, 0)<br>Finding shortest distance between (2, 0) and (11, 5)<br>Finding shortest distance between (5, 8) and (0, 4)<br>Finding shortest distance between (5, 8) and (1, 9)<br>Finding shortest distance between (5, 8) and (2, 0)<br>Finding shortest distance between (5, 8) and (6, 1)<br>Finding shortest distance between (5, 8) and (7, 12)<br>Finding shortest distance between (5, 8) and (10, 9)<br>Finding shortest distance between (5, 8) and (11, 0)<br>Finding shortest distance between (5, 8) and (11, 5)<br>Finding shortest distance between (6, 1) and (0, 4)<br>Finding shortest distance between (6, 1) and (1, 9)<br>Finding shortest distance between (6, 1) and (2, 0)<br>Finding shortest distance between (6, 1) and (5, 8)<br>Finding shortest distance between (6, 1) and (7, 12)<br>Finding shortest distance between (6, 1) and (10, 9)<br>Finding shortest distance between (6, 1) and (11, 0)<br>Finding shortest distance between (6, 1) and (11, 5)<br>Finding shortest distance between (7, 12) and (0, 4)<br>Finding shortest distance between (7, 12) and (1, 9)<br>Finding shortest distance between (7, 12) and (2, 0)<br>Finding shortest distance between (7, 12) and (5, 8)<br>Finding shortest distance between (7, 12) and (6, 1)<br>Finding shortest distance between (7, 12) and (10, 9)<br>Finding shortest distance between (7, 12) and (11, 0)<br>Finding shortest distance between (7, 12) and (11, 5)<br>Finding shortest distance between (10, 9) and (0, 4)<br>Finding shortest distance between (10, 9) and (1, 9)<br>Finding shortest distance between (10, 9) and (2, 0)<br>Finding shortest distance between (10, 9) and (5, 8)<br>Finding shortest distance between (10, 9) and (6, 1)<br>Finding shortest distance between (10, 9) and (7, 12)<br>Finding shortest distance between (10, 9) and (11, 0)<br>Finding shortest distance between (10, 9) and (11, 5)<br>Finding shortest distance between (11, 0) and (0, 4)<br>Finding shortest distance between (11, 0) and (1, 9)<br>Finding shortest distance between (11, 0) and (2, 0)<br>Finding shortest distance between (11, 0) and (5, 8)<br>Finding shortest distance between (11, 0) and (6, 1)<br>Finding shortest distance between (11, 0) and (7, 12)<br>Finding shortest distance between (11, 0) and (10, 9)<br>Finding shortest distance between (11, 0) and (11, 5)<br>Finding shortest distance between (11, 5) and (0, 4)<br>Finding shortest distance between (11, 5) and (1, 9)<br>Finding shortest distance between (11, 5) and (2, 0)<br>Finding shortest distance between (11, 5) and (5, 8)<br>Finding shortest distance between (11, 5) and (6, 1)<br>Finding shortest distance between (11, 5) and (7, 12)<br>Finding shortest distance between (11, 5) and (10, 9)<br>Finding shortest distance between (11, 5) and (11, 0)<br>âœ… Passed test_analyze_observation()<br><br>[Done] exited with code=0 in 0.121 seconds</pre>\n<blockquote>Woah! <strong>0.121 seconds</strong> for the base test case. Comparing this to our previous <em>BFS</em> approach that took <strong>7.131 seconds </strong>to churn out the answers, <em>A*</em> approach is almost <strong>~59x faster!Â ğŸš€</strong>\n</blockquote>\n<p>Letâ€™s run for our puzzle input and go make a coffee!Â â˜•ï¸</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br><br>â—ï¸ Sum of the lengths of the shortest path between every pair of galaxies: XXXXX<br><br>[Done] exited with code=0 in 982.651 seconds</pre>\n<p>Well, this took only <strong>982.651 seconds ~ 16.377 minutes</strong> to run! And this happened because I just ran it and went to make coffee and when I came back, I was it was somewhere around 148th row. Since, I knew we have a total 151 rows only, I just let itÂ run!</p>\n<pre>Finding shortest distance between (148, 104) and (119, 66)<br>Finding shortest distance between (148, 104) and (119, 105)<br>Finding shortest distance between (148, 104) and (119, 116)</pre>\n<p>So, letâ€™s input our answer into the boxÂ andâ€¦</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/830/1*Nld_W8c57EDwOGkKVJHi_g.png\"><figcaption>Yay! ğŸ™Œ</figcaption></figure><p>Hereâ€™s our unpythonic code till now, I will optimise it in PartÂ 2:</p>\n<pre># Day 11: Cosmic Expansion<br><br>from enum import Enum<br>import heapq<br><br><br>EMPTY_SPACE = \".\"<br>GALAXY = \"#\"<br>DISTANCE_MAP = {}<br><br><br>class Direction(Enum):<br>    RIGHT = (0, 1)<br>    LEFT = (0, -1)<br>    DOWN = (1, 0)<br>    UP = (-1, 0)<br><br><br>def calculate_distance(a, b):<br>    return abs(a[0] - b[0]) + abs(a[1] - b[1])  # Manhattan distance<br><br><br>def get_adjacent_galaxies(space_map, galaxy):<br>    adjacent_galaxies = []<br>    for direction in Direction:<br>        i, j = galaxy[0] + direction.value[0], galaxy[1] + direction.value[1]<br>        if 0 &lt;= i &lt; len(space_map) and 0 &lt;= j &lt; len(space_map[0]):<br>            adjacent_galaxies.append((i, j))<br>    return adjacent_galaxies<br><br><br>def find_shortest_path(space_map, start_galaxy, end_galaxy):<br>    galaxies_to_visit = []<br>    heapq.heappush(galaxies_to_visit, (0, start_galaxy))<br>    previous_galaxy = {}<br>    cost_to_reach = {start_galaxy: 0}<br>    estimated_total_cost = {start_galaxy: calculate_distance(start_galaxy, end_galaxy)}<br><br>    while galaxies_to_visit:<br>        current_galaxy = heapq.heappop(galaxies_to_visit)[1]<br><br>        if current_galaxy == end_galaxy:<br>            return cost_to_reach[<br>                current_galaxy<br>            ]  # Return the cost to reach the end galaxy<br><br>        for adjacent_galaxy in get_adjacent_galaxies(space_map, current_galaxy):<br>            tentative_cost = cost_to_reach[current_galaxy] + 1  # assuming uniform cost<br>            if (<br>                adjacent_galaxy not in cost_to_reach<br>                or tentative_cost &lt; cost_to_reach[adjacent_galaxy]<br>            ):<br>                previous_galaxy[adjacent_galaxy] = current_galaxy<br>                cost_to_reach[adjacent_galaxy] = tentative_cost<br>                estimated_total_cost[<br>                    adjacent_galaxy<br>                ] = tentative_cost + calculate_distance(adjacent_galaxy, end_galaxy)<br>                heapq.heappush(<br>                    galaxies_to_visit,<br>                    (estimated_total_cost[adjacent_galaxy], adjacent_galaxy),<br>                )<br><br>    raise Exception(\"No path found between the two galaxies\")<br><br><br>def expand_space_map(space_map):<br>    empty_rows, empty_cols = [], []<br><br>    for i, row in enumerate(space_map):<br>        if GALAXY not in row:<br>            empty_rows.append(i)<br><br>    for i, col in enumerate(space_map[0]):<br>        if GALAXY not in [row[i] for row in space_map]:<br>            empty_cols.append(i)<br><br>    mod_count = 0<br>    for i in empty_rows:<br>        space_map.insert(i + mod_count, EMPTY_SPACE * len(space_map[i]))<br>        mod_count += 1<br><br>    mod_count = 0<br>    for i in empty_cols:<br>        for j, row in enumerate(space_map):<br>            space_map[j] = row[: i + mod_count] + EMPTY_SPACE + row[i + mod_count :]<br>        mod_count += 1<br><br>    return space_map<br><br><br>def find_shortest_distance(galaxy1, galaxy2, space_map):<br>    print(f\"Finding shortest distance between {galaxy1} and {galaxy2}\")<br><br>    distance = DISTANCE_MAP.get(galaxy1, {}).get(galaxy2) or DISTANCE_MAP.get(<br>        galaxy2, {}<br>    ).get(galaxy1)<br>    if distance:<br>        return distance<br><br>    distance = find_shortest_path(space_map, galaxy1, galaxy2)  # Use A* for pathfinding<br><br>    if galaxy1 not in DISTANCE_MAP:<br>        DISTANCE_MAP[galaxy1] = {}<br>    DISTANCE_MAP[galaxy1][galaxy2] = distance<br>    return distance<br><br><br>def find_all_galaxies(space_map):<br>    galaxies = []<br>    for i, row in enumerate(space_map):<br>        for j, col in enumerate(row):<br>            if col == GALAXY:<br>                galaxies.append((i, j))<br>    return galaxies<br><br><br>def analyze_space(space_map):<br>    expanded_space_map = expand_space_map(space_map)<br>    print(<br>        f\"Expanded space map is {len(expanded_space_map)} x {len(expanded_space_map[0])}\"<br>    )<br>    galaxies_locations = find_all_galaxies(expanded_space_map)<br>    print(f\"Number of galaxies: {len(galaxies_locations)}\")<br><br>    for galaxy1 in galaxies_locations:<br>        for galaxy2 in galaxies_locations:<br>            if galaxy1 != galaxy2:<br>                find_shortest_distance(galaxy1, galaxy2, expanded_space_map)<br><br>    sum = 0<br>    for k, v in DISTANCE_MAP.items():<br>        for k1, v1 in v.items():<br>            sum += v1<br><br>    return sum<br><br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br>    sum = analyze_space(space_map)<br>    print(<br>        f\"â—ï¸ Sum of the lengths of the shortest path between every pair of galaxies: {sum}\"<br>    )<br><br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br><br>    sum = analyze_space(space_map.splitlines())<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"âœ… Passed test_analyze_observation()\")<br><br><br>if __name__ == \"__main__\":<br>    # test_analyze_space()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>The galaxies are much older (and thus much farther apart) than the researcher initially estimated.</blockquote>\n<blockquote>Now, instead of the expansion you did before, make each empty row or column one million times larger. That is, each empty row should be replaced with 1000000 empty rows, and each empty column should be replaced with 1000000empty columns.</blockquote>\n<blockquote>(In the example above, if each empty row or column were merely 10 times larger, the sum of the shortest paths between every pair of galaxies would be 1030. If each empty row or column were merely 100 times larger, the sum of the shortest paths between every pair of galaxies would be 8410. However, your universe will need to expand far beyond theseÂ values.)</blockquote>\n<blockquote>Starting with the same initial image, expand the universe according to these new rules, then find the length of the shortest path between every pair of galaxies. What is the sum of theseÂ lengths?</blockquote>\n<p>Well, of course, the galaxies are muchÂ <strong>older!</strong></p>\n<p>So, looks like we need to update how we expand our space map buy a factor of <strong>one million times, </strong>that is<strong>, 1000000x, </strong>for each empty row andÂ column!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*pwCxlg2tQmeeKVJebYZhTQ.png\"></figure><blockquote>Yep! Our current code will not scale at all. <strong>Probably</strong> our solar system sun will collapse into itself before our single threaded Python will be able to compute anything!</blockquote>\n<p>Soâ€¦letâ€™s rethinkÂ this!</p>\n<p>.</p>\n<p>.</p>\n<blockquote>Well shit! Why do I even need any path finding algo here? Isnâ€™t this just simple matrix manipulation? I think I ended up doing over-engineering here! This is classic trap of being Principal Engineer, making problems look more complex than they actuallyÂ are!</blockquote>\n<h3>Revisting PartÂ 1</h3>\n<p>This problem required solving just <strong>Manhattan distance</strong> between 2 nodes. Hereâ€™s an example to get distance between (Galaxy 1, Galaxy 4) and (Galaxy 5, GalaxyÂ 8):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/406/1*FeZ6DaSbYqtfO-B15zLeWg.png\"></figure><p>The formula to get this is absurdly simple asÂ well:</p>\n<blockquote>Manhattan Distance = |x1â€Šâ€”â€Šy1| + |x2â€Šâ€”â€Šy2|</blockquote>\n<p>Which makes my code as simpleÂ as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/837/1*Ro92d-LT-I3LQGcqxirC3A.png\"></figure><p>Solving for part 1, testing with base test case and puzzleÂ input:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>Expanded space map is 12 x 13<br>Number of galaxies: 9<br>Number of possible pairs of galaxies: 36<br>âœ… Passed test_analyze_observation()<br>Expanded space map is 151 x 147<br>Number of galaxies: 426<br>Number of possible pairs of galaxies: 90525<br>â—ï¸ Sum of the lengths of the shortest path between every pair of galaxies: xxxxxx<br><br>[Done] exited with code=0 in 0.199 seconds</pre>\n<p>Yep, correct answer!Â ğŸ¥²</p>\n<h4>Back to PartÂ 2</h4>\n<p>Now, all that is changing is, the <strong>expansion distance</strong> between pairs of galaxies.</p>\n<p>ğŸ’­ If we can somehow just find the number of rows + cols to be modified compared to initial galaxy, we can just do the computation on original space_map and then just increase the distance by a factor ofÂ 1000000</p>\n<blockquote>ğŸ’¡ We can further simplify our code by not having to do the expansion at all as per partÂ 1</blockquote>\n<p>We can introduce a new paramâ€Šâ€”â€Šexpansion_factor which we can pass as 2 for the part one, and 1000000 for part two to keep our codeÂ modular.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*w3rB_I5L5KXzI1CY-AY8ow.png\"></figure><p>Letâ€™s update our base testÂ case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/817/1*FgsL03tvwa3UA2ExhCPylg.png\"></figure><p>And letâ€™s runÂ this:</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>âœ… Passed test_analyze_observation() for expansion_factor=2<br>âœ… Passed test_analyze_observation() for expansion_factor=10<br>âœ… Passed test_analyze_observation() for expansion_factor=100</pre>\n<p>Phew! We can now just load up our puzzle input and call for our 10â¶ expansion_factorÂ :</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qbE8EN2SEYiGUYEuTEw2bA.png\"></figure><p>Letâ€™s run thisÂ up!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>âœ… Passed test_analyze_observation() for expansion_factor=2<br>âœ… Passed test_analyze_observation() for expansion_factor=10<br>âœ… Passed test_analyze_observation() for expansion_factor=100<br>â—ï¸ Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=2: xxxx<br>â€¼ï¸ Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=1000000: xxxxxxxxxx<br><br>[Done] exited with code=0 in 0.843 seconds</pre>\n<p>We get the answer in <strong>0.843 secondsâ€¦.for BOTH the parts + 3 test cases</strong>!Â ğŸ˜¹</p>\n<p>This is why I absolutely loveÂ coding!</p>\n<p>Letâ€™s put this answer in the input box andâ€¦.profit!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/821/1*Me6mzkKI4sceFKZRH8rVWg.png\"><figcaption>ğŸŒŒğŸŒŒğŸŒŒ</figcaption></figure><p>Hereâ€™s our final pythonic yet highly performant code:</p>\n<pre># Day 11: Cosmic Expansion<br><br>class CosmicGrid:<br>    def __init__(self, space_grid):<br>        # Initialize the cosmic grid with the provided space grid<br>        self.space_grid = space_grid<br>        self.grid_height = len(space_grid)<br>        self.grid_width = len(space_grid[0])<br>        # Find rows and columns that are entirely empty<br>        self.empty_rows = self._find_empty_rows()<br>        self.empty_columns = self._find_empty_columns()<br>        # Locate all galaxies within the grid<br>        self.galaxy_positions = self._find_galaxy_positions()<br><br>    def _find_empty_rows(self):<br>        # Identify rows that contain only empty space<br>        empty_rows = set()<br>        for row in range(self.grid_height):<br>            if all(cell == '.' for cell in self.space_grid[row]):<br>                empty_rows.add(row)<br>        return empty_rows<br><br>    def _find_empty_columns(self):<br>        # Identify columns that contain only empty space<br>        empty_columns = set()<br>        for col in range(self.grid_width):<br>            if all(self.space_grid[row][col] == '.' for row in range(self.grid_height)):<br>                empty_columns.add(col)<br>        return empty_columns<br><br>    def _find_galaxy_positions(self):<br>        # Record the positions of all galaxies in the grid<br>        galaxy_positions = []<br>        for row in range(self.grid_height):<br>            for col in range(self.grid_width):<br>                if self.space_grid[row][col] == '#':<br>                    galaxy_positions.append((row, col))<br>        return galaxy_positions<br><br>    def find_shortest_distance(self, galaxy1, galaxy2, expansion_factor):<br>        # Calculate the shortest distance between two galaxies, factoring in cosmic expansion<br>        row_distance = 0<br>        for r in range(min(galaxy1[0], galaxy2[0]), max(galaxy1[0], galaxy2[0]) + 1):<br>            if r in self.empty_rows:<br>                row_distance += 1<br><br>        col_distance = 0<br>        for c in range(min(galaxy1[1], galaxy2[1]), max(galaxy1[1], galaxy2[1]) + 1):<br>            if c in self.empty_columns:<br>                col_distance += 1<br><br>        # Expanded distance is calculated by multiplying empty distances by the expansion factor<br>        # Direct distance is the straight line distance, not through empty space<br>        expanded_row_distance = row_distance * expansion_factor<br>        expanded_col_distance = col_distance * expansion_factor<br>        direct_distance = abs(galaxy1[0] - galaxy2[0]) + abs(galaxy1[1] - galaxy2[1])<br><br>        return expanded_row_distance + expanded_col_distance + direct_distance - row_distance - col_distance<br><br>    def sum_of_shortest_paths(self, expansion_factor):<br>        # Sum the shortest paths between all pairs of galaxies<br>        total_distance = 0<br>        for i, galaxy1 in enumerate(self.galaxy_positions):<br>            for galaxy2 in self.galaxy_positions[i + 1:]:<br>                total_distance += self.find_shortest_distance(galaxy1, galaxy2, expansion_factor)<br>        return total_distance<br><br><br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br><br>    cosmic_grid = CosmicGrid(space_map)<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=2)<br>    print(<br>        f\"â—ï¸ Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=2: {sum}\"<br>    )<br><br><br>def part_two():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br><br>    cosmic_grid = CosmicGrid(space_map)<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=1000000)<br>    print(<br>        f\"â€¼ï¸ Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=1000000: {sum}\"<br>    )<br><br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br>    cosmic_grid = CosmicGrid(space_map.splitlines())<br>    # part one<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=2)<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"âœ… Passed test_analyze_observation() for expansion_factor=2\")<br><br>    # part two<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=10)<br>    assert sum == 1030, f\"Expected 1030, got {sum}\"<br>    print(\"âœ… Passed test_analyze_observation() for expansion_factor=10\")<br><br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=100)<br>    assert sum == 8410, f\"Expected 8410, got {sum}\"<br>    print(\"âœ… Passed test_analyze_observation() for expansion_factor=100\")<br><br><br>if __name__ == \"__main__\":<br>    test_analyze_space()<br>    part_one()<br>    part_two()</pre>\n<p><strong>â˜˜ï¸ Moral of the story? </strong>As a Principal Engineer, Iâ€™m wired to navigate complex problems, often defaulting to intricate solutions like BFS, DFS, Dijkstra, andÂ A*.</p>\n<p>Here, I overcomplicated a straightforward task that simply needed the Manhattan distance formula. This experience was a humbling reminder that sometimes, <strong>simplicity is key</strong>. Itâ€™s easy to overlook the obvious when your mind is tuned to complexity. Itâ€™s crucial to step back and reassess, as the simplest path often leads to the most elegant solution.</p>\n<blockquote><strong><em>This was a lesson in the beauty of simplicity in problem-solving.</em></strong></blockquote>\n<p>p.s: I am deliberating not adding answers here so you can actually spend some time trying to understand how we solved theÂ problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machineÂ ğŸ‘‡</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! ğŸ„</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6e545dad06bb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*WU-oHlsxWjavblYa\"><figcaption>Cosmic Expansion (via DALL-EÂ 3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/11\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You continue following signs for â€œHot Springsâ€ and eventually come across an <a href=\"https://en.wikipedia.org/wiki/Observatory\">observatory</a>. The Elf within turns out to be a researcher studying cosmic expansion using the giant telescope here.</blockquote>\n<blockquote>He doesnâ€™t know anything about the missing machine parts; heâ€™s only visiting for this research project. However, he confirms that the hot springs are the next-closest area likely to have people; heâ€™ll even take you straight there once heâ€™s done with todayâ€™s observation analysis.</blockquote>\n<blockquote>Maybe you can help him with the analysis to speed thingsÂ up?</blockquote>\n<blockquote>The researcher has collected a bunch of data and compiled the data into a single giant image (your puzzle input). The image includes empty space (.) and galaxies (#). ForÂ example:</blockquote>\n<blockquote>...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....</blockquote>\n<blockquote>The researcher is trying to figure out the sum of the lengths of the shortest path between every pair of galaxies. However, thereâ€™s a catch: the universe expanded in the time it took the light from those galaxies to reach the observatory.</blockquote>\n<blockquote>Due to something involving gravitational effects, only some space expands. In fact, the result is that any rows or columns that contain no galaxiesshould all actually be twice asÂ big.</blockquote>\n<blockquote>In the above example, three columns and two rows contain no galaxies:</blockquote>\n<blockquote>v v v<br>Â ...#......<br>Â .......#..<br> #.........<br>&gt;..........&lt;<br>Â ......#...<br>Â .#........<br>Â .........#<br>&gt;..........&lt;<br>Â .......#..<br> #...#.....<br> ^ ^Â ^</blockquote>\n<blockquote>These rows and columns need to be twice as big; the result of cosmic expansion therefore looks likeÂ this:</blockquote>\n<blockquote>....#........<br>.........#...<br>#............<br>.............<br>.............<br>........#....<br>.#...........<br>............#<br>.............<br>.............<br>.........#...<br>#....#.......</blockquote>\n<blockquote>Equipped with this expanded universe, the shortest path between every pair of galaxies can be found. It can help to assign every galaxy a uniqueÂ number:</blockquote>\n<blockquote>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>............6<br>.............<br>.............<br>.........7...<br>8....9.......</blockquote>\n<blockquote>In these 9 galaxies, there are 36 pairs. Only count each pair once; order within the pair doesnâ€™t matter. For each pair, find any shortest path between the two galaxies using only steps that move up, down, left, or right exactly oneÂ . or # at a time. (The shortest path between two galaxies is allowed to pass through anotherÂ galaxy.)</blockquote>\n<blockquote>For example, here is one of the shortest paths between galaxies 5 andÂ 9:</blockquote>\n<blockquote>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>.##.........6<br>..##.........<br>...##........<br>....##...7...<br>8....9.......</blockquote>\n<blockquote>This path has length 9 because it takes a minimum of nine steps to get from galaxy 5 to galaxy 9 (the eight locations marked # plus the step onto galaxy 9 itself). Here are some other example shortest pathÂ lengths:</blockquote>\n<blockquote>Between galaxy 1 and galaxy 7:Â 15</blockquote>\n<blockquote>Between galaxy 3 and galaxy 6:Â 17</blockquote>\n<blockquote>Between galaxy 8 and galaxy 9:Â 5</blockquote>\n<blockquote>In this example, after expanding the universe, the sum of the shortest path between all 36 pairs of galaxies isÂ 374.</blockquote>\n<blockquote>Expand the universe, then find the length of the shortest path between every pair of galaxies. What is the sum of theseÂ lengths?</blockquote>\n<p><em>Finally! A space exploration problem. I am a sucker forÂ those!</em></p>\n<p>So, letâ€™s look at the problem, we have an image of space from the observatory and it looks something likeÂ this:</p>\n<pre>...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....</pre>\n<p>And we need to compute the sum of the lengths of the shortest path between every pair of galaxies!</p>\n<blockquote>â—ï¸The catch being, that by the time light reaches to us, the space expands due to ever expanding universe, but only some part, resulting in any <strong>rows or columns</strong> that contain <strong>no galaxies</strong> should all actually be <strong>twice asÂ big.</strong>\n</blockquote>\n<p>Letâ€™s visualise this?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lUFvdLG-8zW-7eo4Vvl74w.png\"><figcaption>This seems like a good firstÂ step</figcaption></figure><p>Once we have the final image! We can just number the galaxiesÂ like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*hZRn53JjHjOFcBspyvzYLA.png\"></figure><p>And then we can just find the shortest distance from each pair of galaxies!</p>\n<p>Seems pretty straight forward right? Letâ€™sÂ code!</p>\n<p>As usual, I will begin with writing our base case as the ultimate validator!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/528/1*wpLfzZ-B7q-gkt46Zka26A.png\"></figure><p>And now letâ€™s start expanding! Itâ€™s clear we first need to <strong><em>expand</em></strong> space by finding empty rows and columns and doubling it. So, letâ€™s first just doÂ that.</p>\n<p>Hereâ€™s a simple function expand_space that just doesÂ that:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IvD01NKWBgQB3m5LNNoSOQ.png\"></figure><blockquote>ğŸ’¡ Caught a bug, as if we modify the space_map while iterating through it, the empty_rows elements start to point to an incorrect index. To fix that, we can just introduce something like a mod_count which can help us keep a track of original index in modified space_map.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VoSoXFEiPUwgq5Kqi7hERw.png\"><figcaption>Fixed!</figcaption></figure><p>Now we can find all the galaxies locations in the expanded_space_map with a simple function:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/471/1*LszcXw2pLv5S_15-MqpBCQ.png\"></figure><p>ğŸ’­ The last step is to now take 1 galaxy and find its shortest distance from all other galaxies and then repeat this process for all galaxies!</p>\n<p>Well, before even touching the code, I can already see a lot of steps to optimise this one! For example: If we have found the shortest distance from Galaxy_1 to Galaxy_2Â , it will be same other way around, so we can save extra compute by just refering to aÂ cache.</p>\n<pre>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>............6<br>.............<br>.............<br>.........7...<br>8....9.......</pre>\n<p>So, in case of this example, where we have 9 galaxies can could have 81 combinations, since we canâ€™t repeat a pair, the formulaÂ becomes:</p>\n<blockquote>Number of combinations= <em>n</em>! / <em>r</em>!(<em>n</em>âˆ’<em>r</em>)!â€‹</blockquote>\n<p>Solving for ourÂ case:</p>\n<blockquote>\n<em>9C</em>2â€‹ = 9! / 2!(9âˆ’2)! â€‹=Â 36</blockquote>\n<p><strong>36 combinations!</strong></p>\n<p>Letâ€™s write some code? I will be using goodâ€™ol <strong>BFS (breadth first search)</strong> to find the shortest path for each pair of galaxies. <em>We may come back and optimise this to a more greedy approach for faster computation!</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fnAe9-H1FYiZRcnQHgc26Q.png\"><figcaption>Classic BFS!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*2_MOrRwleCiWT4-DMKLxNg.png\"><figcaption>Ofcourse, I forgot `list` is unhashable ğŸ¤¦â€â™‚ï¸</figcaption></figure><p>We can always hash a tupple though!Â ;)</p>\n<p>Finally after a lot of iterations:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HOtCjKwT6txXLOfaCZCd9w.png\"><figcaption>36!</figcaption></figure><p>Letâ€™s check our test caseÂ now?</p>\n<p>Hereâ€™s our MVP code tillÂ now:</p>\n<pre># Day 11: Cosmic Expansion<br><br>from enum import Enum<br><br><br>EMPTY_SPACE = \".\"<br>GALAXY = \"#\"<br>DISTANCE_MAP = {}<br><br>class Direction(Enum):<br>        RIGHT = (0, 1)<br>        LEFT = (0, -1)<br>        DOWN = (1, 0)<br>        UP = (-1, 0)<br><br><br>def expand_space_map(space_map):<br>    empty_rows, empty_cols = [], []<br><br>    for i, row in enumerate(space_map):<br>        if GALAXY not in row:<br>            empty_rows.append(i)<br><br>    for i, col in enumerate(space_map[0]):<br>        if GALAXY not in [row[i] for row in space_map]:<br>            empty_cols.append(i)<br><br>    mod_count = 0<br>    for i in empty_rows:<br>        space_map.insert(i + mod_count, EMPTY_SPACE * len(space_map[i]))<br>        mod_count += 1<br><br>    mod_count = 0<br>    for i in empty_cols:<br>        for j, row in enumerate(space_map):<br>            space_map[j] = row[: i + mod_count] + EMPTY_SPACE + row[i + mod_count :]<br>        mod_count += 1<br><br>    return space_map<br><br><br>def find_shortest_distance(galaxy1, galaxy2, space_map):<br>    print(f\"Finding shortest distance between {galaxy1} and {galaxy2}\")<br>    # check if the distance between the two galaxies is already calculated<br>    distance = DISTANCE_MAP.get(galaxy1, {}).get(galaxy2) or DISTANCE_MAP.get(<br>        galaxy2, {}<br>    ).get(galaxy1)<br>    if distance:<br>        return distance<br><br>    # using BFS to find the shortest path between two galaxies<br>    queue = [galaxy1]  # initialize the queue with the starting galaxy<br>    visited = set()  # set to keep track of visited galaxies<br>    distance = 0  # initialize the distance to 0<br>    while queue:<br>        for _ in range(len(queue)):<br>            current = queue.pop(0)  # get the next galaxy from the queue<br>            if current == galaxy2:  # if we reach the destination galaxy<br>                if galaxy1 not in DISTANCE_MAP:<br>                    DISTANCE_MAP[galaxy1] = {}<br>                DISTANCE_MAP[galaxy1][galaxy2] = distance  # store the distance between the galaxies<br>                return distance<br>            visited.add(current)  # mark the current galaxy as visited<br><br>            for direction in Direction:  # explore all possible directions<br>                i, j = current[0] + direction.value[0], current[1] + direction.value[1]<br>                if (<br>                    0 &lt;= i &lt; len(space_map)<br>                    and 0 &lt;= j &lt; len(space_map[0])<br>                    and (i, j) not in visited<br>                ):<br>                    queue.append((i, j))  # add the neighboring galaxy to the queue<br>        distance += 1  # increment the distance after exploring all galaxies at the current level<br><br>    raise Exception(\"No path found between the two galaxies\")<br><br><br>def find_all_galaxies(space_map):<br>    galaxies = []<br>    for i, row in enumerate(space_map):<br>        for j, col in enumerate(row):<br>            if col == GALAXY:<br>                galaxies.append((i, j))<br>    return galaxies<br><br><br>def analyze_space(space_map):<br>    expanded_space_map = expand_space_map(space_map)<br>    print(f\"Expanded space map is {len(expanded_space_map)} x {len(expanded_space_map[0])}\")<br>    galaxies_locations = find_all_galaxies(expanded_space_map)<br>    print(f\"Number of galaxies: {len(galaxies_locations)}\")<br><br>    for galaxy1 in galaxies_locations:<br>        for galaxy2 in galaxies_locations:<br>            if galaxy1 != galaxy2:<br>                find_shortest_distance(galaxy1, galaxy2, expanded_space_map)<br><br>    sum = 0 <br>    for k,v in DISTANCE_MAP.items():<br>        for k1,v1 in v.items():<br>            sum += v1<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br>    sum =  analyze_space(space_map)<br>    print(f\"â—ï¸ Sum of the lengths of the shortest path between every pair of galaxies: {sum}\")<br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br><br>    sum = analyze_space(space_map.splitlines())<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"âœ… Passed test_analyze_observation()\")<br><br><br>if __name__ == \"__main__\":<br>    test_analyze_space()<br>    # part_one()</pre>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>âœ… Passed test_analyze_observation()<br><br>[Done] exited with code=0 in 7.131 seconds</pre>\n<p>Well, it did took 7.131 seconds to compute for a simple testcase, letâ€™s see if it can do it for puzzleÂ input?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/991/1*qsb5pCVb9HnxVVOv7uzGzQ.png\"></figure><p>And compute!!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*NTrAEUF4t-HG-9FlN3uA6Q.png\"><figcaption>2 mins in, doesnâ€™t seemÂ likely!</figcaption></figure><p>Letâ€™s add some logging to understand the scale of theÂ problem?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/896/1*KatgSN7P3HCewqc06-gjLw.gif\"><figcaption>Yeahâ€¦.this is not gonnaÂ compute!</figcaption></figure><p>We have 426 Galaxies in a map of size 151 x 147 which gives us 426C2 combinations, equaling 90525 possible pairs! We need to make it more efficient!</p>\n<blockquote>While, I can take the easy path of just doings the <strong>Bi-directional BFS</strong> where I can look up from both Galaxy 1 and Galaxy 2, I feels itâ€™s better to take a peak into <strong>A* or Dijkstraâ€™s </strong>Algorithm for our shortest path finding to be more efficient!</blockquote>\n<p>I am bit rusty donâ€™t remember A* algo exactly but I do remember that A* is a type of <strong>greedy approch</strong> which does a <strong>smart search</strong> through a maze, where at each step it makes an <strong>informed guess</strong> about the best next step based on <em>how far it has already traveled</em> and <em>how far it still has to go</em>, according to the map. Itâ€™s a blend of exploring and using what you know to make good guesses, which makes it efficient and effective for findingÂ paths.</p>\n<p>Letâ€™s use Github Copilot to quickly generate a A* method for searching and then refactor it to suit our galaxy and space_map problem:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YrmYmgoRwh7xZY6OUTjUHQ.png\"><figcaption>Looks good!</figcaption></figure><p>Now, letâ€™s run for the base test case with our loggingÂ enabled?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>Expanded space map is 12 x 13<br>Number of galaxies: 9<br>Finding shortest distance between (0, 4) and (1, 9)<br>Finding shortest distance between (0, 4) and (2, 0)<br>Finding shortest distance between (0, 4) and (5, 8)<br>Finding shortest distance between (0, 4) and (6, 1)<br>Finding shortest distance between (0, 4) and (7, 12)<br>Finding shortest distance between (0, 4) and (10, 9)<br>Finding shortest distance between (0, 4) and (11, 0)<br>Finding shortest distance between (0, 4) and (11, 5)<br>Finding shortest distance between (1, 9) and (0, 4)<br>Finding shortest distance between (1, 9) and (2, 0)<br>Finding shortest distance between (1, 9) and (5, 8)<br>Finding shortest distance between (1, 9) and (6, 1)<br>Finding shortest distance between (1, 9) and (7, 12)<br>Finding shortest distance between (1, 9) and (10, 9)<br>Finding shortest distance between (1, 9) and (11, 0)<br>Finding shortest distance between (1, 9) and (11, 5)<br>Finding shortest distance between (2, 0) and (0, 4)<br>Finding shortest distance between (2, 0) and (1, 9)<br>Finding shortest distance between (2, 0) and (5, 8)<br>Finding shortest distance between (2, 0) and (6, 1)<br>Finding shortest distance between (2, 0) and (7, 12)<br>Finding shortest distance between (2, 0) and (10, 9)<br>Finding shortest distance between (2, 0) and (11, 0)<br>Finding shortest distance between (2, 0) and (11, 5)<br>Finding shortest distance between (5, 8) and (0, 4)<br>Finding shortest distance between (5, 8) and (1, 9)<br>Finding shortest distance between (5, 8) and (2, 0)<br>Finding shortest distance between (5, 8) and (6, 1)<br>Finding shortest distance between (5, 8) and (7, 12)<br>Finding shortest distance between (5, 8) and (10, 9)<br>Finding shortest distance between (5, 8) and (11, 0)<br>Finding shortest distance between (5, 8) and (11, 5)<br>Finding shortest distance between (6, 1) and (0, 4)<br>Finding shortest distance between (6, 1) and (1, 9)<br>Finding shortest distance between (6, 1) and (2, 0)<br>Finding shortest distance between (6, 1) and (5, 8)<br>Finding shortest distance between (6, 1) and (7, 12)<br>Finding shortest distance between (6, 1) and (10, 9)<br>Finding shortest distance between (6, 1) and (11, 0)<br>Finding shortest distance between (6, 1) and (11, 5)<br>Finding shortest distance between (7, 12) and (0, 4)<br>Finding shortest distance between (7, 12) and (1, 9)<br>Finding shortest distance between (7, 12) and (2, 0)<br>Finding shortest distance between (7, 12) and (5, 8)<br>Finding shortest distance between (7, 12) and (6, 1)<br>Finding shortest distance between (7, 12) and (10, 9)<br>Finding shortest distance between (7, 12) and (11, 0)<br>Finding shortest distance between (7, 12) and (11, 5)<br>Finding shortest distance between (10, 9) and (0, 4)<br>Finding shortest distance between (10, 9) and (1, 9)<br>Finding shortest distance between (10, 9) and (2, 0)<br>Finding shortest distance between (10, 9) and (5, 8)<br>Finding shortest distance between (10, 9) and (6, 1)<br>Finding shortest distance between (10, 9) and (7, 12)<br>Finding shortest distance between (10, 9) and (11, 0)<br>Finding shortest distance between (10, 9) and (11, 5)<br>Finding shortest distance between (11, 0) and (0, 4)<br>Finding shortest distance between (11, 0) and (1, 9)<br>Finding shortest distance between (11, 0) and (2, 0)<br>Finding shortest distance between (11, 0) and (5, 8)<br>Finding shortest distance between (11, 0) and (6, 1)<br>Finding shortest distance between (11, 0) and (7, 12)<br>Finding shortest distance between (11, 0) and (10, 9)<br>Finding shortest distance between (11, 0) and (11, 5)<br>Finding shortest distance between (11, 5) and (0, 4)<br>Finding shortest distance between (11, 5) and (1, 9)<br>Finding shortest distance between (11, 5) and (2, 0)<br>Finding shortest distance between (11, 5) and (5, 8)<br>Finding shortest distance between (11, 5) and (6, 1)<br>Finding shortest distance between (11, 5) and (7, 12)<br>Finding shortest distance between (11, 5) and (10, 9)<br>Finding shortest distance between (11, 5) and (11, 0)<br>âœ… Passed test_analyze_observation()<br><br>[Done] exited with code=0 in 0.121 seconds</pre>\n<blockquote>Woah! <strong>0.121 seconds</strong> for the base test case. Comparing this to our previous <em>BFS</em> approach that took <strong>7.131 seconds </strong>to churn out the answers, <em>A*</em> approach is almost <strong>~59x faster!Â ğŸš€</strong>\n</blockquote>\n<p>Letâ€™s run for our puzzle input and go make a coffee!Â â˜•ï¸</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br><br>â—ï¸ Sum of the lengths of the shortest path between every pair of galaxies: XXXXX<br><br>[Done] exited with code=0 in 982.651 seconds</pre>\n<p>Well, this took only <strong>982.651 seconds ~ 16.377 minutes</strong> to run! And this happened because I just ran it and went to make coffee and when I came back, I was it was somewhere around 148th row. Since, I knew we have a total 151 rows only, I just let itÂ run!</p>\n<pre>Finding shortest distance between (148, 104) and (119, 66)<br>Finding shortest distance between (148, 104) and (119, 105)<br>Finding shortest distance between (148, 104) and (119, 116)</pre>\n<p>So, letâ€™s input our answer into the boxÂ andâ€¦</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/830/1*Nld_W8c57EDwOGkKVJHi_g.png\"><figcaption>Yay! ğŸ™Œ</figcaption></figure><p>Hereâ€™s our unpythonic code till now, I will optimise it in PartÂ 2:</p>\n<pre># Day 11: Cosmic Expansion<br><br>from enum import Enum<br>import heapq<br><br><br>EMPTY_SPACE = \".\"<br>GALAXY = \"#\"<br>DISTANCE_MAP = {}<br><br><br>class Direction(Enum):<br>    RIGHT = (0, 1)<br>    LEFT = (0, -1)<br>    DOWN = (1, 0)<br>    UP = (-1, 0)<br><br><br>def calculate_distance(a, b):<br>    return abs(a[0] - b[0]) + abs(a[1] - b[1])  # Manhattan distance<br><br><br>def get_adjacent_galaxies(space_map, galaxy):<br>    adjacent_galaxies = []<br>    for direction in Direction:<br>        i, j = galaxy[0] + direction.value[0], galaxy[1] + direction.value[1]<br>        if 0 &lt;= i &lt; len(space_map) and 0 &lt;= j &lt; len(space_map[0]):<br>            adjacent_galaxies.append((i, j))<br>    return adjacent_galaxies<br><br><br>def find_shortest_path(space_map, start_galaxy, end_galaxy):<br>    galaxies_to_visit = []<br>    heapq.heappush(galaxies_to_visit, (0, start_galaxy))<br>    previous_galaxy = {}<br>    cost_to_reach = {start_galaxy: 0}<br>    estimated_total_cost = {start_galaxy: calculate_distance(start_galaxy, end_galaxy)}<br><br>    while galaxies_to_visit:<br>        current_galaxy = heapq.heappop(galaxies_to_visit)[1]<br><br>        if current_galaxy == end_galaxy:<br>            return cost_to_reach[<br>                current_galaxy<br>            ]  # Return the cost to reach the end galaxy<br><br>        for adjacent_galaxy in get_adjacent_galaxies(space_map, current_galaxy):<br>            tentative_cost = cost_to_reach[current_galaxy] + 1  # assuming uniform cost<br>            if (<br>                adjacent_galaxy not in cost_to_reach<br>                or tentative_cost &lt; cost_to_reach[adjacent_galaxy]<br>            ):<br>                previous_galaxy[adjacent_galaxy] = current_galaxy<br>                cost_to_reach[adjacent_galaxy] = tentative_cost<br>                estimated_total_cost[<br>                    adjacent_galaxy<br>                ] = tentative_cost + calculate_distance(adjacent_galaxy, end_galaxy)<br>                heapq.heappush(<br>                    galaxies_to_visit,<br>                    (estimated_total_cost[adjacent_galaxy], adjacent_galaxy),<br>                )<br><br>    raise Exception(\"No path found between the two galaxies\")<br><br><br>def expand_space_map(space_map):<br>    empty_rows, empty_cols = [], []<br><br>    for i, row in enumerate(space_map):<br>        if GALAXY not in row:<br>            empty_rows.append(i)<br><br>    for i, col in enumerate(space_map[0]):<br>        if GALAXY not in [row[i] for row in space_map]:<br>            empty_cols.append(i)<br><br>    mod_count = 0<br>    for i in empty_rows:<br>        space_map.insert(i + mod_count, EMPTY_SPACE * len(space_map[i]))<br>        mod_count += 1<br><br>    mod_count = 0<br>    for i in empty_cols:<br>        for j, row in enumerate(space_map):<br>            space_map[j] = row[: i + mod_count] + EMPTY_SPACE + row[i + mod_count :]<br>        mod_count += 1<br><br>    return space_map<br><br><br>def find_shortest_distance(galaxy1, galaxy2, space_map):<br>    print(f\"Finding shortest distance between {galaxy1} and {galaxy2}\")<br><br>    distance = DISTANCE_MAP.get(galaxy1, {}).get(galaxy2) or DISTANCE_MAP.get(<br>        galaxy2, {}<br>    ).get(galaxy1)<br>    if distance:<br>        return distance<br><br>    distance = find_shortest_path(space_map, galaxy1, galaxy2)  # Use A* for pathfinding<br><br>    if galaxy1 not in DISTANCE_MAP:<br>        DISTANCE_MAP[galaxy1] = {}<br>    DISTANCE_MAP[galaxy1][galaxy2] = distance<br>    return distance<br><br><br>def find_all_galaxies(space_map):<br>    galaxies = []<br>    for i, row in enumerate(space_map):<br>        for j, col in enumerate(row):<br>            if col == GALAXY:<br>                galaxies.append((i, j))<br>    return galaxies<br><br><br>def analyze_space(space_map):<br>    expanded_space_map = expand_space_map(space_map)<br>    print(<br>        f\"Expanded space map is {len(expanded_space_map)} x {len(expanded_space_map[0])}\"<br>    )<br>    galaxies_locations = find_all_galaxies(expanded_space_map)<br>    print(f\"Number of galaxies: {len(galaxies_locations)}\")<br><br>    for galaxy1 in galaxies_locations:<br>        for galaxy2 in galaxies_locations:<br>            if galaxy1 != galaxy2:<br>                find_shortest_distance(galaxy1, galaxy2, expanded_space_map)<br><br>    sum = 0<br>    for k, v in DISTANCE_MAP.items():<br>        for k1, v1 in v.items():<br>            sum += v1<br><br>    return sum<br><br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br>    sum = analyze_space(space_map)<br>    print(<br>        f\"â—ï¸ Sum of the lengths of the shortest path between every pair of galaxies: {sum}\"<br>    )<br><br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br><br>    sum = analyze_space(space_map.splitlines())<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"âœ… Passed test_analyze_observation()\")<br><br><br>if __name__ == \"__main__\":<br>    # test_analyze_space()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>The galaxies are much older (and thus much farther apart) than the researcher initially estimated.</blockquote>\n<blockquote>Now, instead of the expansion you did before, make each empty row or column one million times larger. That is, each empty row should be replaced with 1000000 empty rows, and each empty column should be replaced with 1000000empty columns.</blockquote>\n<blockquote>(In the example above, if each empty row or column were merely 10 times larger, the sum of the shortest paths between every pair of galaxies would be 1030. If each empty row or column were merely 100 times larger, the sum of the shortest paths between every pair of galaxies would be 8410. However, your universe will need to expand far beyond theseÂ values.)</blockquote>\n<blockquote>Starting with the same initial image, expand the universe according to these new rules, then find the length of the shortest path between every pair of galaxies. What is the sum of theseÂ lengths?</blockquote>\n<p>Well, of course, the galaxies are muchÂ <strong>older!</strong></p>\n<p>So, looks like we need to update how we expand our space map buy a factor of <strong>one million times, </strong>that is<strong>, 1000000x, </strong>for each empty row andÂ column!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*pwCxlg2tQmeeKVJebYZhTQ.png\"></figure><blockquote>Yep! Our current code will not scale at all. <strong>Probably</strong> our solar system sun will collapse into itself before our single threaded Python will be able to compute anything!</blockquote>\n<p>Soâ€¦letâ€™s rethinkÂ this!</p>\n<p>.</p>\n<p>.</p>\n<blockquote>Well shit! Why do I even need any path finding algo here? Isnâ€™t this just simple matrix manipulation? I think I ended up doing over-engineering here! This is classic trap of being Principal Engineer, making problems look more complex than they actuallyÂ are!</blockquote>\n<h3>Revisting PartÂ 1</h3>\n<p>This problem required solving just <strong>Manhattan distance</strong> between 2 nodes. Hereâ€™s an example to get distance between (Galaxy 1, Galaxy 4) and (Galaxy 5, GalaxyÂ 8):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/406/1*FeZ6DaSbYqtfO-B15zLeWg.png\"></figure><p>The formula to get this is absurdly simple asÂ well:</p>\n<blockquote>Manhattan Distance = |x1â€Šâ€”â€Šy1| + |x2â€Šâ€”â€Šy2|</blockquote>\n<p>Which makes my code as simpleÂ as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/837/1*Ro92d-LT-I3LQGcqxirC3A.png\"></figure><p>Solving for part 1, testing with base test case and puzzleÂ input:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>Expanded space map is 12 x 13<br>Number of galaxies: 9<br>Number of possible pairs of galaxies: 36<br>âœ… Passed test_analyze_observation()<br>Expanded space map is 151 x 147<br>Number of galaxies: 426<br>Number of possible pairs of galaxies: 90525<br>â—ï¸ Sum of the lengths of the shortest path between every pair of galaxies: xxxxxx<br><br>[Done] exited with code=0 in 0.199 seconds</pre>\n<p>Yep, correct answer!Â ğŸ¥²</p>\n<h4>Back to PartÂ 2</h4>\n<p>Now, all that is changing is, the <strong>expansion distance</strong> between pairs of galaxies.</p>\n<p>ğŸ’­ If we can somehow just find the number of rows + cols to be modified compared to initial galaxy, we can just do the computation on original space_map and then just increase the distance by a factor ofÂ 1000000</p>\n<blockquote>ğŸ’¡ We can further simplify our code by not having to do the expansion at all as per partÂ 1</blockquote>\n<p>We can introduce a new paramâ€Šâ€”â€Šexpansion_factor which we can pass as 2 for the part one, and 1000000 for part two to keep our codeÂ modular.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*w3rB_I5L5KXzI1CY-AY8ow.png\"></figure><p>Letâ€™s update our base testÂ case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/817/1*FgsL03tvwa3UA2ExhCPylg.png\"></figure><p>And letâ€™s runÂ this:</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>âœ… Passed test_analyze_observation() for expansion_factor=2<br>âœ… Passed test_analyze_observation() for expansion_factor=10<br>âœ… Passed test_analyze_observation() for expansion_factor=100</pre>\n<p>Phew! We can now just load up our puzzle input and call for our 10â¶ expansion_factorÂ :</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qbE8EN2SEYiGUYEuTEw2bA.png\"></figure><p>Letâ€™s run thisÂ up!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>âœ… Passed test_analyze_observation() for expansion_factor=2<br>âœ… Passed test_analyze_observation() for expansion_factor=10<br>âœ… Passed test_analyze_observation() for expansion_factor=100<br>â—ï¸ Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=2: xxxx<br>â€¼ï¸ Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=1000000: xxxxxxxxxx<br><br>[Done] exited with code=0 in 0.843 seconds</pre>\n<p>We get the answer in <strong>0.843 secondsâ€¦.for BOTH the parts + 3 test cases</strong>!Â ğŸ˜¹</p>\n<p>This is why I absolutely loveÂ coding!</p>\n<p>Letâ€™s put this answer in the input box andâ€¦.profit!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/821/1*Me6mzkKI4sceFKZRH8rVWg.png\"><figcaption>ğŸŒŒğŸŒŒğŸŒŒ</figcaption></figure><p>Hereâ€™s our final pythonic yet highly performant code:</p>\n<pre># Day 11: Cosmic Expansion<br><br>class CosmicGrid:<br>    def __init__(self, space_grid):<br>        # Initialize the cosmic grid with the provided space grid<br>        self.space_grid = space_grid<br>        self.grid_height = len(space_grid)<br>        self.grid_width = len(space_grid[0])<br>        # Find rows and columns that are entirely empty<br>        self.empty_rows = self._find_empty_rows()<br>        self.empty_columns = self._find_empty_columns()<br>        # Locate all galaxies within the grid<br>        self.galaxy_positions = self._find_galaxy_positions()<br><br>    def _find_empty_rows(self):<br>        # Identify rows that contain only empty space<br>        empty_rows = set()<br>        for row in range(self.grid_height):<br>            if all(cell == '.' for cell in self.space_grid[row]):<br>                empty_rows.add(row)<br>        return empty_rows<br><br>    def _find_empty_columns(self):<br>        # Identify columns that contain only empty space<br>        empty_columns = set()<br>        for col in range(self.grid_width):<br>            if all(self.space_grid[row][col] == '.' for row in range(self.grid_height)):<br>                empty_columns.add(col)<br>        return empty_columns<br><br>    def _find_galaxy_positions(self):<br>        # Record the positions of all galaxies in the grid<br>        galaxy_positions = []<br>        for row in range(self.grid_height):<br>            for col in range(self.grid_width):<br>                if self.space_grid[row][col] == '#':<br>                    galaxy_positions.append((row, col))<br>        return galaxy_positions<br><br>    def find_shortest_distance(self, galaxy1, galaxy2, expansion_factor):<br>        # Calculate the shortest distance between two galaxies, factoring in cosmic expansion<br>        row_distance = 0<br>        for r in range(min(galaxy1[0], galaxy2[0]), max(galaxy1[0], galaxy2[0]) + 1):<br>            if r in self.empty_rows:<br>                row_distance += 1<br><br>        col_distance = 0<br>        for c in range(min(galaxy1[1], galaxy2[1]), max(galaxy1[1], galaxy2[1]) + 1):<br>            if c in self.empty_columns:<br>                col_distance += 1<br><br>        # Expanded distance is calculated by multiplying empty distances by the expansion factor<br>        # Direct distance is the straight line distance, not through empty space<br>        expanded_row_distance = row_distance * expansion_factor<br>        expanded_col_distance = col_distance * expansion_factor<br>        direct_distance = abs(galaxy1[0] - galaxy2[0]) + abs(galaxy1[1] - galaxy2[1])<br><br>        return expanded_row_distance + expanded_col_distance + direct_distance - row_distance - col_distance<br><br>    def sum_of_shortest_paths(self, expansion_factor):<br>        # Sum the shortest paths between all pairs of galaxies<br>        total_distance = 0<br>        for i, galaxy1 in enumerate(self.galaxy_positions):<br>            for galaxy2 in self.galaxy_positions[i + 1:]:<br>                total_distance += self.find_shortest_distance(galaxy1, galaxy2, expansion_factor)<br>        return total_distance<br><br><br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br><br>    cosmic_grid = CosmicGrid(space_map)<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=2)<br>    print(<br>        f\"â—ï¸ Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=2: {sum}\"<br>    )<br><br><br>def part_two():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br><br>    cosmic_grid = CosmicGrid(space_map)<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=1000000)<br>    print(<br>        f\"â€¼ï¸ Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=1000000: {sum}\"<br>    )<br><br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br>    cosmic_grid = CosmicGrid(space_map.splitlines())<br>    # part one<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=2)<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"âœ… Passed test_analyze_observation() for expansion_factor=2\")<br><br>    # part two<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=10)<br>    assert sum == 1030, f\"Expected 1030, got {sum}\"<br>    print(\"âœ… Passed test_analyze_observation() for expansion_factor=10\")<br><br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=100)<br>    assert sum == 8410, f\"Expected 8410, got {sum}\"<br>    print(\"âœ… Passed test_analyze_observation() for expansion_factor=100\")<br><br><br>if __name__ == \"__main__\":<br>    test_analyze_space()<br>    part_one()<br>    part_two()</pre>\n<p><strong>â˜˜ï¸ Moral of the story? </strong>As a Principal Engineer, Iâ€™m wired to navigate complex problems, often defaulting to intricate solutions like BFS, DFS, Dijkstra, andÂ A*.</p>\n<p>Here, I overcomplicated a straightforward task that simply needed the Manhattan distance formula. This experience was a humbling reminder that sometimes, <strong>simplicity is key</strong>. Itâ€™s easy to overlook the obvious when your mind is tuned to complexity. Itâ€™s crucial to step back and reassess, as the simplest path often leads to the most elegant solution.</p>\n<blockquote><strong><em>This was a lesson in the beauty of simplicity in problem-solving.</em></strong></blockquote>\n<p>p.s: I am deliberating not adding answers here so you can actually spend some time trying to understand how we solved theÂ problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machineÂ ğŸ‘‡</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! ğŸ„</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6e545dad06bb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "christmas",
        "python",
        "advent-of-code-2023",
        "advent-of-code"
      ]
    }
  ]
}