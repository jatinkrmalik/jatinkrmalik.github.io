{
  "status": "ok",
  "feed": {
    "url": "https://medium.com/feed/@jatinkrmalik",
    "title": "Stories by Jatin K Malik on Medium",
    "link": "https://medium.com/@jatinkrmalik?source=rss-ec576e4b06b0------2",
    "author": "",
    "description": "Stories by Jatin K Malik on Medium",
    "image": "https://cdn-images-1.medium.com/fit/c/150/150/2*9w8uaQp8uqA5wtRu-DltrQ.png"
  },
  "items": [
    {
      "title": "[Day 14] Parabolic Reflector Dish // Advent of Code 2023 (Python)",
      "pubDate": "2023-12-21 21:01:16",
      "link": "https://medium.com/@jatinkrmalik/day-14-parabolic-reflector-dish-advent-of-code-2023-python-10760f12f5a5?source=rss-ec576e4b06b0------2",
      "guid": "https://medium.com/p/10760f12f5a5",
      "author": "Jatin K Malik",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*zkAVIfrKih2TgfjK\"><figcaption>Parabolic Reflector Dish (via DALL-E¬†3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/14\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You reach the place where all of the mirrors were pointing: a massive <a href=\"https://en.wikipedia.org/wiki/Parabolic_reflector\">parabolic reflector dish</a> attached to the side of another large mountain.</blockquote>\n<blockquote>The dish is made up of many small mirrors, but while the mirrors themselves are roughly in the shape of a parabolic reflector dish, each individual mirror seems to be pointing in slightly the wrong direction. If the dish is meant to focus light, all it‚Äôs doing right now is sending it in a vague direction.</blockquote>\n<blockquote>This system must be what provides the energy for the lava! If you focus the reflector dish, maybe you can go where it‚Äôs pointing and use the light to fix the lava production.</blockquote>\n<blockquote>Upon closer inspection, the individual mirrors each appear to be connected via an elaborate system of ropes and pulleys to a large metal platform below the dish. The platform is covered in large rocks of various shapes. Depending on their position, the weight of the rocks deforms the platform, and the shape of the platform controls which ropes move and ultimately the focus of the¬†dish.</blockquote>\n<blockquote>In short: if you move the rocks, you can focus the dish. The platform even has a control panel on the side that lets you tilt it in one of four directions! The rounded rocks (O) will roll when the platform is tilted, while the cube-shaped rocks (#) will stay in place. You note the positions of all of the empty spaces (.) and rocks (your puzzle input). For¬†example:</blockquote>\n<blockquote>O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....</blockquote>\n<blockquote>Start by tilting the lever so all of the rocks will slide north as far as they will¬†go:</blockquote>\n<blockquote>OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....</blockquote>\n<blockquote>You notice that the support beams along the north side of the platform are damaged; to ensure the platform doesn‚Äôt collapse, you should calculate the total load on the north support¬†beams.</blockquote>\n<blockquote>The amount of load caused by a single rounded rock (O) is equal to the number of rows from the rock to the south edge of the platform, including the row the rock is on. (Cube-shaped rocks (#) don't contribute to load.) So, the amount of load caused by each rock in each row is as¬†follows:</blockquote>\n<blockquote>OOOO.#.O.. 10<br>OO..#....# 9<br>OO..O##..O 8<br>O..#.OO... 7<br>........#. 6<br>..#....#.# 5<br>..O..#.O.O 4<br>..O....... 3<br>#....###.. 2<br>#....#.... 1</blockquote>\n<blockquote>The total load is the sum of the load caused by all of the rounded rocks. In this example, the total load is¬†136.</blockquote>\n<blockquote>Tilt the platform so that the rounded rocks all roll north. Afterward, what is the total load on the north support¬†beams?</blockquote>\n<p>Cool! Let‚Äôs review the problem in terms of <strong><em>chronology</em></strong> and we shall break down what needs to be done to get our¬†answer?</p>\n<p>We have <strong>2 types of¬†rocks</strong>:</p>\n<ul>\n<li># <strong>Cube shape rocks</strong>, that stay in¬†place</li>\n<li>O <strong>Rounded rocks</strong>, that¬†rolls!</li>\n</ul>\n<p>Given an initial state of platform represented by a 2D matrix, we need to ensure that the north side beam <strong>can handle the load</strong> if we start to tilt the platform, so we can need to <strong>calculate the state of platform</strong> when it is tilted towards North direction!</p>\n<p>Let‚Äôs see a quick¬†viz:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/733/1*34Iz-l6OzH6JvCKvO1pHvw.png\"></figure><p>We can observe how all O rocks have <strong>moved along their columns towards North</strong> while # have stayed¬†put.</p>\n<p>And then, base case allows us to calculate the load bearing capacity of the north support beam by sum(number of \"O‚Äù rocks * number of rows from the rock to the south edge of the platform), like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/852/1*z7xNWvYhuVnAf6N5fmV2xA.png\"></figure><p>So, we need to write code in 2¬†parts:</p>\n<ol>\n<li>To <strong>generate</strong> the north_tilted state</li>\n<li>To <strong>calculate</strong> the total load on north¬†beam</li>\n</ol>\n<p>But first, let‚Äôs write the base test case along with some skelton code to structure our thought¬†process:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/817/1*dTdlYQQC_kV6EXaKXAOr4g.png\"></figure><p>Perfect, now let‚Äôs implement our methods and do some debugging!</p>\n<p>Now for <em>tilting </em>our platform, we can just go through our platform and then for each instance of O we can try to move it upward in column till we get another O or # and then move on the next¬†one!</p>\n<p>Here, some code for that with an Tile(Enum) to keep code¬†tidy!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/913/1*fWqLKIbBKhFVktMvw-91yA.png\"></figure><p>Let‚Äôs debug and see if it is working correctly, and actually we can write a test case just to verify the tilt_platform function:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*U9TuX8mNBSaOOsBuB6blYg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚úÖ tilt_platform passed<br><br>[Done] exited with code=0 in 0.087 seconds</pre>\n<p>Let‚Äôs see a beautiful visualisation of platform tilting to north as we hÃ∂uÃ∂mÃ∂aÃ∂nÃ∂sÃ∂ coders can appreciate:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/904/1*gsgUbXWQEr5EphznMC5EZA.gif\"><figcaption>Beautiful! ü§©</figcaption></figure><p>Now, let‚Äôs implement our load calculation function, as it‚Äôs clear from our visualization above, all we need to do is to sum(number of \"O‚Äù rocks * number of rows from the rock to the south edge of the platform)</p>\n<p>Let‚Äôs write some code, seems pretty¬†simple:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/714/1*iLx15Och0NPYHbtj8_lScA.png\"></figure><p>And let‚Äôs run both of our test¬†cases?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚úÖ tilt_platform passed<br>‚úÖ calculate_load_on_north_beam passed<br><br>[Done] exited with code=0 in 0.056 seconds</pre>\n<p>Noice! Pretty quick as well. Let‚Äôs load up our puzzle input and run this¬†code?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/864/1*X3PIZqqBOkUklyqIjKRwhg.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚ùóÔ∏è Total load on the north beam is XXXXXX<br><br>[Done] exited with code=0 in 0.07 seconds</pre>\n<p>We get an answer, let‚Äôs input this in our answer box, I have a good feeling about this¬†one!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/837/1*dnPq69m0hHyjHP_HYBP5WA.png\"><figcaption>Ez! üï∂</figcaption></figure><p>Here‚Äôs our code till now, we will optimise it in next part, as preoptimization is¬†futile:</p>\n<pre># Day 14 - Parabolic Reflector Dish<br><br>from enum import Enum<br><br><br>class TiltDirection(Enum):<br>    North = 1<br>    South = 2<br>    East = 3<br>    West = 4<br><br><br>class Tile(Enum):<br>    Empty = \".\"<br>    CubeRock = \"#\"<br>    RoundRock = \"O\"<br><br><br>def tilt_platform(platform_state, direction=TiltDirection.North):<br>    # well, we only care about north for now<br>    if direction != TiltDirection.North:<br>        NotImplementedError(\"Only TiltDirection.North is supported for now\")<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    for i, row in enumerate(platform_state):<br>        for j, tile in enumerate(row):<br>            if tile == Tile.RoundRock.value:<br>                # move this rock upwards in column<br>                row_idx, col_idx = i, j<br>                while (<br>                    row_idx - 1 &gt;= 0<br>                    and platform_state[row_idx - 1][col_idx] == Tile.Empty.value<br>                ):<br>                    platform_state[row_idx][col_idx] = Tile.Empty.value<br>                    platform_state[row_idx - 1][col_idx] = Tile.RoundRock.value<br>                    row_idx -= 1<br><br>    return platform_state<br><br><br>def calculate_load_on_north_beam(tilted_platform_state):<br>    total_load = 0<br>    load_factor = len(tilted_platform_state)<br><br>    for row in tilted_platform_state:<br>        total_load += load_factor * row.count(Tile.RoundRock.value)<br>        load_factor -= 1<br><br>    return total_load<br><br><br>def part_one():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"‚ùóÔ∏è Total load on the north beam is {total_load}\")<br><br><br>def test_tilt_platform():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state = \"\"\"OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....\"\"\"<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    assert tilted_platform_state == [<br>        list(row) for row in expected_platform_state.split(\"\\n\")<br>    ], f\"Expected {expected_platform_state}, got {tilted_platform_state}\"<br>    print(\"‚úÖ tilt_platform passed\")<br><br><br>def test_calculate_load_on_north_beam():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 136, f\"Expected 136, got {total_load}\"<br>    print(\"‚úÖ calculate_load_on_north_beam passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_tilt_platform()<br>    test_calculate_load_on_north_beam()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>The parabolic reflector dish deforms, but not in a way that focuses the beam. To do that, you‚Äôll need to move the rocks to the edges of the platform. Fortunately, a button on the side of the control panel labeled ‚Äúspin cycle‚Äù attempts to do just¬†that!</blockquote>\n<blockquote>Each cycle tilts the platform four times so that the rounded rocks roll north, then west, then south, then east. After each tilt, the rounded rocks roll as far as they can before the platform tilts in the next direction. After one cycle, the platform will have finished rolling the rounded rocks in those four directions in that¬†order.</blockquote>\n<blockquote>Here‚Äôs what happens in the example above after each of the first few¬†cycles:</blockquote>\n<blockquote>After 1 cycle:<br>.....#....<br>....#...O#<br>...OO##...<br>.OO#......<br>.....OOO#.<br>.O#...O#.#<br>....O#....<br>......OOOO<br>#...O###..<br>#..OO#....</blockquote>\n<blockquote>After 2 cycles:<br>.....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#..OO###..<br>#.OOO#...O</blockquote>\n<blockquote>After 3 cycles:<br>.....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#...O###.O<br>#.OOO#...O</blockquote>\n<blockquote>This process should work if you leave it running long enough, but you‚Äôre still worried about the north support beams. To make sure they‚Äôll survive for a while, you need to calculate the total load on the north support beams after 1000000000 cycles.</blockquote>\n<blockquote>In the above example, after 1000000000 cycles, the total load on the north support beams is¬†64.</blockquote>\n<blockquote>Run the spin cycle for 1000000000 cycles. Afterward, what is the total load on the north support¬†beams?</blockquote>\n<p>Well, haven‚Äôt we got used to <strong><em>ever increasing exponential scale</em></strong> of Part Two!¬†üëÄ</p>\n<blockquote>Let‚Äôs dive¬†in‚Ä¶</blockquote>\n<p>Our foresight of using TiltDirection(Enum) was correct, we do need to tilt in other directions, but thankfully we still only care about north support¬†beams!</p>\n<p>So, seems like we can to do 1000000000<em>‚Ää‚Äî‚Ää</em>one billion cycles where each cycle¬†means:</p>\n<ul><li>tilts the platform four times so that the rounded rocks roll north, then west, then south, then¬†east.</li></ul>\n<p>Before thinking how we can optimise without doing 1000000000<em> </em>repeatitions, let‚Äôs just implement and test tilt_platform for other 3 directions:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/855/1*MZ2Rq0CVPdg4W7wUW6EUXQ.png\"><figcaption>I know, I know, a lot of dup code, we will fix this in final¬†code!</figcaption></figure><p>And we can modify our tilt_platform to basically use a switch case to call relevant method. Also, introducing tilt_platform_cycle where we can pass num_cycles where each cycle is defined¬†as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/821/1*fWJS_MwVZqSzcUk7LrUnhQ.png\"></figure><p>Let‚Äôs test our tilt code for the base case given in the part 2 of the¬†puzzle:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/945/1*RZdLZKigWqm_uU7xm6zLPQ.png\"></figure><p>Let‚Äôs run¬†this?</p>\n<p>And‚Ä¶.nope! It¬†failed!</p>\n<blockquote>üí° Edge case: Well, when we go to tilt_platform_south since it‚Äôs traversing from (0,0) -&gt; (i,j) (from top left to bottom right), it won‚Äôt be able to move a O rock if it has another O rock below it, but later in iteration, if we move the bottom most rock of the group, the rocks above it should also¬†follow!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OCBi2aYBL7f_-u0WPttdQA.png\"></figure><p>This will never be a problem when we do tilt_platform_north and tilt_platform_west since we are starting from top left aka (0,0) in our¬†loop.</p>\n<blockquote>üí≠ An easy way to fix this is to, for tilt_platform_south and tilt_platform_east, just iterate from bottom right (i,j) to top left (0,0) and it should automatically take care of the edge cases without having to make our code too complicated!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/340/1*x8Vcicu4SxwSbmynIgbV2w.png\"><figcaption>This shall ensure our group won‚Äôt be blocked by neighbours while tilting east or¬†south.</figcaption></figure><p>After a few debugging sessions! It works!¬†ü§ì</p>\n<p>Here‚Äôs a quick visuzliation of 1 cycle, with our platform_state</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/490/1*bwmLqr7lfRMuRQL75ORm6Q.gif\"><figcaption>roll north, then west, then south, then¬†east.</figcaption></figure><p>Let‚Äôs see if our test cases¬†work?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚úÖ tilt_platform_cycle with 1 cycle passed<br>‚úÖ tilt_platform_cycle with 2 cycles passed<br>‚úÖ tilt_platform_cycle with 3 cycles passed<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>How about checking our testcase‚Ää‚Äî‚Ää1 billion times and see if we get <strong>64 </strong>load as given in the¬†puzzle!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/875/1*c26l8wk3mlidRmkLDsKczQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚úÖ test_calculate_load_on_north_beam passed<br><br>[Done] exited with code=0 in 0.075 seconds</pre>\n<p><strong>0.075 seconds</strong> // Looking at this fast runtime, I am just tempted to run it for <strong>A billion cycles </strong>for the puzzle input as it is just <strong>100x100</strong> and our runtime is just¬†O(n¬≤)!</p>\n<p>Are you game? Yes? Let‚Äôs do¬†it!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/890/1*sQ0JUQVJAGh92wVpvW_yag.png\"><figcaption>ü§û</figcaption></figure><p>Well, 3 minutes later, doesn‚Äôt seem likely!¬†ü•≤</p>\n<p>I should have had put some std::out just to know which cycle our code is on currently! So, added some logging in parallel, just to gauge the¬†speed:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/811/1*FJ_U2UbP7PiDaX8Jhmf6xw.png\"></figure><p>Let‚Äôs see how many cycles we do for puzzle input in 10 seconds for¬†fun:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/811/1*FJ_U2UbP7PiDaX8Jhmf6xw.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/922/1*DYYGxjZrRaCwo6PurAc0fw.gif\"><figcaption>~300 cycles in 10¬†seconds</figcaption></figure><blockquote>So, it should just take us <strong>33,333,333.33</strong> seconds ~ <strong>555,555.56</strong> minutes ~ <strong>9,259.26</strong> hours ~ <strong>385.80</strong> days, which is just over 1 year!¬†ü§Ø</blockquote>\n<p>Yep! It‚Äôs difficult for human brain to estimate large numbers! Let‚Äôs optimise¬†now?!</p>\n<p>One of my early hypothesis is that we are spending so much time tilting our platform_state that we are bound to get repeated inputs for multiple directions! We can probably make it faster by just introducing a cache to track input and output for tilt_platform function!</p>\n<p>Let‚Äôs test that, using our same unscientific test above (it will be interesting to see how memory size grows as these are 4 computations per cycle, totalling to <strong>4 billion computations</strong>!):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*shey_5pM8zAz9jdVQeP5Yg.png\"><figcaption>Added cache!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wNLS1z6SOaAlXaFYAsUl2g.gif\"><figcaption>~300 / 10 seconds, no¬†avail!</figcaption></figure><p>Let‚Äôs rethink now! Brute force won‚Äôt work¬†clearly!</p>\n<p>I still firmly beleive there has to be some kind of a repeatition after a while and we just need to find the cycle¬†here!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/889/1*7vZuAx0YRT2j69W9IVPM5A.png\"></figure><p>Added some logging, let‚Äôs see our test¬†input:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/721/1*1tgBP55O98m1dM-VYS2vrQ.png\"></figure><p>Clearly we can see, there is <strong>some cycle going</strong> on¬†here!</p>\n<blockquote>üí°Now, all we need to do is, <strong>find the cycle length</strong> and <strong>find the cycle elements</strong>, and then by the <strong>magic of modulus</strong> % we can directly find the platform_state, as if what it will be after 1000000000 cycles!</blockquote>\n<p>.</p>\n<p>.</p>\n<blockquote>30 minutes and some debugging later!</blockquote>\n<p>.</p>\n<p>.</p>\n<p>Whipped up this <strong>spaghetti</strong> code (I promise, <strong>I will fix</strong>¬†this):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yfPl8wqtUZiv9icCAo884g.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚úÖ tilt_platform_cycle with 1 cycle passed<br>‚úÖ tilt_platform_cycle with 2 cycles passed<br>‚úÖ tilt_platform_cycle with 3 cycles passed<br>‚úÖ test_calculate_load_on_north_beam_1000000000_cycles passed<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>Finally! üôè</p>\n<p>Now, let‚Äôs run for our puzzle¬†input?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚ÄºÔ∏è Total load on the north beam after 1000000000 cycles is XXXXX<br><br>[Done] exited with code=0 in 4.166 seconds</pre>\n<p>We have an answer in <strong>4.166 seconds</strong>, let‚Äôs put this in the answer box¬†and‚Ä¶</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/957/1*ElrQjU_yhrwuoxyIGDQFWg.png\"><figcaption>Finally üôè</figcaption></figure><p>Here‚Äôs our pythonic and optimized code:</p>\n<pre># Day 14 - Parabolic Reflector Dish<br><br>from enum import Enum<br><br><br>class TiltDirection(Enum):<br>    North = \"NORTH\"<br>    South = \"SOUTH\"<br>    East = \"EAST\"<br>    West = \"WEST\"<br><br><br>class Tile(Enum):<br>    Empty = \".\"<br>    CubeRock = \"#\"<br>    RoundRock = \"O\"<br><br><br>def tilt_platform(platform_state, direction):<br>    rows, cols = len(platform_state), len(platform_state[0])<br>    delta = {<br>        TiltDirection.North: (0, -1),<br>        TiltDirection.South: (0, 1),<br>        TiltDirection.East: (1, 0),<br>        TiltDirection.West: (-1, 0)<br>    }[direction]<br><br>    def is_valid_position(row, col):<br>        return 0 &lt;= row &lt; rows and 0 &lt;= col &lt; cols<br><br>    def move_rock(start_row, start_col):<br>        row, col = start_row, start_col<br>        while is_valid_position(row + delta[1], col + delta[0]) and \\<br>                platform_state[row + delta[1]][col + delta[0]] == Tile.Empty.value:<br>            platform_state[row][col] = Tile.Empty.value<br>            row, col = row + delta[1], col + delta[0]<br>            platform_state[row][col] = Tile.RoundRock.value<br><br>    if direction in [TiltDirection.North, TiltDirection.West]:<br>        range_func = range<br>    else:<br>        range_func = lambda start, end: range(end - 1, start - 1, -1)<br><br>    for i in range_func(0, rows):<br>        for j in range_func(0, cols):<br>            if platform_state[i][j] == Tile.RoundRock.value:<br>                move_rock(i, j)<br><br>    return platform_state<br><br><br>def tilt_platform_cycle(platform_state, num_cycles=1):    <br>    platform_cache = {}  # Cache for storing seen platform states<br>    cycle_patterns = []  # List to store unique states forming a cycle<br>    cycle_start_point = None<br><br><br>    for idx in range(1, num_cycles+1):<br>        # Tilt platform in all directions<br>        for direction in [TiltDirection.North, TiltDirection.West, TiltDirection.South, TiltDirection.East]:<br>            platform_state = tilt_platform(platform_state, direction)<br><br>        # Generate a key for the current state<br>        platform_state_key = \"\\n\".join([\" \".join(map(str, row)) for row in platform_state])<br><br>        # Check if the current state has been seen before<br>        if platform_state_key in platform_cache:<br>            if cycle_start_point is None:<br>                cycle_start_point = platform_cache[platform_state_key]<br>                cycle_patterns.append(platform_state_key)<br>                continue<br><br>            # Start of the cycle found, calculate the index in the cycle pattern<br>            if platform_state_key == cycle_patterns[0]:<br>                cycle_length = len(cycle_patterns)<br>                cycle_index = (num_cycles - cycle_start_point) % cycle_length<br>                return [list(row) for row in cycle_patterns[cycle_index].split(\"\\n\")]<br><br>            # New state in the cycle<br>            if platform_state_key not in cycle_patterns:<br>                cycle_patterns.append(platform_state_key)<br>            continue<br><br>        # Store the new state in the cache<br>        platform_cache[platform_state_key] = idx<br>        if cycle_start_point is not None and platform_state_key not in cycle_patterns:<br>            cycle_patterns.append(platform_state_key)<br><br>    return platform_state<br><br><br>def calculate_load_on_north_beam(tilted_platform_state):<br>    return sum((len(tilted_platform_state) - i) * row.count(Tile.RoundRock.value)<br>               for i, row in enumerate(tilted_platform_state))<br><br><br>def part_one():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"‚ùóÔ∏è Total load on the north beam is {total_load}\")<br><br><br>def part_two():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1000000000)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"‚ÄºÔ∏è Total load on the north beam after 1000000000 cycles is {total_load}\")<br><br><br>def test_tilt_platform_cycle():<br>    platform_state_og = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state_with_1_cycle = \"\"\".....#....<br>....#...O#<br>...OO##...<br>.OO#......<br>.....OOO#.<br>.O#...O#.#<br>....O#....<br>......OOOO<br>#...O###..<br>#..OO#....\"\"\"<br><br>    expected_platform_state_with_2_cycles = \"\"\".....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#..OO###..<br>#.OOO#...O\"\"\"<br><br>    expected_platform_state_with_3_cycles = \"\"\".....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#...O###.O<br>#.OOO#...O\"\"\"<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_1_cycle = [<br>        list(row) for row in expected_platform_state_with_1_cycle.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_1_cycle<br>    ), f\"Expected {expected_platform_state_with_1_cycle}, got {tilted_platform_state}\"<br>    print(\"‚úÖ tilt_platform_cycle with 1 cycle passed\")<br><br>    # reseting platform_state<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_2_cycles = [<br>        list(row) for row in expected_platform_state_with_2_cycles.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 2)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_2_cycles<br>    ), f\"Expected {expected_platform_state_with_2_cycles}, got {tilted_platform_state}\"<br>    print(\"‚úÖ tilt_platform_cycle with 2 cycles passed\")<br><br>    # reseting platform_state<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_3_cycles = [<br>        list(row) for row in expected_platform_state_with_3_cycles.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 3)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_3_cycles<br>    ), f\"Expected {expected_platform_state_with_3_cycles}, got {tilted_platform_state}\"<br>    print(\"‚úÖ tilt_platform_cycle with 3 cycles passed\")<br><br><br>def test_tilt_platform():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state = \"\"\"OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    assert tilted_platform_state == [<br>        list(row) for row in expected_platform_state.split(\"\\n\")<br>    ], f\"Expected {expected_platform_state}, got {tilted_platform_state}\"<br>    print(\"‚úÖ tilt_platform passed\")<br><br><br>def test_calculate_load_on_north_beam():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 136, f\"Expected 136, got {total_load}\"<br>    print(\"‚úÖ test_calculate_load_on_north_beam passed\")<br><br><br>def test_calculate_load_on_north_beam_1000000000_cycles():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1000000000)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 64, f\"Expected 64, got {total_load}\"<br>    print(\"‚úÖ test_calculate_load_on_north_beam_1000000000_cycles passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_tilt_platform()<br>    test_calculate_load_on_north_beam()<br>    part_one()<br><br>    test_tilt_platform_cycle()<br>    test_calculate_load_on_north_beam_1000000000_cycles()<br>    part_two()</pre>\n<p>I am sure there is more juice left to squeeze as we can further optimize this, but I am tired now! I will most likely <strong>come back</strong> during holidays to optimise this to atleast <strong>sub-second compute¬†time</strong>.</p>\n<p>Stay tuned!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the¬†problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine¬†üëá</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! üéÑ</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=10760f12f5a5\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*zkAVIfrKih2TgfjK\"><figcaption>Parabolic Reflector Dish (via DALL-E¬†3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/14\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You reach the place where all of the mirrors were pointing: a massive <a href=\"https://en.wikipedia.org/wiki/Parabolic_reflector\">parabolic reflector dish</a> attached to the side of another large mountain.</blockquote>\n<blockquote>The dish is made up of many small mirrors, but while the mirrors themselves are roughly in the shape of a parabolic reflector dish, each individual mirror seems to be pointing in slightly the wrong direction. If the dish is meant to focus light, all it‚Äôs doing right now is sending it in a vague direction.</blockquote>\n<blockquote>This system must be what provides the energy for the lava! If you focus the reflector dish, maybe you can go where it‚Äôs pointing and use the light to fix the lava production.</blockquote>\n<blockquote>Upon closer inspection, the individual mirrors each appear to be connected via an elaborate system of ropes and pulleys to a large metal platform below the dish. The platform is covered in large rocks of various shapes. Depending on their position, the weight of the rocks deforms the platform, and the shape of the platform controls which ropes move and ultimately the focus of the¬†dish.</blockquote>\n<blockquote>In short: if you move the rocks, you can focus the dish. The platform even has a control panel on the side that lets you tilt it in one of four directions! The rounded rocks (O) will roll when the platform is tilted, while the cube-shaped rocks (#) will stay in place. You note the positions of all of the empty spaces (.) and rocks (your puzzle input). For¬†example:</blockquote>\n<blockquote>O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....</blockquote>\n<blockquote>Start by tilting the lever so all of the rocks will slide north as far as they will¬†go:</blockquote>\n<blockquote>OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....</blockquote>\n<blockquote>You notice that the support beams along the north side of the platform are damaged; to ensure the platform doesn‚Äôt collapse, you should calculate the total load on the north support¬†beams.</blockquote>\n<blockquote>The amount of load caused by a single rounded rock (O) is equal to the number of rows from the rock to the south edge of the platform, including the row the rock is on. (Cube-shaped rocks (#) don't contribute to load.) So, the amount of load caused by each rock in each row is as¬†follows:</blockquote>\n<blockquote>OOOO.#.O.. 10<br>OO..#....# 9<br>OO..O##..O 8<br>O..#.OO... 7<br>........#. 6<br>..#....#.# 5<br>..O..#.O.O 4<br>..O....... 3<br>#....###.. 2<br>#....#.... 1</blockquote>\n<blockquote>The total load is the sum of the load caused by all of the rounded rocks. In this example, the total load is¬†136.</blockquote>\n<blockquote>Tilt the platform so that the rounded rocks all roll north. Afterward, what is the total load on the north support¬†beams?</blockquote>\n<p>Cool! Let‚Äôs review the problem in terms of <strong><em>chronology</em></strong> and we shall break down what needs to be done to get our¬†answer?</p>\n<p>We have <strong>2 types of¬†rocks</strong>:</p>\n<ul>\n<li># <strong>Cube shape rocks</strong>, that stay in¬†place</li>\n<li>O <strong>Rounded rocks</strong>, that¬†rolls!</li>\n</ul>\n<p>Given an initial state of platform represented by a 2D matrix, we need to ensure that the north side beam <strong>can handle the load</strong> if we start to tilt the platform, so we can need to <strong>calculate the state of platform</strong> when it is tilted towards North direction!</p>\n<p>Let‚Äôs see a quick¬†viz:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/733/1*34Iz-l6OzH6JvCKvO1pHvw.png\"></figure><p>We can observe how all O rocks have <strong>moved along their columns towards North</strong> while # have stayed¬†put.</p>\n<p>And then, base case allows us to calculate the load bearing capacity of the north support beam by sum(number of \"O‚Äù rocks * number of rows from the rock to the south edge of the platform), like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/852/1*z7xNWvYhuVnAf6N5fmV2xA.png\"></figure><p>So, we need to write code in 2¬†parts:</p>\n<ol>\n<li>To <strong>generate</strong> the north_tilted state</li>\n<li>To <strong>calculate</strong> the total load on north¬†beam</li>\n</ol>\n<p>But first, let‚Äôs write the base test case along with some skelton code to structure our thought¬†process:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/817/1*dTdlYQQC_kV6EXaKXAOr4g.png\"></figure><p>Perfect, now let‚Äôs implement our methods and do some debugging!</p>\n<p>Now for <em>tilting </em>our platform, we can just go through our platform and then for each instance of O we can try to move it upward in column till we get another O or # and then move on the next¬†one!</p>\n<p>Here, some code for that with an Tile(Enum) to keep code¬†tidy!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/913/1*fWqLKIbBKhFVktMvw-91yA.png\"></figure><p>Let‚Äôs debug and see if it is working correctly, and actually we can write a test case just to verify the tilt_platform function:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*U9TuX8mNBSaOOsBuB6blYg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚úÖ tilt_platform passed<br><br>[Done] exited with code=0 in 0.087 seconds</pre>\n<p>Let‚Äôs see a beautiful visualisation of platform tilting to north as we hÃ∂uÃ∂mÃ∂aÃ∂nÃ∂sÃ∂ coders can appreciate:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/904/1*gsgUbXWQEr5EphznMC5EZA.gif\"><figcaption>Beautiful! ü§©</figcaption></figure><p>Now, let‚Äôs implement our load calculation function, as it‚Äôs clear from our visualization above, all we need to do is to sum(number of \"O‚Äù rocks * number of rows from the rock to the south edge of the platform)</p>\n<p>Let‚Äôs write some code, seems pretty¬†simple:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/714/1*iLx15Och0NPYHbtj8_lScA.png\"></figure><p>And let‚Äôs run both of our test¬†cases?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚úÖ tilt_platform passed<br>‚úÖ calculate_load_on_north_beam passed<br><br>[Done] exited with code=0 in 0.056 seconds</pre>\n<p>Noice! Pretty quick as well. Let‚Äôs load up our puzzle input and run this¬†code?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/864/1*X3PIZqqBOkUklyqIjKRwhg.png\"></figure><pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚ùóÔ∏è Total load on the north beam is XXXXXX<br><br>[Done] exited with code=0 in 0.07 seconds</pre>\n<p>We get an answer, let‚Äôs input this in our answer box, I have a good feeling about this¬†one!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/837/1*dnPq69m0hHyjHP_HYBP5WA.png\"><figcaption>Ez! üï∂</figcaption></figure><p>Here‚Äôs our code till now, we will optimise it in next part, as preoptimization is¬†futile:</p>\n<pre># Day 14 - Parabolic Reflector Dish<br><br>from enum import Enum<br><br><br>class TiltDirection(Enum):<br>    North = 1<br>    South = 2<br>    East = 3<br>    West = 4<br><br><br>class Tile(Enum):<br>    Empty = \".\"<br>    CubeRock = \"#\"<br>    RoundRock = \"O\"<br><br><br>def tilt_platform(platform_state, direction=TiltDirection.North):<br>    # well, we only care about north for now<br>    if direction != TiltDirection.North:<br>        NotImplementedError(\"Only TiltDirection.North is supported for now\")<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    for i, row in enumerate(platform_state):<br>        for j, tile in enumerate(row):<br>            if tile == Tile.RoundRock.value:<br>                # move this rock upwards in column<br>                row_idx, col_idx = i, j<br>                while (<br>                    row_idx - 1 &gt;= 0<br>                    and platform_state[row_idx - 1][col_idx] == Tile.Empty.value<br>                ):<br>                    platform_state[row_idx][col_idx] = Tile.Empty.value<br>                    platform_state[row_idx - 1][col_idx] = Tile.RoundRock.value<br>                    row_idx -= 1<br><br>    return platform_state<br><br><br>def calculate_load_on_north_beam(tilted_platform_state):<br>    total_load = 0<br>    load_factor = len(tilted_platform_state)<br><br>    for row in tilted_platform_state:<br>        total_load += load_factor * row.count(Tile.RoundRock.value)<br>        load_factor -= 1<br><br>    return total_load<br><br><br>def part_one():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"‚ùóÔ∏è Total load on the north beam is {total_load}\")<br><br><br>def test_tilt_platform():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state = \"\"\"OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....\"\"\"<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    assert tilted_platform_state == [<br>        list(row) for row in expected_platform_state.split(\"\\n\")<br>    ], f\"Expected {expected_platform_state}, got {tilted_platform_state}\"<br>    print(\"‚úÖ tilt_platform passed\")<br><br><br>def test_calculate_load_on_north_beam():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 136, f\"Expected 136, got {total_load}\"<br>    print(\"‚úÖ calculate_load_on_north_beam passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_tilt_platform()<br>    test_calculate_load_on_north_beam()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>The parabolic reflector dish deforms, but not in a way that focuses the beam. To do that, you‚Äôll need to move the rocks to the edges of the platform. Fortunately, a button on the side of the control panel labeled ‚Äúspin cycle‚Äù attempts to do just¬†that!</blockquote>\n<blockquote>Each cycle tilts the platform four times so that the rounded rocks roll north, then west, then south, then east. After each tilt, the rounded rocks roll as far as they can before the platform tilts in the next direction. After one cycle, the platform will have finished rolling the rounded rocks in those four directions in that¬†order.</blockquote>\n<blockquote>Here‚Äôs what happens in the example above after each of the first few¬†cycles:</blockquote>\n<blockquote>After 1 cycle:<br>.....#....<br>....#...O#<br>...OO##...<br>.OO#......<br>.....OOO#.<br>.O#...O#.#<br>....O#....<br>......OOOO<br>#...O###..<br>#..OO#....</blockquote>\n<blockquote>After 2 cycles:<br>.....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#..OO###..<br>#.OOO#...O</blockquote>\n<blockquote>After 3 cycles:<br>.....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#...O###.O<br>#.OOO#...O</blockquote>\n<blockquote>This process should work if you leave it running long enough, but you‚Äôre still worried about the north support beams. To make sure they‚Äôll survive for a while, you need to calculate the total load on the north support beams after 1000000000 cycles.</blockquote>\n<blockquote>In the above example, after 1000000000 cycles, the total load on the north support beams is¬†64.</blockquote>\n<blockquote>Run the spin cycle for 1000000000 cycles. Afterward, what is the total load on the north support¬†beams?</blockquote>\n<p>Well, haven‚Äôt we got used to <strong><em>ever increasing exponential scale</em></strong> of Part Two!¬†üëÄ</p>\n<blockquote>Let‚Äôs dive¬†in‚Ä¶</blockquote>\n<p>Our foresight of using TiltDirection(Enum) was correct, we do need to tilt in other directions, but thankfully we still only care about north support¬†beams!</p>\n<p>So, seems like we can to do 1000000000<em>‚Ää‚Äî‚Ää</em>one billion cycles where each cycle¬†means:</p>\n<ul><li>tilts the platform four times so that the rounded rocks roll north, then west, then south, then¬†east.</li></ul>\n<p>Before thinking how we can optimise without doing 1000000000<em> </em>repeatitions, let‚Äôs just implement and test tilt_platform for other 3 directions:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/855/1*MZ2Rq0CVPdg4W7wUW6EUXQ.png\"><figcaption>I know, I know, a lot of dup code, we will fix this in final¬†code!</figcaption></figure><p>And we can modify our tilt_platform to basically use a switch case to call relevant method. Also, introducing tilt_platform_cycle where we can pass num_cycles where each cycle is defined¬†as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/821/1*fWJS_MwVZqSzcUk7LrUnhQ.png\"></figure><p>Let‚Äôs test our tilt code for the base case given in the part 2 of the¬†puzzle:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/945/1*RZdLZKigWqm_uU7xm6zLPQ.png\"></figure><p>Let‚Äôs run¬†this?</p>\n<p>And‚Ä¶.nope! It¬†failed!</p>\n<blockquote>üí° Edge case: Well, when we go to tilt_platform_south since it‚Äôs traversing from (0,0) -&gt; (i,j) (from top left to bottom right), it won‚Äôt be able to move a O rock if it has another O rock below it, but later in iteration, if we move the bottom most rock of the group, the rocks above it should also¬†follow!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OCBi2aYBL7f_-u0WPttdQA.png\"></figure><p>This will never be a problem when we do tilt_platform_north and tilt_platform_west since we are starting from top left aka (0,0) in our¬†loop.</p>\n<blockquote>üí≠ An easy way to fix this is to, for tilt_platform_south and tilt_platform_east, just iterate from bottom right (i,j) to top left (0,0) and it should automatically take care of the edge cases without having to make our code too complicated!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/340/1*x8Vcicu4SxwSbmynIgbV2w.png\"><figcaption>This shall ensure our group won‚Äôt be blocked by neighbours while tilting east or¬†south.</figcaption></figure><p>After a few debugging sessions! It works!¬†ü§ì</p>\n<p>Here‚Äôs a quick visuzliation of 1 cycle, with our platform_state</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/490/1*bwmLqr7lfRMuRQL75ORm6Q.gif\"><figcaption>roll north, then west, then south, then¬†east.</figcaption></figure><p>Let‚Äôs see if our test cases¬†work?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚úÖ tilt_platform_cycle with 1 cycle passed<br>‚úÖ tilt_platform_cycle with 2 cycles passed<br>‚úÖ tilt_platform_cycle with 3 cycles passed<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>How about checking our testcase‚Ää‚Äî‚Ää1 billion times and see if we get <strong>64 </strong>load as given in the¬†puzzle!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/875/1*c26l8wk3mlidRmkLDsKczQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚úÖ test_calculate_load_on_north_beam passed<br><br>[Done] exited with code=0 in 0.075 seconds</pre>\n<p><strong>0.075 seconds</strong> // Looking at this fast runtime, I am just tempted to run it for <strong>A billion cycles </strong>for the puzzle input as it is just <strong>100x100</strong> and our runtime is just¬†O(n¬≤)!</p>\n<p>Are you game? Yes? Let‚Äôs do¬†it!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/890/1*sQ0JUQVJAGh92wVpvW_yag.png\"><figcaption>ü§û</figcaption></figure><p>Well, 3 minutes later, doesn‚Äôt seem likely!¬†ü•≤</p>\n<p>I should have had put some std::out just to know which cycle our code is on currently! So, added some logging in parallel, just to gauge the¬†speed:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/811/1*FJ_U2UbP7PiDaX8Jhmf6xw.png\"></figure><p>Let‚Äôs see how many cycles we do for puzzle input in 10 seconds for¬†fun:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/811/1*FJ_U2UbP7PiDaX8Jhmf6xw.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/922/1*DYYGxjZrRaCwo6PurAc0fw.gif\"><figcaption>~300 cycles in 10¬†seconds</figcaption></figure><blockquote>So, it should just take us <strong>33,333,333.33</strong> seconds ~ <strong>555,555.56</strong> minutes ~ <strong>9,259.26</strong> hours ~ <strong>385.80</strong> days, which is just over 1 year!¬†ü§Ø</blockquote>\n<p>Yep! It‚Äôs difficult for human brain to estimate large numbers! Let‚Äôs optimise¬†now?!</p>\n<p>One of my early hypothesis is that we are spending so much time tilting our platform_state that we are bound to get repeated inputs for multiple directions! We can probably make it faster by just introducing a cache to track input and output for tilt_platform function!</p>\n<p>Let‚Äôs test that, using our same unscientific test above (it will be interesting to see how memory size grows as these are 4 computations per cycle, totalling to <strong>4 billion computations</strong>!):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*shey_5pM8zAz9jdVQeP5Yg.png\"><figcaption>Added cache!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wNLS1z6SOaAlXaFYAsUl2g.gif\"><figcaption>~300 / 10 seconds, no¬†avail!</figcaption></figure><p>Let‚Äôs rethink now! Brute force won‚Äôt work¬†clearly!</p>\n<p>I still firmly beleive there has to be some kind of a repeatition after a while and we just need to find the cycle¬†here!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/889/1*7vZuAx0YRT2j69W9IVPM5A.png\"></figure><p>Added some logging, let‚Äôs see our test¬†input:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/721/1*1tgBP55O98m1dM-VYS2vrQ.png\"></figure><p>Clearly we can see, there is <strong>some cycle going</strong> on¬†here!</p>\n<blockquote>üí°Now, all we need to do is, <strong>find the cycle length</strong> and <strong>find the cycle elements</strong>, and then by the <strong>magic of modulus</strong> % we can directly find the platform_state, as if what it will be after 1000000000 cycles!</blockquote>\n<p>.</p>\n<p>.</p>\n<blockquote>30 minutes and some debugging later!</blockquote>\n<p>.</p>\n<p>.</p>\n<p>Whipped up this <strong>spaghetti</strong> code (I promise, <strong>I will fix</strong>¬†this):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yfPl8wqtUZiv9icCAo884g.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚úÖ tilt_platform_cycle with 1 cycle passed<br>‚úÖ tilt_platform_cycle with 2 cycles passed<br>‚úÖ tilt_platform_cycle with 3 cycles passed<br>‚úÖ test_calculate_load_on_north_beam_1000000000_cycles passed<br><br>[Done] exited with code=0 in 0.073 seconds</pre>\n<p>Finally! üôè</p>\n<p>Now, let‚Äôs run for our puzzle¬†input?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_14/parabolic_reflector_dish.py\"<br>‚ÄºÔ∏è Total load on the north beam after 1000000000 cycles is XXXXX<br><br>[Done] exited with code=0 in 4.166 seconds</pre>\n<p>We have an answer in <strong>4.166 seconds</strong>, let‚Äôs put this in the answer box¬†and‚Ä¶</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/957/1*ElrQjU_yhrwuoxyIGDQFWg.png\"><figcaption>Finally üôè</figcaption></figure><p>Here‚Äôs our pythonic and optimized code:</p>\n<pre># Day 14 - Parabolic Reflector Dish<br><br>from enum import Enum<br><br><br>class TiltDirection(Enum):<br>    North = \"NORTH\"<br>    South = \"SOUTH\"<br>    East = \"EAST\"<br>    West = \"WEST\"<br><br><br>class Tile(Enum):<br>    Empty = \".\"<br>    CubeRock = \"#\"<br>    RoundRock = \"O\"<br><br><br>def tilt_platform(platform_state, direction):<br>    rows, cols = len(platform_state), len(platform_state[0])<br>    delta = {<br>        TiltDirection.North: (0, -1),<br>        TiltDirection.South: (0, 1),<br>        TiltDirection.East: (1, 0),<br>        TiltDirection.West: (-1, 0)<br>    }[direction]<br><br>    def is_valid_position(row, col):<br>        return 0 &lt;= row &lt; rows and 0 &lt;= col &lt; cols<br><br>    def move_rock(start_row, start_col):<br>        row, col = start_row, start_col<br>        while is_valid_position(row + delta[1], col + delta[0]) and \\<br>                platform_state[row + delta[1]][col + delta[0]] == Tile.Empty.value:<br>            platform_state[row][col] = Tile.Empty.value<br>            row, col = row + delta[1], col + delta[0]<br>            platform_state[row][col] = Tile.RoundRock.value<br><br>    if direction in [TiltDirection.North, TiltDirection.West]:<br>        range_func = range<br>    else:<br>        range_func = lambda start, end: range(end - 1, start - 1, -1)<br><br>    for i in range_func(0, rows):<br>        for j in range_func(0, cols):<br>            if platform_state[i][j] == Tile.RoundRock.value:<br>                move_rock(i, j)<br><br>    return platform_state<br><br><br>def tilt_platform_cycle(platform_state, num_cycles=1):    <br>    platform_cache = {}  # Cache for storing seen platform states<br>    cycle_patterns = []  # List to store unique states forming a cycle<br>    cycle_start_point = None<br><br><br>    for idx in range(1, num_cycles+1):<br>        # Tilt platform in all directions<br>        for direction in [TiltDirection.North, TiltDirection.West, TiltDirection.South, TiltDirection.East]:<br>            platform_state = tilt_platform(platform_state, direction)<br><br>        # Generate a key for the current state<br>        platform_state_key = \"\\n\".join([\" \".join(map(str, row)) for row in platform_state])<br><br>        # Check if the current state has been seen before<br>        if platform_state_key in platform_cache:<br>            if cycle_start_point is None:<br>                cycle_start_point = platform_cache[platform_state_key]<br>                cycle_patterns.append(platform_state_key)<br>                continue<br><br>            # Start of the cycle found, calculate the index in the cycle pattern<br>            if platform_state_key == cycle_patterns[0]:<br>                cycle_length = len(cycle_patterns)<br>                cycle_index = (num_cycles - cycle_start_point) % cycle_length<br>                return [list(row) for row in cycle_patterns[cycle_index].split(\"\\n\")]<br><br>            # New state in the cycle<br>            if platform_state_key not in cycle_patterns:<br>                cycle_patterns.append(platform_state_key)<br>            continue<br><br>        # Store the new state in the cache<br>        platform_cache[platform_state_key] = idx<br>        if cycle_start_point is not None and platform_state_key not in cycle_patterns:<br>            cycle_patterns.append(platform_state_key)<br><br>    return platform_state<br><br><br>def calculate_load_on_north_beam(tilted_platform_state):<br>    return sum((len(tilted_platform_state) - i) * row.count(Tile.RoundRock.value)<br>               for i, row in enumerate(tilted_platform_state))<br><br><br>def part_one():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"‚ùóÔ∏è Total load on the north beam is {total_load}\")<br><br><br>def part_two():<br>    with open(\"day_14/input.txt\") as f:<br>        platform_state = f.read()<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br><br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1000000000)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    print(f\"‚ÄºÔ∏è Total load on the north beam after 1000000000 cycles is {total_load}\")<br><br><br>def test_tilt_platform_cycle():<br>    platform_state_og = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state_with_1_cycle = \"\"\".....#....<br>....#...O#<br>...OO##...<br>.OO#......<br>.....OOO#.<br>.O#...O#.#<br>....O#....<br>......OOOO<br>#...O###..<br>#..OO#....\"\"\"<br><br>    expected_platform_state_with_2_cycles = \"\"\".....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#..OO###..<br>#.OOO#...O\"\"\"<br><br>    expected_platform_state_with_3_cycles = \"\"\".....#....<br>....#...O#<br>.....##...<br>..O#......<br>.....OOO#.<br>.O#...O#.#<br>....O#...O<br>.......OOO<br>#...O###.O<br>#.OOO#...O\"\"\"<br><br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_1_cycle = [<br>        list(row) for row in expected_platform_state_with_1_cycle.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_1_cycle<br>    ), f\"Expected {expected_platform_state_with_1_cycle}, got {tilted_platform_state}\"<br>    print(\"‚úÖ tilt_platform_cycle with 1 cycle passed\")<br><br>    # reseting platform_state<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_2_cycles = [<br>        list(row) for row in expected_platform_state_with_2_cycles.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 2)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_2_cycles<br>    ), f\"Expected {expected_platform_state_with_2_cycles}, got {tilted_platform_state}\"<br>    print(\"‚úÖ tilt_platform_cycle with 2 cycles passed\")<br><br>    # reseting platform_state<br>    platform_state = [list(row) for row in platform_state_og.split(\"\\n\")]<br>    expected_platform_state_with_3_cycles = [<br>        list(row) for row in expected_platform_state_with_3_cycles.split(\"\\n\")<br>    ]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 3)<br>    assert (<br>        tilted_platform_state == expected_platform_state_with_3_cycles<br>    ), f\"Expected {expected_platform_state_with_3_cycles}, got {tilted_platform_state}\"<br>    print(\"‚úÖ tilt_platform_cycle with 3 cycles passed\")<br><br><br>def test_tilt_platform():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br><br>    expected_platform_state = \"\"\"OOOO.#.O..<br>OO..#....#<br>OO..O##..O<br>O..#.OO...<br>........#.<br>..#....#.#<br>..O..#.O.O<br>..O.......<br>#....###..<br>#....#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    assert tilted_platform_state == [<br>        list(row) for row in expected_platform_state.split(\"\\n\")<br>    ], f\"Expected {expected_platform_state}, got {tilted_platform_state}\"<br>    print(\"‚úÖ tilt_platform passed\")<br><br><br>def test_calculate_load_on_north_beam():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform(platform_state, TiltDirection.North)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 136, f\"Expected 136, got {total_load}\"<br>    print(\"‚úÖ test_calculate_load_on_north_beam passed\")<br><br><br>def test_calculate_load_on_north_beam_1000000000_cycles():<br>    platform_state = \"\"\"O....#....<br>O.OO#....#<br>.....##...<br>OO.#O....O<br>.O.....O#.<br>O.#..O.#.#<br>..O..#O..O<br>.......O..<br>#....###..<br>#OO..#....\"\"\"<br>    # split the platform state into rows<br>    platform_state = [list(row) for row in platform_state.split(\"\\n\")]<br>    tilted_platform_state = tilt_platform_cycle(platform_state, 1000000000)<br>    total_load = calculate_load_on_north_beam(tilted_platform_state)<br>    assert total_load == 64, f\"Expected 64, got {total_load}\"<br>    print(\"‚úÖ test_calculate_load_on_north_beam_1000000000_cycles passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_tilt_platform()<br>    test_calculate_load_on_north_beam()<br>    part_one()<br><br>    test_tilt_platform_cycle()<br>    test_calculate_load_on_north_beam_1000000000_cycles()<br>    part_two()</pre>\n<p>I am sure there is more juice left to squeeze as we can further optimize this, but I am tired now! I will most likely <strong>come back</strong> during holidays to optimise this to atleast <strong>sub-second compute¬†time</strong>.</p>\n<p>Stay tuned!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the¬†problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine¬†üëá</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! üéÑ</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=10760f12f5a5\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "python",
        "christmas",
        "advent-of-code",
        "problem-solving",
        "advent-of-code-2023"
      ]
    },
    {
      "title": "[Day 13] Point of Incidence // Advent of Code 2023 (Python)",
      "pubDate": "2023-12-20 19:03:57",
      "link": "https://medium.com/@jatinkrmalik/day-13-point-of-incidence-advent-of-code-2023-python-4fea00eb98fb?source=rss-ec576e4b06b0------2",
      "guid": "https://medium.com/p/4fea00eb98fb",
      "author": "Jatin K Malik",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*rfUmh-2ouPC2eg70\"><figcaption>Point of Incidence</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/13\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>With your help, the hot springs team locates an appropriate spring which launches you neatly and precisely up to the edge of Lava¬†Island.</blockquote>\n<blockquote>There‚Äôs just one problem: you don‚Äôt see any¬†lava.</blockquote>\n<blockquote>You do see a lot of ash and igneous rock; there are even what look like gray mountains scattered around. After a while, you make your way to a nearby cluster of mountains only to discover that the valley between them is completely full of large mirrors. Most of the mirrors seem to be aligned in a consistent way; perhaps you should head in that direction?</blockquote>\n<blockquote>As you move through the valley of mirrors, you find that several of them have fallen from the large metal frames keeping them in place. The mirrors are extremely flat and shiny, and many of the fallen mirrors have lodged into the ash at strange angles. Because the terrain is all one color, it‚Äôs hard to tell where it‚Äôs safe to walk or where you‚Äôre about to run into a¬†mirror.</blockquote>\n<blockquote>You note down the patterns of ash (.) and rocks (#) that you see as you walk (your puzzle input); perhaps by carefully analyzing these patterns, you can figure out where the mirrors¬†are!</blockquote>\n<blockquote>For example:</blockquote>\n<blockquote>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</blockquote>\n<blockquote>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</blockquote>\n<blockquote>To find the reflection in each pattern, you need to find a perfect reflection across either a horizontal line between two rows or across a vertical line between two¬†columns.</blockquote>\n<blockquote>In the first pattern, the reflection is across a vertical line between two columns; arrows on each of the two columns point at the line between the¬†columns:</blockquote>\n<blockquote>123456789<br> &gt;&lt; <br>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br> &gt;&lt; <br>123456789</blockquote>\n<blockquote>In this pattern, the line of reflection is the vertical line between columns 5 and 6. Because the vertical line is not perfectly in the middle of the pattern, part of the pattern (column 1) has nowhere to reflect onto and can be ignored; every other column has a reflected column within the pattern and must match exactly: column 2 matches column 9, column 3 matches 8, 4 matches 7, and 5 matches¬†6.</blockquote>\n<blockquote>The second pattern reflects across a horizontal line¬†instead:</blockquote>\n<blockquote>1 #...##..# 1<br>2 #....#..# 2<br>3¬†..##..### 3<br>4v#####.##.v4<br>5^#####.##.^5<br>6¬†..##..### 6<br>7 #....#..# 7</blockquote>\n<blockquote>This pattern reflects across the horizontal line between rows 4 and 5. Row 1 would reflect with a hypothetical row 8, but since that‚Äôs not in the pattern, row 1 doesn‚Äôt need to match anything. The remaining rows match: row 2 matches row 7, row 3 matches row 6, and row 4 matches row¬†5.</blockquote>\n<blockquote>To summarize your pattern notes, add up the number of columns to the left of each vertical line of reflection; to that, also add 100 multiplied by the number of rows above each horizontal line of reflection. In the above example, the first pattern‚Äôs vertical line has 5 columns to its left and the second pattern's horizontal line has 4 rows above it, a total of¬†405.</blockquote>\n<blockquote>Find the line of reflection in each of the patterns in your notes. What number do you get after summarizing all of your¬†notes?</blockquote>\n<blockquote>A mirror maze?! I have always loved them since childhood!</blockquote>\n<p>Let‚Äôs understand the problem! We are given a pattern of ash (.) and rocks (#) and we need to figure out a line of mirrors which can be either be in between rows or columns casting a perfect reflection in our¬†pattern!</p>\n<p>Let‚Äôs study the example with a visualization, for the given¬†input:</p>\n<pre>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</pre>\n<p>We can observe that the line of reflection is in b/w 5th and 6th column and our 1st column can be¬†ignored!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/858/1*w9RqnyQzNe7fby2oGhrycw.png\"><figcaption>Pattern 1</figcaption></figure><p>Similarly, for another¬†example:</p>\n<pre>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</pre>\n<p>We can see that line of reflection is in b/w 4th and 5th row and our 1st row can be¬†ignored!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/523/1*OpsohpC1DbR87xeu16gqMw.png\"><figcaption>Pattern 2</figcaption></figure><p>Now, the puzzle wants us to summarize these patterns and add¬†up:</p>\n<ul>\n<li>the <strong>number of columns</strong> to the <strong>left of each vertical line of reflection</strong>\n</li>\n<li>add <strong>100 multiplied</strong> by the number of <strong>rows</strong> <strong>above each horizontal line of reflection</strong>\n</li>\n</ul>\n<p>So, for the given example, the answer¬†becomes:</p>\n<blockquote>5 (pattern 1) + 4 (pattern 2) * 100 =¬†405</blockquote>\n<p>This is pretty interesting! My mind is trying to wander toward the Palindrome approach, especially for even numbers, but let me first write some test code for the base case given¬†above!</p>\n<blockquote>üí° A quick analysis of puzzle input shows that we will have multiple patterns to process, so we will structure our code accordingly!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/543/1*e2OU1KdkRb9On0B06VUUQQ.png\"></figure><p>Let‚Äôs write code now, as mentioned, my initial idea is to just follow the naive palindrome approach, where I will try to compare ch[i] == ch[i-1] and will do a fan out approach to go both ways till we run out of¬†bounds:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/583/1*OV0bZhDBM5J44Ujz5284JA.png\"></figure><p>Now we can adapt the same approach to go <strong>row by row</strong>, and then if not found, we go <strong>column by column </strong>and then return the point as per the calculation for horizontal line v/s vertical line as per the¬†puzzle.</p>\n<p>.</p>\n<p>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*kwZ5gQR1bAGMWsA00gb9ow.png\"></figure><p>Few debugging sessions¬†later!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>‚úÖ summarize_pattern passed<br><br>[Done] exited with code=0 in 0.065 seconds</pre>\n<p>This is a bit bruteforce approach, but seems pretty fast for 2 patterns, 0.065 seconds, let‚Äôs load up our puzzle input and see how it runs as we seem to only have 100 patterns!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iAnwZ7o1zY1wgny3evWzyQ.png\"><figcaption>I am sure there will be a nutty edge case somewhere in¬†here!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/682/1*tysBMJDX-Q6_Mfq1wSeY4Q.png\"><figcaption>Let‚Äôs run this!¬†ü§û</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>‚ùóÔ∏è Summarizing all patterns in Part 1: XXXXXX<br><br>[Done] exited with code=0 in 0.051 seconds</pre>\n<p>Woah! We have an answer in just <strong>0.051</strong> seconds!¬†ü§Ø</p>\n<p>Let‚Äôs input this in the answer box¬†and‚Ä¶.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/879/1*H4vBV50RauNGTNK_qEO3aA.png\"><figcaption>üëØ‚Äç‚ôÄÔ∏èüëØ‚Äç‚ôÄÔ∏èüëØ‚Äç‚ôÄÔ∏è</figcaption></figure><p>Correct in first try and with an amazing runtime! Though I am sure as soon as I click on Part Two, it‚Äôs going to wreck our code!¬†ü§ì</p>\n<p>Here‚Äôs our raw code till now, we will optimise it in Part 2, like¬†always:</p>\n<pre># Day 13 - Point of Incidence<br><br>from enum import Enum<br><br>class Mode(Enum):<br>    ROW = \"row\"<br>    COLUMN = \"column\"<br><br>def is_perfect_reflection(prev, next, pattern, mode):<br>    if mode == Mode.ROW:<br>        while prev &gt;= 0 and next &lt; len(pattern):<br>            if pattern[prev] != pattern[next]:<br>                return False<br>            prev -= 1<br>            next += 1<br><br>        return True<br><br>    elif mode == Mode.COLUMN:<br>        while prev &gt;= 0 and next &lt; len(pattern[0]):<br>            for i in range(len(pattern)):<br>                if pattern[i][prev] != pattern[i][next]:<br>                    return False<br>            prev -= 1<br>            next += 1<br><br>        return True<br><br>    raise Exception(\"Invalid mode\")<br><br>def find_point_of_reflection(pattern, mode):<br>    if mode == Mode.ROW:<br>        for i in range(1, len(pattern)):<br>            if pattern[i-1] == pattern[i]:<br>                if is_perfect_reflection(i-1, i, pattern, Mode.ROW):<br>                    return i<br><br>    if mode == Mode.COLUMN:<br>        for j in range(1, len(pattern[0])):<br>            prev_col, next_col = [], []<br>            for i in range(0, len(pattern)):<br>                prev_col.append(pattern[i][j-1])<br>                next_col.append(pattern[i][j])<br>            if prev_col == next_col:<br>                if is_perfect_reflection(j-1, j, pattern, Mode.COLUMN):<br>                    return j<br><br>def analyze_pattern(pattern):<br>    pattern_grid = [list(row) for row in pattern.strip().split(\"\\n\")]<br><br>    # Find the point of reflection row by row<br>    point = find_point_of_reflection(pattern_grid, Mode.ROW)<br>    if point:<br>        return point * 100<br><br>    # Find the point of reflection column by column<br>    point = find_point_of_reflection(pattern_grid, Mode.COLUMN)<br>    if point:<br>        return point<br><br>    raise Exception(\"No point of reflection found\")<br><br>def summarize_patterns(patterns):<br>    sum = 0<br>    for pattern in patterns.split(\"\\n\\n\"):<br>        sum += analyze_pattern(pattern)<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns)<br><br>    print(f\"‚ùóÔ∏è Summarizing all patterns in Part 1: {sum}\")<br><br>def test_summarize_patterns():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br>    sum = summarize_patterns(patterns)<br>    assert sum == 405, f\"Expected 405, got {sum}\"<br>    print(\"‚úÖ summarize_pattern passed\")<br><br>if __name__ == \"__main__\":<br>    test_summarize_patterns()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>You resume walking through the valley of mirrors and‚Ää‚Äî‚ÄäSMACK!‚Ää‚Äî‚Äärun directly into one. Hopefully nobody was watching, because that must have been pretty embarrassing.</blockquote>\n<blockquote>Upon closer inspection, you discover that every mirror has exactly one smudge: exactly one¬†. or # should be the opposite¬†type.</blockquote>\n<blockquote>In each pattern, you‚Äôll need to locate and fix the smudge that causes a different reflection line to be valid. (The old reflection line won‚Äôt necessarily continue being valid after the smudge is¬†fixed.)</blockquote>\n<blockquote>Here‚Äôs the above example¬†again:</blockquote>\n<blockquote>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</blockquote>\n<blockquote>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</blockquote>\n<blockquote>The first pattern‚Äôs smudge is in the top-left corner. If the top-left #were instead¬†., it would have a different, horizontal line of reflection:</blockquote>\n<blockquote>1¬†..##..##. 1<br>2¬†..#.##.#. 2<br>3v##......#v3<br>4^##......#^4<br>5¬†..#.##.#. 5<br>6¬†..##..##. 6<br>7 #.#.##.#. 7</blockquote>\n<blockquote>With the smudge in the top-left corner repaired, a new horizontal line of reflection between rows 3 and 4 now exists. Row 7 has no corresponding reflected row and can be ignored, but every other row matches exactly: row 1 matches row 6, row 2 matches row 5, and row 3 matches row¬†4.</blockquote>\n<blockquote>In the second pattern, the smudge can be fixed by changing the fifth symbol on row 2 from¬†. to¬†#:</blockquote>\n<blockquote>1v#...##..#v1<br>2^#...##..#^2<br>3¬†..##..### 3<br>4 #####.##. 4<br>5 #####.##. 5<br>6¬†..##..### 6<br>7 #....#..# 7</blockquote>\n<blockquote>Now, the pattern has a different horizontal line of reflection between rows 1 and¬†2.</blockquote>\n<blockquote>Summarize your notes as before, but instead use the new different reflection lines. In this example, the first pattern‚Äôs new horizontal line has 3 rows above it and the second pattern‚Äôs new horizontal line has 1 row above it, summarizing to the value¬†400.</blockquote>\n<blockquote>In each pattern, fix the smudge and find the different line of reflection. What number do you get after summarizing the new reflection line in each pattern in your¬†notes?</blockquote>\n<p>And‚Ä¶</p>\n<blockquote>every mirror has exactly one smudge: exactly one¬†. or # should be the opposite¬†type.</blockquote>\n<p>We are back to permutations and combinations! ü™¶</p>\n<p>üí≠ Carrying on with our brute force approach, since our code was pretty blazing fast, we can extend our solution by adding some extra steps and¬†loops.</p>\n<p>Introducing ‚Äòsmudges‚Äô, where exactly one character in each pattern is incorrect and needs to be flipped to find a new line of reflection. We can follow these¬†steps:</p>\n<ol>\n<li>\n<strong>Identify the Smudge</strong>: Iterate through each cell of the pattern. <br> a. For each cell, flip its value (from¬†. to # or vice versa) <br> b. then check if this change results in a <strong>valid reflection line different from the original</strong>. <br> c. if <strong>yes</strong>, this is the <strong>smudge</strong> we need to fix, else <strong>continue</strong>¬†loop</li>\n<li>\n<strong>Summarize the Patterns</strong>: Calculate the summary based on the new reflection lines.</li>\n</ol>\n<p>Let‚Äôs try¬†this?</p>\n<blockquote>üí°This approaches hinges upon the fact that puzzle states, there‚Äôs exactly 1 smudge in each¬†pattern!</blockquote>\n<blockquote>‚ùóÔ∏èEdge case: We need to ensure, that everytime we find a new reflection point, we need to compare it with original reflection point along with the mode, as sometimes the value can be same, but it can be for rows and columns respectively.<br>(new_reflection_point, mode)¬†!= (original_reflection_point, original_mode)</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IZm5QwQGOZ_qbTGbAbsJKg.png\"><figcaption>Tons of debugging later!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SB6a_qv-iqZ9-sSvoaGStw.png\"><figcaption>Masterpiece!</figcaption></figure><p>Let‚Äôs see if it works for our new test¬†case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/579/1*ozPJTOamPgPqdVYvEUUHUQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>‚úÖ summarize_pattern_with_smudges passed<br><br>[Done] exited with code=0 in 0.071 seconds</pre>\n<p>‚úÖ in just <strong>0.071 seconds</strong>! This gives me¬†hope!</p>\n<p>Let‚Äôs run it for the puzzle¬†input?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>‚ÄºÔ∏è Summarizing all patterns in Part 2: XXXXX<br><br>[Done] exited with code=0 in 0.281 seconds</pre>\n<p>Done! Let‚Äôs see if our answer is correct?¬†üëÄ</p>\n<p>And‚Ä¶</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*-GgwQaaV9TTLNX0awHsjbg.png\"><figcaption>ü•Å</figcaption></figure><p>Here‚Äôs our code with a bruteforce approach, works pretty quick on my M1 Macbook Pro. I might come back later to solve this in a more novel way, but since I am already running behind in AdventOfCode, I will just move on!¬†üòÉ</p>\n<pre># Day 13 - Point of Incidence<br><br>from enum import Enum<br>import itertools<br><br><br>class Mode(Enum):<br>    ROW = \"row\"<br>    COLUMN = \"column\"<br><br><br>class MirrorPatternAnalyzer:<br>    def __init__(self, pattern):<br>        self.pattern = [list(row) for row in pattern.strip().split(\"\\n\")]<br><br>    @staticmethod<br>    def flip_char(char):<br>        return \"#\" if char == \".\" else \".\"<br><br>    def is_perfect_reflection(self, index, mode):<br>        if mode == Mode.ROW:<br>            prev, next = index - 1, index<br>            while prev &gt;= 0 and next &lt; len(self.pattern):<br>                if self.pattern[prev] != self.pattern[next]:<br>                    return False<br>                prev -= 1<br>                next += 1<br>            return True<br><br>        elif mode == Mode.COLUMN:<br>            prev, next = index - 1, index<br>            while prev &gt;= 0 and next &lt; len(self.pattern[0]):<br>                if any(<br>                    self.pattern[row][prev] != self.pattern[row][next]<br>                    for row in range(len(self.pattern))<br>                ):<br>                    return False<br>                prev -= 1<br>                next += 1<br>            return True<br><br>        raise ValueError(\"Invalid mode\")<br><br>    def find_point_of_reflection(self, mode):<br>        range_to_check = range(<br>            1, len(self.pattern) if mode == Mode.ROW else len(self.pattern[0])<br>        )<br>        for i in range_to_check:<br>            if self.is_perfect_reflection(i, mode):<br>                return i<br>        return None<br><br>    def try_fix_smudge_and_find_reflection(<br>        self, original_reflection_point, original_mode<br>    ):<br>        for i in range(len(self.pattern)):<br>            for j in range(len(self.pattern[i])):<br>                self.pattern[i][j] = MirrorPatternAnalyzer.flip_char(self.pattern[i][j])<br>                for mode in [Mode.ROW, Mode.COLUMN]:<br>                    new_reflection_point = self.find_point_of_reflection(mode)<br>                    if new_reflection_point and (new_reflection_point, mode) != (<br>                        original_reflection_point,<br>                        original_mode,<br>                    ):<br>                        return new_reflection_point, mode<br>                self.pattern[i][j] = MirrorPatternAnalyzer.flip_char(self.pattern[i][j])<br>        return original_reflection_point, original_mode<br><br>    def analyze(self, with_smudge=False):<br>        for mode in [Mode.ROW, Mode.COLUMN]:<br>            reflection_point = self.find_point_of_reflection(mode)<br>            if reflection_point is not None:<br>                if with_smudge:<br>                    (<br>                        new_reflection_point,<br>                        new_mode,<br>                    ) = self.try_fix_smudge_and_find_reflection(reflection_point, mode)<br>                    if new_mode == Mode.ROW:<br>                        return new_reflection_point * 100<br>                    else:<br>                        return new_reflection_point<br>                else:<br>                    return (<br>                        reflection_point * 100 if mode == Mode.ROW else reflection_point<br>                    )<br>        raise Exception(\"No valid reflection line found\")<br><br><br>def summarize_patterns(patterns, with_smudges=False):<br>    total_sum = 0<br>    for i, pattern in enumerate(patterns.split(\"\\n\\n\")):<br>        analyzer = MirrorPatternAnalyzer(pattern)<br>        total_sum += analyzer.analyze(with_smudge=with_smudges)<br>    return total_sum<br><br><br>def part_one():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns)<br><br>    print(f\"‚ùóÔ∏è Summarizing all patterns in Part 1: {sum}\")<br><br><br>def test_summarize_patterns():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br>    sum = summarize_patterns(patterns)<br>    assert sum == 405, f\"Expected 405, got {sum}\"<br>    print(\"‚úÖ summarize_pattern passed\")<br><br><br>def part_two():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns, with_smudges=True)<br>    print(f\"‚ÄºÔ∏è Summarizing all patterns in Part 2: {sum}\")<br><br><br>def test_summarize_patterns_with_smudges():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br><br>    sum = summarize_patterns(patterns, with_smudges=True)<br>    assert sum == 400, f\"Expected 400, got {sum}\"<br>    print(\"‚úÖ summarize_pattern_with_smudges passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_summarize_patterns()<br>    part_one()<br><br>    test_summarize_patterns_with_smudges()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the¬†problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine¬†üëá</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! üéÑ</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4fea00eb98fb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*rfUmh-2ouPC2eg70\"><figcaption>Point of Incidence</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/13\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>With your help, the hot springs team locates an appropriate spring which launches you neatly and precisely up to the edge of Lava¬†Island.</blockquote>\n<blockquote>There‚Äôs just one problem: you don‚Äôt see any¬†lava.</blockquote>\n<blockquote>You do see a lot of ash and igneous rock; there are even what look like gray mountains scattered around. After a while, you make your way to a nearby cluster of mountains only to discover that the valley between them is completely full of large mirrors. Most of the mirrors seem to be aligned in a consistent way; perhaps you should head in that direction?</blockquote>\n<blockquote>As you move through the valley of mirrors, you find that several of them have fallen from the large metal frames keeping them in place. The mirrors are extremely flat and shiny, and many of the fallen mirrors have lodged into the ash at strange angles. Because the terrain is all one color, it‚Äôs hard to tell where it‚Äôs safe to walk or where you‚Äôre about to run into a¬†mirror.</blockquote>\n<blockquote>You note down the patterns of ash (.) and rocks (#) that you see as you walk (your puzzle input); perhaps by carefully analyzing these patterns, you can figure out where the mirrors¬†are!</blockquote>\n<blockquote>For example:</blockquote>\n<blockquote>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</blockquote>\n<blockquote>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</blockquote>\n<blockquote>To find the reflection in each pattern, you need to find a perfect reflection across either a horizontal line between two rows or across a vertical line between two¬†columns.</blockquote>\n<blockquote>In the first pattern, the reflection is across a vertical line between two columns; arrows on each of the two columns point at the line between the¬†columns:</blockquote>\n<blockquote>123456789<br> &gt;&lt; <br>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br> &gt;&lt; <br>123456789</blockquote>\n<blockquote>In this pattern, the line of reflection is the vertical line between columns 5 and 6. Because the vertical line is not perfectly in the middle of the pattern, part of the pattern (column 1) has nowhere to reflect onto and can be ignored; every other column has a reflected column within the pattern and must match exactly: column 2 matches column 9, column 3 matches 8, 4 matches 7, and 5 matches¬†6.</blockquote>\n<blockquote>The second pattern reflects across a horizontal line¬†instead:</blockquote>\n<blockquote>1 #...##..# 1<br>2 #....#..# 2<br>3¬†..##..### 3<br>4v#####.##.v4<br>5^#####.##.^5<br>6¬†..##..### 6<br>7 #....#..# 7</blockquote>\n<blockquote>This pattern reflects across the horizontal line between rows 4 and 5. Row 1 would reflect with a hypothetical row 8, but since that‚Äôs not in the pattern, row 1 doesn‚Äôt need to match anything. The remaining rows match: row 2 matches row 7, row 3 matches row 6, and row 4 matches row¬†5.</blockquote>\n<blockquote>To summarize your pattern notes, add up the number of columns to the left of each vertical line of reflection; to that, also add 100 multiplied by the number of rows above each horizontal line of reflection. In the above example, the first pattern‚Äôs vertical line has 5 columns to its left and the second pattern's horizontal line has 4 rows above it, a total of¬†405.</blockquote>\n<blockquote>Find the line of reflection in each of the patterns in your notes. What number do you get after summarizing all of your¬†notes?</blockquote>\n<blockquote>A mirror maze?! I have always loved them since childhood!</blockquote>\n<p>Let‚Äôs understand the problem! We are given a pattern of ash (.) and rocks (#) and we need to figure out a line of mirrors which can be either be in between rows or columns casting a perfect reflection in our¬†pattern!</p>\n<p>Let‚Äôs study the example with a visualization, for the given¬†input:</p>\n<pre>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</pre>\n<p>We can observe that the line of reflection is in b/w 5th and 6th column and our 1st column can be¬†ignored!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/858/1*w9RqnyQzNe7fby2oGhrycw.png\"><figcaption>Pattern 1</figcaption></figure><p>Similarly, for another¬†example:</p>\n<pre>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</pre>\n<p>We can see that line of reflection is in b/w 4th and 5th row and our 1st row can be¬†ignored!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/523/1*OpsohpC1DbR87xeu16gqMw.png\"><figcaption>Pattern 2</figcaption></figure><p>Now, the puzzle wants us to summarize these patterns and add¬†up:</p>\n<ul>\n<li>the <strong>number of columns</strong> to the <strong>left of each vertical line of reflection</strong>\n</li>\n<li>add <strong>100 multiplied</strong> by the number of <strong>rows</strong> <strong>above each horizontal line of reflection</strong>\n</li>\n</ul>\n<p>So, for the given example, the answer¬†becomes:</p>\n<blockquote>5 (pattern 1) + 4 (pattern 2) * 100 =¬†405</blockquote>\n<p>This is pretty interesting! My mind is trying to wander toward the Palindrome approach, especially for even numbers, but let me first write some test code for the base case given¬†above!</p>\n<blockquote>üí° A quick analysis of puzzle input shows that we will have multiple patterns to process, so we will structure our code accordingly!</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/543/1*e2OU1KdkRb9On0B06VUUQQ.png\"></figure><p>Let‚Äôs write code now, as mentioned, my initial idea is to just follow the naive palindrome approach, where I will try to compare ch[i] == ch[i-1] and will do a fan out approach to go both ways till we run out of¬†bounds:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/583/1*OV0bZhDBM5J44Ujz5284JA.png\"></figure><p>Now we can adapt the same approach to go <strong>row by row</strong>, and then if not found, we go <strong>column by column </strong>and then return the point as per the calculation for horizontal line v/s vertical line as per the¬†puzzle.</p>\n<p>.</p>\n<p>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*kwZ5gQR1bAGMWsA00gb9ow.png\"></figure><p>Few debugging sessions¬†later!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>‚úÖ summarize_pattern passed<br><br>[Done] exited with code=0 in 0.065 seconds</pre>\n<p>This is a bit bruteforce approach, but seems pretty fast for 2 patterns, 0.065 seconds, let‚Äôs load up our puzzle input and see how it runs as we seem to only have 100 patterns!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iAnwZ7o1zY1wgny3evWzyQ.png\"><figcaption>I am sure there will be a nutty edge case somewhere in¬†here!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/682/1*tysBMJDX-Q6_Mfq1wSeY4Q.png\"><figcaption>Let‚Äôs run this!¬†ü§û</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>‚ùóÔ∏è Summarizing all patterns in Part 1: XXXXXX<br><br>[Done] exited with code=0 in 0.051 seconds</pre>\n<p>Woah! We have an answer in just <strong>0.051</strong> seconds!¬†ü§Ø</p>\n<p>Let‚Äôs input this in the answer box¬†and‚Ä¶.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/879/1*H4vBV50RauNGTNK_qEO3aA.png\"><figcaption>üëØ‚Äç‚ôÄÔ∏èüëØ‚Äç‚ôÄÔ∏èüëØ‚Äç‚ôÄÔ∏è</figcaption></figure><p>Correct in first try and with an amazing runtime! Though I am sure as soon as I click on Part Two, it‚Äôs going to wreck our code!¬†ü§ì</p>\n<p>Here‚Äôs our raw code till now, we will optimise it in Part 2, like¬†always:</p>\n<pre># Day 13 - Point of Incidence<br><br>from enum import Enum<br><br>class Mode(Enum):<br>    ROW = \"row\"<br>    COLUMN = \"column\"<br><br>def is_perfect_reflection(prev, next, pattern, mode):<br>    if mode == Mode.ROW:<br>        while prev &gt;= 0 and next &lt; len(pattern):<br>            if pattern[prev] != pattern[next]:<br>                return False<br>            prev -= 1<br>            next += 1<br><br>        return True<br><br>    elif mode == Mode.COLUMN:<br>        while prev &gt;= 0 and next &lt; len(pattern[0]):<br>            for i in range(len(pattern)):<br>                if pattern[i][prev] != pattern[i][next]:<br>                    return False<br>            prev -= 1<br>            next += 1<br><br>        return True<br><br>    raise Exception(\"Invalid mode\")<br><br>def find_point_of_reflection(pattern, mode):<br>    if mode == Mode.ROW:<br>        for i in range(1, len(pattern)):<br>            if pattern[i-1] == pattern[i]:<br>                if is_perfect_reflection(i-1, i, pattern, Mode.ROW):<br>                    return i<br><br>    if mode == Mode.COLUMN:<br>        for j in range(1, len(pattern[0])):<br>            prev_col, next_col = [], []<br>            for i in range(0, len(pattern)):<br>                prev_col.append(pattern[i][j-1])<br>                next_col.append(pattern[i][j])<br>            if prev_col == next_col:<br>                if is_perfect_reflection(j-1, j, pattern, Mode.COLUMN):<br>                    return j<br><br>def analyze_pattern(pattern):<br>    pattern_grid = [list(row) for row in pattern.strip().split(\"\\n\")]<br><br>    # Find the point of reflection row by row<br>    point = find_point_of_reflection(pattern_grid, Mode.ROW)<br>    if point:<br>        return point * 100<br><br>    # Find the point of reflection column by column<br>    point = find_point_of_reflection(pattern_grid, Mode.COLUMN)<br>    if point:<br>        return point<br><br>    raise Exception(\"No point of reflection found\")<br><br>def summarize_patterns(patterns):<br>    sum = 0<br>    for pattern in patterns.split(\"\\n\\n\"):<br>        sum += analyze_pattern(pattern)<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns)<br><br>    print(f\"‚ùóÔ∏è Summarizing all patterns in Part 1: {sum}\")<br><br>def test_summarize_patterns():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br>    sum = summarize_patterns(patterns)<br>    assert sum == 405, f\"Expected 405, got {sum}\"<br>    print(\"‚úÖ summarize_pattern passed\")<br><br>if __name__ == \"__main__\":<br>    test_summarize_patterns()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>You resume walking through the valley of mirrors and‚Ää‚Äî‚ÄäSMACK!‚Ää‚Äî‚Äärun directly into one. Hopefully nobody was watching, because that must have been pretty embarrassing.</blockquote>\n<blockquote>Upon closer inspection, you discover that every mirror has exactly one smudge: exactly one¬†. or # should be the opposite¬†type.</blockquote>\n<blockquote>In each pattern, you‚Äôll need to locate and fix the smudge that causes a different reflection line to be valid. (The old reflection line won‚Äôt necessarily continue being valid after the smudge is¬†fixed.)</blockquote>\n<blockquote>Here‚Äôs the above example¬†again:</blockquote>\n<blockquote>#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.</blockquote>\n<blockquote>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#</blockquote>\n<blockquote>The first pattern‚Äôs smudge is in the top-left corner. If the top-left #were instead¬†., it would have a different, horizontal line of reflection:</blockquote>\n<blockquote>1¬†..##..##. 1<br>2¬†..#.##.#. 2<br>3v##......#v3<br>4^##......#^4<br>5¬†..#.##.#. 5<br>6¬†..##..##. 6<br>7 #.#.##.#. 7</blockquote>\n<blockquote>With the smudge in the top-left corner repaired, a new horizontal line of reflection between rows 3 and 4 now exists. Row 7 has no corresponding reflected row and can be ignored, but every other row matches exactly: row 1 matches row 6, row 2 matches row 5, and row 3 matches row¬†4.</blockquote>\n<blockquote>In the second pattern, the smudge can be fixed by changing the fifth symbol on row 2 from¬†. to¬†#:</blockquote>\n<blockquote>1v#...##..#v1<br>2^#...##..#^2<br>3¬†..##..### 3<br>4 #####.##. 4<br>5 #####.##. 5<br>6¬†..##..### 6<br>7 #....#..# 7</blockquote>\n<blockquote>Now, the pattern has a different horizontal line of reflection between rows 1 and¬†2.</blockquote>\n<blockquote>Summarize your notes as before, but instead use the new different reflection lines. In this example, the first pattern‚Äôs new horizontal line has 3 rows above it and the second pattern‚Äôs new horizontal line has 1 row above it, summarizing to the value¬†400.</blockquote>\n<blockquote>In each pattern, fix the smudge and find the different line of reflection. What number do you get after summarizing the new reflection line in each pattern in your¬†notes?</blockquote>\n<p>And‚Ä¶</p>\n<blockquote>every mirror has exactly one smudge: exactly one¬†. or # should be the opposite¬†type.</blockquote>\n<p>We are back to permutations and combinations! ü™¶</p>\n<p>üí≠ Carrying on with our brute force approach, since our code was pretty blazing fast, we can extend our solution by adding some extra steps and¬†loops.</p>\n<p>Introducing ‚Äòsmudges‚Äô, where exactly one character in each pattern is incorrect and needs to be flipped to find a new line of reflection. We can follow these¬†steps:</p>\n<ol>\n<li>\n<strong>Identify the Smudge</strong>: Iterate through each cell of the pattern. <br> a. For each cell, flip its value (from¬†. to # or vice versa) <br> b. then check if this change results in a <strong>valid reflection line different from the original</strong>. <br> c. if <strong>yes</strong>, this is the <strong>smudge</strong> we need to fix, else <strong>continue</strong>¬†loop</li>\n<li>\n<strong>Summarize the Patterns</strong>: Calculate the summary based on the new reflection lines.</li>\n</ol>\n<p>Let‚Äôs try¬†this?</p>\n<blockquote>üí°This approaches hinges upon the fact that puzzle states, there‚Äôs exactly 1 smudge in each¬†pattern!</blockquote>\n<blockquote>‚ùóÔ∏èEdge case: We need to ensure, that everytime we find a new reflection point, we need to compare it with original reflection point along with the mode, as sometimes the value can be same, but it can be for rows and columns respectively.<br>(new_reflection_point, mode)¬†!= (original_reflection_point, original_mode)</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IZm5QwQGOZ_qbTGbAbsJKg.png\"><figcaption>Tons of debugging later!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SB6a_qv-iqZ9-sSvoaGStw.png\"><figcaption>Masterpiece!</figcaption></figure><p>Let‚Äôs see if it works for our new test¬†case?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/579/1*ozPJTOamPgPqdVYvEUUHUQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_13/point_of_incidence.py\"<br>‚úÖ summarize_pattern_with_smudges passed<br><br>[Done] exited with code=0 in 0.071 seconds</pre>\n<p>‚úÖ in just <strong>0.071 seconds</strong>! This gives me¬†hope!</p>\n<p>Let‚Äôs run it for the puzzle¬†input?</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/tempCodeRunnerFile.python\"<br>‚ÄºÔ∏è Summarizing all patterns in Part 2: XXXXX<br><br>[Done] exited with code=0 in 0.281 seconds</pre>\n<p>Done! Let‚Äôs see if our answer is correct?¬†üëÄ</p>\n<p>And‚Ä¶</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*-GgwQaaV9TTLNX0awHsjbg.png\"><figcaption>ü•Å</figcaption></figure><p>Here‚Äôs our code with a bruteforce approach, works pretty quick on my M1 Macbook Pro. I might come back later to solve this in a more novel way, but since I am already running behind in AdventOfCode, I will just move on!¬†üòÉ</p>\n<pre># Day 13 - Point of Incidence<br><br>from enum import Enum<br>import itertools<br><br><br>class Mode(Enum):<br>    ROW = \"row\"<br>    COLUMN = \"column\"<br><br><br>class MirrorPatternAnalyzer:<br>    def __init__(self, pattern):<br>        self.pattern = [list(row) for row in pattern.strip().split(\"\\n\")]<br><br>    @staticmethod<br>    def flip_char(char):<br>        return \"#\" if char == \".\" else \".\"<br><br>    def is_perfect_reflection(self, index, mode):<br>        if mode == Mode.ROW:<br>            prev, next = index - 1, index<br>            while prev &gt;= 0 and next &lt; len(self.pattern):<br>                if self.pattern[prev] != self.pattern[next]:<br>                    return False<br>                prev -= 1<br>                next += 1<br>            return True<br><br>        elif mode == Mode.COLUMN:<br>            prev, next = index - 1, index<br>            while prev &gt;= 0 and next &lt; len(self.pattern[0]):<br>                if any(<br>                    self.pattern[row][prev] != self.pattern[row][next]<br>                    for row in range(len(self.pattern))<br>                ):<br>                    return False<br>                prev -= 1<br>                next += 1<br>            return True<br><br>        raise ValueError(\"Invalid mode\")<br><br>    def find_point_of_reflection(self, mode):<br>        range_to_check = range(<br>            1, len(self.pattern) if mode == Mode.ROW else len(self.pattern[0])<br>        )<br>        for i in range_to_check:<br>            if self.is_perfect_reflection(i, mode):<br>                return i<br>        return None<br><br>    def try_fix_smudge_and_find_reflection(<br>        self, original_reflection_point, original_mode<br>    ):<br>        for i in range(len(self.pattern)):<br>            for j in range(len(self.pattern[i])):<br>                self.pattern[i][j] = MirrorPatternAnalyzer.flip_char(self.pattern[i][j])<br>                for mode in [Mode.ROW, Mode.COLUMN]:<br>                    new_reflection_point = self.find_point_of_reflection(mode)<br>                    if new_reflection_point and (new_reflection_point, mode) != (<br>                        original_reflection_point,<br>                        original_mode,<br>                    ):<br>                        return new_reflection_point, mode<br>                self.pattern[i][j] = MirrorPatternAnalyzer.flip_char(self.pattern[i][j])<br>        return original_reflection_point, original_mode<br><br>    def analyze(self, with_smudge=False):<br>        for mode in [Mode.ROW, Mode.COLUMN]:<br>            reflection_point = self.find_point_of_reflection(mode)<br>            if reflection_point is not None:<br>                if with_smudge:<br>                    (<br>                        new_reflection_point,<br>                        new_mode,<br>                    ) = self.try_fix_smudge_and_find_reflection(reflection_point, mode)<br>                    if new_mode == Mode.ROW:<br>                        return new_reflection_point * 100<br>                    else:<br>                        return new_reflection_point<br>                else:<br>                    return (<br>                        reflection_point * 100 if mode == Mode.ROW else reflection_point<br>                    )<br>        raise Exception(\"No valid reflection line found\")<br><br><br>def summarize_patterns(patterns, with_smudges=False):<br>    total_sum = 0<br>    for i, pattern in enumerate(patterns.split(\"\\n\\n\")):<br>        analyzer = MirrorPatternAnalyzer(pattern)<br>        total_sum += analyzer.analyze(with_smudge=with_smudges)<br>    return total_sum<br><br><br>def part_one():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns)<br><br>    print(f\"‚ùóÔ∏è Summarizing all patterns in Part 1: {sum}\")<br><br><br>def test_summarize_patterns():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br>    sum = summarize_patterns(patterns)<br>    assert sum == 405, f\"Expected 405, got {sum}\"<br>    print(\"‚úÖ summarize_pattern passed\")<br><br><br>def part_two():<br>    with open(\"day_13/input.txt\", \"r\") as f:<br>        patterns = f.read()<br>    sum = summarize_patterns(patterns, with_smudges=True)<br>    print(f\"‚ÄºÔ∏è Summarizing all patterns in Part 2: {sum}\")<br><br><br>def test_summarize_patterns_with_smudges():<br>    patterns = \"\"\"#.##..##.<br>..#.##.#.<br>##......#<br>##......#<br>..#.##.#.<br>..##..##.<br>#.#.##.#.<br><br>#...##..#<br>#....#..#<br>..##..###<br>#####.##.<br>#####.##.<br>..##..###<br>#....#..#\"\"\"<br><br>    sum = summarize_patterns(patterns, with_smudges=True)<br>    assert sum == 400, f\"Expected 400, got {sum}\"<br>    print(\"‚úÖ summarize_pattern_with_smudges passed\")<br><br><br>if __name__ == \"__main__\":<br>    test_summarize_patterns()<br>    part_one()<br><br>    test_summarize_patterns_with_smudges()<br>    part_two()</pre>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the¬†problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine¬†üëá</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! üéÑ</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4fea00eb98fb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "python",
        "advent-of-code-2023",
        "advent-of-code",
        "christmas"
      ]
    },
    {
      "title": "[Day 12] Hot Springs // Advent of Code 2023 (Python)",
      "pubDate": "2023-12-19 14:46:59",
      "link": "https://medium.com/@jatinkrmalik/day-12-hot-springs-advent-of-code-2023-python-77506773abfb?source=rss-ec576e4b06b0------2",
      "guid": "https://medium.com/p/77506773abfb",
      "author": "Jatin K Malik",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*2qyq_T4PoQxHVYw9\"><figcaption>Hot Springs (via DALL-E¬†3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/12\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You finally reach the hot springs! You can see steam rising from secluded areas attached to the primary, ornate building.</blockquote>\n<blockquote>As you turn to enter, the <a href=\"https://adventofcode.com/2023/day/11\">researcher</a> stops you. ‚ÄúWait‚Ää‚Äî‚ÄäI thought you were looking for the hot springs, weren‚Äôt you?‚Äù You indicate that this definitely looks like hot springs to¬†you.</blockquote>\n<blockquote>‚ÄúOh, sorry, common mistake! This is actually the <a href=\"https://en.wikipedia.org/wiki/Onsen\">onsen</a>! The hot springs are next¬†door.‚Äù</blockquote>\n<blockquote>You look in the direction the researcher is pointing and suddenly notice the massive metal helixes towering overhead. ‚ÄúThis¬†way!‚Äù</blockquote>\n<blockquote>It only takes you a few more steps to reach the main gate of the massive fenced-off area containing the springs. You go through the gate and into a small administrative building.</blockquote>\n<blockquote>‚ÄúHello! What brings you to the hot springs today? Sorry they‚Äôre not very hot right now; we‚Äôre having a lava shortage at the moment.‚Äù You ask about the missing machine parts for Desert¬†Island.</blockquote>\n<blockquote>‚ÄúOh, all of Gear Island is currently offline! Nothing is being manufactured at the moment, not until we get more lava to heat our forges. And our springs. The springs aren‚Äôt very springy unless they‚Äôre¬†hot!‚Äù</blockquote>\n<blockquote>‚ÄúSay, could you go up and see why the lava stopped flowing? The springs are too cold for normal operation, but we should be able to find one springy enough to launch you up¬†there!‚Äù</blockquote>\n<blockquote>There‚Äôs just one problem‚Ää‚Äî‚Äämany of the springs have fallen into disrepair, so they‚Äôre not actually sure which springs would even be safe to use! Worse yet, their condition records of which springs are damaged (your puzzle input) are also damaged! You‚Äôll need to help them repair the damaged¬†records.</blockquote>\n<blockquote>In the giant field just outside, the springs are arranged into rows. For each row, the condition records show every spring and whether it is operational (.) or damaged (#). This is the part of the condition records that is itself damaged; for some springs, it is simply unknown (?) whether the spring is operational or¬†damaged.</blockquote>\n<blockquote>However, the engineer that produced the condition records also duplicated some of this information in a different format! After the list of springs for a given row, the size of each contiguous group of damaged springs is listed in the order those groups appear in the row. This list always accounts for every damaged spring, and each number is the entire size of its contiguous group (that is, groups are always separated by at least one operational spring: #### would always be 4, never¬†2,2).</blockquote>\n<blockquote>So, condition records with no unknown spring conditions might look like¬†this:</blockquote>\n<blockquote>#.#.### 1,1,3<br>.#...#....###. 1,1,3<br>.#.###.#.###### 1,3,1,6<br>####.#...#... 4,1,1<br>#....######..#####. 1,6,5<br>.###.##....# 3,2,1</blockquote>\n<blockquote>However, the condition records are partially damaged; some of the springs‚Äô conditions are actually unknown (?). For¬†example:</blockquote>\n<blockquote>???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1</blockquote>\n<blockquote>Equipped with this information, it is your job to figure out how many different arrangements of operational and broken springs fit the given criteria in each¬†row.</blockquote>\n<blockquote>In the first line (???.### 1,1,3), there is exactly one way separate groups of one, one, and three broken springs (in that order) can appear in that row: the first three unknown springs must be broken, then operational, then broken (#.#), making the whole row¬†#.#.###.</blockquote>\n<blockquote>The second line is more interesting:¬†.??..??...?##. 1,1,3 could be a total of four different arrangements. The last¬†? must always be broken (to satisfy the final contiguous group of three broken springs), and each¬†??must hide exactly one of the two broken springs. (Neither¬†?? could be both broken springs or they would form a single contiguous group of two; if that were true, the numbers afterward would have been 2,3 instead.) Since each¬†?? can either be #. or¬†.#, there are four possible arrangements of¬†springs.</blockquote>\n<blockquote>The last line is actually consistent with ten different arrangements! Because the first number is 3, the first and second¬†? must both be¬†. (if either were #, the first number would have to be 4 or higher). However, the remaining run of unknown spring conditions have many different ways they could hold groups of two and one broken¬†springs:</blockquote>\n<blockquote>?###???????? 3,2,1<br>.###.##.#...<br>.###.##..#..<br>.###.##...#.<br>.###.##....#<br>.###..##.#..<br>.###..##..#.<br>.###..##...#<br>.###...##.#.<br>.###...##..#<br>.###....##.#</blockquote>\n<blockquote>In this example, the number of possible arrangements for each row¬†is:</blockquote>\n<blockquote>???.### 1,1,3 - 1 arrangement</blockquote>\n<blockquote>.??..??...?##. 1,1,3 - 4 arrangements</blockquote>\n<blockquote>?#?#?#?#?#?#?#? 1,3,1,6 - 1 arrangement</blockquote>\n<blockquote>????.#...#... 4,1,1 - 1 arrangement</blockquote>\n<blockquote>????.######..#####. 1,6,5 - 4 arrangements</blockquote>\n<blockquote>?###???????? 3,2,1 - 10 arrangements</blockquote>\n<blockquote>Adding all of the possible arrangement counts together produces a total of 21 arrangements.</blockquote>\n<blockquote>For each row, count all of the different arrangements of operational and broken springs that meet the given criteria. What is the sum of those¬†counts?</blockquote>\n<p>Man! Another permutation and combination problem! It seems like Santa knows what I used to hate during my engineering days!¬†ü§ì</p>\n<p>So..let‚Äôs break the problem down, and try not to get ahead of ourself unlike <a href=\"https://medium.com/@jatinkrmalik/day-11-cosmic-expansion-advent-of-code-2023-python-6e545dad06bb\">Day¬†11</a>!</p>\n<p>In an ideal world, our spring records look something like¬†this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HEfawkgl3UkaXOujYeYvhQ.png\"></figure><p>But, since the condition records are partially damaged, some of the springs‚Äô conditions are actually unknown¬†(?):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/988/1*msCo829KuU8oXkABUT8D0w.png\"><figcaption>where `?` denotes the unknown¬†state</figcaption></figure><p>üí° So, before we start talking about combinations possible and all, I think we should assume the ideal case, and write a simple validator that validates the spring_state (left) with damaged_spring_record (right). And this case be our base¬†case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*cs0D_12A8fOC34O7FBHgWg.png\"><figcaption>Quick prototying in¬†REPL</figcaption></figure><p>Here‚Äôs our test¬†case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/795/1*6xYRS2whEuMWeyeqQwio_Q.png\"></figure><p>And here‚Äôs some shabby code just to validate the¬†idea:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/774/1*7IpkGhEBWW00mcYWRbWosQ.png\"></figure><p>Let‚Äôs run this, and we can validate that it indeed¬†works!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>‚úÖ OK: #.#.### 1,1,3<br>‚úÖ OK: .#...#....###. 1,1,3<br>‚úÖ OK: .#.###.#.###### 1,3,1,6<br>‚úÖ OK: ####.#...#... 4,1,1<br>‚úÖ OK: #....######..#####. 1,6,5<br>‚úÖ OK: .###.##....# 3,2,1<br><br>[Done] exited with code=0 in 0.097 seconds</pre>\n<p>So, now that we know the records are not ideal, but indeed damaged and has a lot of unknowns, we will expand the scope of our thinking.</p>\n<p>Well, it‚Äôs clear that our validate_spring_record(spring_record) bool function will play a pivotal role to solve the problem as for an example row from damaged¬†records:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/987/1*yPP9z0Et7UBNJgad-tIfBw.png\"><figcaption>We can use our validator function to help verify correct combinations</figcaption></figure><blockquote>Now, to get all possible combinations, we need to consider each¬†? as a place where 2 choices are possible: either¬†. or #. This is a classic problem of combinatorics where each¬†? represents a <strong>binary¬†choice</strong>.</blockquote>\n<p>In the example row taken above:¬†.??..??‚Ä¶?##.¬†, we have a total of 5¬†? present, where each can be replaced by¬†. or # so, mathematically speaking, that yields: <strong><em>2‚Åµ combinations ==¬†32.</em></strong></p>\n<p>üí≠ We can write a function that replaces each¬†? in the record with either¬†. or #, and then calls itself recursively until all¬†? have been replaced, using that we can generate all the combinations!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zt0yeaKGXxSM6uAVI9KrNg.png\"></figure><p>Let‚Äôs do a quick script¬†test?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*oszF9BgfE6OlziW0E3YOyA.png\"><figcaption>Looks good!</figcaption></figure><p>Now, all we need to do¬†is:</p>\n<ol>\n<li>For each spring_state record, generate all_combinations</li>\n<li>For each combination in all_combinations, count validate_spring_record(combination) ==¬†true</li>\n<li>sum(for each count of valid combination)</li>\n<li>???</li>\n<li>Profit!</li>\n</ol>\n<blockquote>‚ùóÔ∏è Disclaimer: I know this is not the most efficient way, but as always, my first approach is to match a solution to a problem and then try to find optimisations! We will probably have to do that as well, as we are currently generating 2^n combinations where the valid combinations will be super¬†low!</blockquote>\n<p>So, let‚Äôs write¬†üëÜcode:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/957/1*m_JTU9Mlkhm02vv22-ZzFw.png\"></figure><p>And let‚Äôs run for our base test case as given in the question:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>Found 1 valid combinations for ???.### 1,1,3<br>Found 4 valid combinations for .??..??...?##. 1,1,3<br>Found 1 valid combinations for ?#?#?#?#?#?#?#? 1,3,1,6<br>Found 1 valid combinations for ????.#...#... 4,1,1<br>Found 4 valid combinations for ????.######..#####. 1,6,5<br>Found 10 valid combinations for ?###???????? 3,2,1<br>‚úÖ OK - test_sum_spring_record_combinations<br><br>[Done] exited with code=0 in 0.066 seconds</pre>\n<p>Yes!!! Now, let‚Äôs load up the puzzle input and try to get an answer?¬†ü§û</p>\n<p>Ah, well‚Ä¶.this might take some time‚Ä¶and‚Ä¶</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>Found 4 valid combinations for .???#??????#. 6,1<br>Found 2 valid combinations for ???##???##?#??#?#..# 1,14,1<br>Found 2 valid combinations for #??????#????#?###?# 3,1,10,1<br>Found 13 valid combinations for .???????#????. 1,2,1,2<br>Found 4 valid combinations for ?##?.??.???.. 3,2,2<br>Found 1 valid combinations for #.?###?#??. 1,5<br>Found 12 valid combinations for ?#??#??????????.??.? 7,2,3,1<br>Found 1 valid combinations for ???###?#.##??? 8,3<br>...<br>1000 lines later<br>...<br>‚ùóÔ∏è Total valid combinations: XXXX<br><br>[Done] exited with code=0 in 49.445 seconds</pre>\n<p>Not bad! An answer in 49.445 seconds shall be considered a win comapred to last few¬†days!</p>\n<p>Let‚Äôs see if this is the corect¬†answers?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/830/1*a3NavRUiuC2ujHUK9wXbRw.png\"><figcaption>YASS!</figcaption></figure><p>Here‚Äôs my code till¬†now:</p>\n<pre># Day 12: Hot Springs<br><br>from enum import Enum<br><br><br>class SpringState(Enum):<br>    OPERATIONAL = \".\"<br>    DAMAGED = \"#\"<br>    UNKNOWN = \"?\"<br><br><br>def generate_spring_record_combinations(spring_record, index=0):<br>    if index &gt;= len(spring_record):<br>        return [spring_record]<br><br>    if spring_record[index] == SpringState.UNKNOWN.value:<br>        # replace '?' with '.' and combine results<br>        with_operational = generate_spring_record_combinations(<br>            spring_record[:index]<br>            + SpringState.OPERATIONAL.value<br>            + spring_record[index + 1 :],<br>            index + 1,<br>        )<br>        # replace '?' with '#' and combine results<br>        with_damaged = generate_spring_record_combinations(<br>            spring_record[:index]<br>            + SpringState.DAMAGED.value<br>            + spring_record[index + 1 :],<br>            index + 1,<br>        )<br>        return with_operational + with_damaged<br>    else:<br>        # continue recursion for next index<br>        return generate_spring_record_combinations(spring_record, index + 1)<br><br><br>def validate_spring_record(spring_state, damaged_spring_record):<br>    damaged_spring_record = damaged_spring_record.split(\",\")<br>    spring_state = list(spring_state)<br><br>    replica_damaged_spring_record = []<br>    damaged_count = 0<br>    for spring in spring_state:<br>        if spring == SpringState.DAMAGED.value:<br>            damaged_count += 1<br>        else:<br>            if damaged_count &gt; 0:<br>                replica_damaged_spring_record.append(str(damaged_count))<br>                damaged_count = 0<br><br>    if damaged_count &gt; 0:<br>        replica_damaged_spring_record.append(str(damaged_count))<br><br>    return replica_damaged_spring_record == damaged_spring_record<br><br><br>def sum_spring_record_combinations(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        combinations = generate_spring_record_combinations(spring_state)<br>        valid_combinations_length = len(<br>            [<br>                c for c in combinations<br>                if validate_spring_record(c, damaged_spring_record)<br>            ]<br>        )<br>        print(f\"Found {valid_combinations_length} valid combinations for {spring_record}\")<br>        total_combinations += valid_combinations_length<br>    return total_combinations<br><br>def part_one():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    print(f\"‚ùóÔ∏è Total valid combinations: {sum}\")<br><br>def test_sum_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    assert sum == 21, f\"‚ùå Expected: 21, Actual: {sum}\"<br>    print(\"‚úÖ OK - test_sum_spring_record_combinations\")<br><br><br>def test_validate_spring_record_ideal():<br>    ideal_spring_condition_records = \"\"\"#.#.### 1,1,3<br>.#...#....###. 1,1,3<br>.#.###.#.###### 1,3,1,6<br>####.#...#... 4,1,1<br>#....######..#####. 1,6,5<br>.###.##....# 3,2,1<br>\"\"\"<br>    for spring_record in ideal_spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        ok = validate_spring_record(spring_state, damaged_spring_record)<br>        assert ok, f\"‚ùå Expected: True, Actual: {ok}\"<br>        print(f\"‚úÖ OK: {spring_record}\")<br>    print(\"‚úÖ OK - test_validate_spring_record_ideal\")<br><br><br><br>if __name__ == \"__main__\":<br>    # test_validate_spring_record_ideal()<br>    test_sum_spring_record_combinations()<br>    part_one()</pre>\n<blockquote>I am aware that we have a lot of wasted compute that we can optimise here, but let‚Äôs move on to part 2 as that usually changes the requirements drastically and then we will combine refactor our¬†code.</blockquote>\n<h3>Part Two</h3>\n<blockquote>As you look out at the field of springs, you feel like there are way more springs than the condition records list. When you examine the records, you discover that they were actually folded up this whole¬†time!</blockquote>\n<blockquote>To unfold the records, on each row, replace the list of spring conditions with five copies of itself (separated by¬†?) and replace the list of contiguous groups of damaged springs with five copies of itself (separated by¬†,).</blockquote>\n<blockquote>So, this¬†row:</blockquote>\n<blockquote>.# 1</blockquote>\n<blockquote>Would become:</blockquote>\n<blockquote>.#?.#?.#?.#?.# 1,1,1,1,1</blockquote>\n<blockquote>The first line of the above example would¬†become:</blockquote>\n<blockquote>???.###????.###????.###????.###????.### 1,1,3,1,1,3,1,1,3,1,1,3,1,1,3</blockquote>\n<blockquote>In the above example, after unfolding, the number of possible arrangements for some rows is now much¬†larger:</blockquote>\n<blockquote>???.### 1,1,3 - 1 arrangement</blockquote>\n<blockquote>.??..??...?##. 1,1,3 - 16384 arrangements</blockquote>\n<blockquote>?#?#?#?#?#?#?#? 1,3,1,6 - 1 arrangement</blockquote>\n<blockquote>????.#...#... 4,1,1 - 16 arrangements</blockquote>\n<blockquote>????.######..#####. 1,6,5 - 2500 arrangements</blockquote>\n<blockquote>?###???????? 3,2,1 - 506250 arrangements</blockquote>\n<blockquote>After unfolding, adding all of the possible arrangement counts together produces¬†525152.</blockquote>\n<blockquote>Unfold your condition records; what is the new sum of possible arrangement counts?</blockquote>\n<p>Aha! Told you. So, now conviniently, springs were actually <strong>folded up </strong>this whole¬†time!</p>\n<p>To unfold the sequence, we just need to 5x each row of the record, for¬†example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/966/1*s4MTuZ3zRalGpICJhrhfJQ.png\"></figure><p>Clearly, our inefficient code will now not work, as our possible combinations will increase exponentially!</p>\n<blockquote>üí°Well, one simple way I can see to reduce computations is¬†to:</blockquote>\n<blockquote>- just integrate the validation logic directly into the combination generation process</blockquote>\n<blockquote>- instead of store all the combinations and then computing length, we can just return the <strong>valid</strong> number of combinations.</blockquote>\n<p>This way, we only generate valid combinations from the start, significantly reducing the number of combinations we need to¬†handle.</p>\n<p>Updating code for that, let‚Äôs run¬†it!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>‚úÖ OK - test_sum_spring_record_combinations<br>‚ùóÔ∏è Total valid combinations: 7599<br><br>[Done] exited with code=0 in 48.915 seconds</pre>\n<p>And it saved us a grand total of 49.445‚Äì48.915 = <strong>~530 ms¬†üòÇ</strong></p>\n<a href=\"https://medium.com/media/05826d1b7bcf41e217ad095add326244/href\">https://medium.com/media/05826d1b7bcf41e217ad095add326244/href</a><p>Breaking down the computation, it‚Äôs clear that we are <strong>spending a lot of time in</strong> generating ‚Äúall‚Äù the possible combinations of the record. Since we already have the damaged_spring_record, we should be able to use it to basically just generate correct combinations? Or at the least, do an <strong>early return</strong> for the all incorrect ones!¬†ü§î</p>\n<blockquote>The complexity of this problem lies in correctly interpreting the ‚Äò?‚Äô characters while adhering to the constraints set by the <strong><em>damaged_spring_record</em></strong>.</blockquote>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>üí° We need to find a way to <strong>prune of our search space early</strong> when a rule from damaged_spring_record is violated in our recursive process itself! Let‚Äôs write our early return conditions using our record while navigating through all possible combinations in our recursive function:</p>\n<ul>\n<li>If the damaged_spring_record is empty, <br>- if any spring is damaged: return 0 <br>- else, return¬†1.</li>\n<li>If the spring_state string is empty, <br>- if there are no damaged spring records left to process: return 1<br>- else, return¬†0.</li>\n<li>recursively check each spring state and calculate the total number of valid combinations based on whether the current spring is operational, damaged, or¬†unknown.</li>\n</ul>\n<p>And since now alot of search space will have repeated calculations, we can use @cache decorator from functools to memoize the results of the recursive function get_valid_spring_record_combinations in an LRU cache with no size¬†limit!</p>\n<blockquote>Python does make caching absolutely simple with these nifty OOTB decorators! ü§å</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SOZFKjkeUP6fDZF42V4Ffw.png\"></figure><p>And here, our is_valid_condition would look¬†like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/882/1*9jeKFExvbHulJLyT9qmFQQ.png\"></figure><p>‚ùóÔ∏è Here, _is_valid_condition returns a boolean value that indicates whether the given spring_state and damaged_spring_record meet the following conditions:</p>\n<ol>\n<li>The first element of damaged_spring_record (which represents the number of damaged springs in the first group) is less than or equal to the length of spring_state. This ensures that there are enough springs in spring_state to account for the first group of damaged¬†springs.</li>\n<li>All springs in spring_state up to the index equal to the first element of damaged_spring_record are not operational. This is checked by ensuring that the OPERATIONAL value of the SpringState Enum is not found in the substring of spring_state that ends at the index equal to the first element of damaged_spring_record.</li>\n<li>Either the first element of damaged_spring_record is equal to the length of spring_state (which means that all springs are damaged), or the spring at the index equal to the first element of damaged_spring_record is not damaged. This ensures that there is no damaged spring immediately after the first group of damaged¬†springs.</li>\n</ol>\n<p>Let‚Äôs run this code for our base test case of part¬†1:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/748/1*Hw9kB_F1vPM-PDxQxMNqwQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>‚úÖ OK - test_sum_spring_record_combinations<br><br>[Done] exited with code=0 in 0.109 seconds</pre>\n<p>And puzzle input for part¬†1:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*R7ko8-beeAmE7h8LOHK8ig.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>‚ùóÔ∏è Total valid combinations: XXXX<br><br>[Done] exited with code=0 in 0.134 seconds</pre>\n<p>Wow! We get the correct answer in just <strong>0.134 seconds </strong>compare this to our previous brute force approach that took <strong>~49 seconds¬†üòØ</strong></p>\n<p>Now, let‚Äôs also write our base test case for part 2, where all we need to do is, just increase our input per spring_record * 5¬†:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/796/1*1tR0tV2M9F1FkhO9YmgEhg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>‚úÖ OK - test_sum_unfolded_spring_record_combinations<br><br>[Done] exited with code=0 in 0.11 seconds</pre>\n<p>Phew! And now let‚Äôs do it for part 2, puzzle¬†input:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*KwV2lKEhMMicGv2y4jS69Q.png\"><figcaption>* 5 for unfolding Í©ú</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>‚ùóÔ∏è Total valid combinations: XXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.693 seconds</pre>\n<p><strong>Yes! Look at that runtime!¬†üöÄ</strong></p>\n<p>Let‚Äôs put this answer in the text box?¬†And‚Ä¶</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/950/1*HfuXqBmUaJQdhPzx1YC98w.png\"><figcaption>üí•</figcaption></figure><p>Here‚Äôs our super optimised code till now, I am not doing object oriented for this one!¬†:P</p>\n<pre>from enum import Enum<br>from functools import cache<br><br><br>class SpringState(Enum):<br>    OPERATIONAL = \".\"<br>    DAMAGED = \"#\"<br>    UNKNOWN = \"?\"<br><br><br>@cache<br>def get_valid_spring_record_combinations(spring_state, damaged_spring_record):<br>    if not damaged_spring_record:<br>        if SpringState.DAMAGED.value in spring_state:<br>            return 0<br>        else:<br>            return 1<br><br>    if not spring_state:<br>        if not damaged_spring_record:<br>            return 1<br>        else:<br>            return 0<br><br>    total_combinations = 0<br><br>    # if \".\" or \"?\"<br>    if spring_state[0] in [SpringState.OPERATIONAL.value, SpringState.UNKNOWN.value]:<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state[1:], damaged_spring_record<br>        )<br><br>    # if \"#\" or \"?\"<br>    if spring_state[0] in [SpringState.DAMAGED.value, SpringState.UNKNOWN.value]:<br>        if is_valid_condition(spring_state, damaged_spring_record):<br>            total_combinations += get_valid_spring_record_combinations(<br>                spring_state[damaged_spring_record[0] + 1 :], damaged_spring_record[1:]<br>            )<br><br>    return total_combinations<br><br><br>def is_valid_condition(spring_state, damaged_spring_record):<br>    return (<br>        damaged_spring_record[0] &lt;= len(spring_state)<br>        and SpringState.OPERATIONAL.value<br>        not in spring_state[: damaged_spring_record[0]]<br>        and (<br>            damaged_spring_record[0] == len(spring_state)<br>            or spring_state[damaged_spring_record[0]] != SpringState.DAMAGED.value<br>        )<br>    )<br><br><br>def sum_spring_record_combinations(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        damaged_spring_record = tuple(map(int, damaged_spring_record.split(\",\")))<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state, damaged_spring_record<br>        )<br><br>    return total_combinations<br><br><br>def part_one():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    print(f\"‚ùóÔ∏è Total valid combinations: {sum}\")<br><br><br>def sum_spring_record_combinations_unfold(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        damaged_spring_record = tuple(map(int, damaged_spring_record.split(\",\")))<br>        spring_state = \"?\".join([spring_state] * 5)  # unfolding<br>        damaged_spring_record = damaged_spring_record * 5  # unfolding<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state, damaged_spring_record<br>        )<br><br>    return total_combinations<br><br><br>def part_two():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations_unfold(spring_condition_records)<br>    print(f\"‚ùóÔ∏è Total valid combinations: {sum}\")<br><br><br>def test_sum_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    assert sum == 21, f\"‚ùå Expected: 21, Actual: {sum}\"<br>    print(\"‚úÖ OK - test_sum_spring_record_combinations\")<br><br><br>def test_sum_unfolded_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations_unfold(spring_condition_records)<br>    assert sum == 525152, f\"‚ùå Expected: 525152, Actual: {sum}\"<br>    print(\"‚úÖ OK - test_sum_unfolded_spring_record_combinations\")<br><br><br>if __name__ == \"__main__\":<br>    test_sum_spring_record_combinations()<br>    part_one()<br><br>    test_sum_unfolded_spring_record_combinations()<br>    part_two()</pre>\n<p>Man! I am learning so much with <strong>#AdventOfCode2023</strong>, it‚Äôs beautiful that I am getting to revisit a lot of my engineering days concepts that I don‚Äôt get to use in my day to day work while building CRUD apps!¬†ü§ì</p>\n<p>Onto the next day¬†then?!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the¬†problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine¬†üëá</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! üéÑ</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=77506773abfb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*2qyq_T4PoQxHVYw9\"><figcaption>Hot Springs (via DALL-E¬†3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/12\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You finally reach the hot springs! You can see steam rising from secluded areas attached to the primary, ornate building.</blockquote>\n<blockquote>As you turn to enter, the <a href=\"https://adventofcode.com/2023/day/11\">researcher</a> stops you. ‚ÄúWait‚Ää‚Äî‚ÄäI thought you were looking for the hot springs, weren‚Äôt you?‚Äù You indicate that this definitely looks like hot springs to¬†you.</blockquote>\n<blockquote>‚ÄúOh, sorry, common mistake! This is actually the <a href=\"https://en.wikipedia.org/wiki/Onsen\">onsen</a>! The hot springs are next¬†door.‚Äù</blockquote>\n<blockquote>You look in the direction the researcher is pointing and suddenly notice the massive metal helixes towering overhead. ‚ÄúThis¬†way!‚Äù</blockquote>\n<blockquote>It only takes you a few more steps to reach the main gate of the massive fenced-off area containing the springs. You go through the gate and into a small administrative building.</blockquote>\n<blockquote>‚ÄúHello! What brings you to the hot springs today? Sorry they‚Äôre not very hot right now; we‚Äôre having a lava shortage at the moment.‚Äù You ask about the missing machine parts for Desert¬†Island.</blockquote>\n<blockquote>‚ÄúOh, all of Gear Island is currently offline! Nothing is being manufactured at the moment, not until we get more lava to heat our forges. And our springs. The springs aren‚Äôt very springy unless they‚Äôre¬†hot!‚Äù</blockquote>\n<blockquote>‚ÄúSay, could you go up and see why the lava stopped flowing? The springs are too cold for normal operation, but we should be able to find one springy enough to launch you up¬†there!‚Äù</blockquote>\n<blockquote>There‚Äôs just one problem‚Ää‚Äî‚Äämany of the springs have fallen into disrepair, so they‚Äôre not actually sure which springs would even be safe to use! Worse yet, their condition records of which springs are damaged (your puzzle input) are also damaged! You‚Äôll need to help them repair the damaged¬†records.</blockquote>\n<blockquote>In the giant field just outside, the springs are arranged into rows. For each row, the condition records show every spring and whether it is operational (.) or damaged (#). This is the part of the condition records that is itself damaged; for some springs, it is simply unknown (?) whether the spring is operational or¬†damaged.</blockquote>\n<blockquote>However, the engineer that produced the condition records also duplicated some of this information in a different format! After the list of springs for a given row, the size of each contiguous group of damaged springs is listed in the order those groups appear in the row. This list always accounts for every damaged spring, and each number is the entire size of its contiguous group (that is, groups are always separated by at least one operational spring: #### would always be 4, never¬†2,2).</blockquote>\n<blockquote>So, condition records with no unknown spring conditions might look like¬†this:</blockquote>\n<blockquote>#.#.### 1,1,3<br>.#...#....###. 1,1,3<br>.#.###.#.###### 1,3,1,6<br>####.#...#... 4,1,1<br>#....######..#####. 1,6,5<br>.###.##....# 3,2,1</blockquote>\n<blockquote>However, the condition records are partially damaged; some of the springs‚Äô conditions are actually unknown (?). For¬†example:</blockquote>\n<blockquote>???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1</blockquote>\n<blockquote>Equipped with this information, it is your job to figure out how many different arrangements of operational and broken springs fit the given criteria in each¬†row.</blockquote>\n<blockquote>In the first line (???.### 1,1,3), there is exactly one way separate groups of one, one, and three broken springs (in that order) can appear in that row: the first three unknown springs must be broken, then operational, then broken (#.#), making the whole row¬†#.#.###.</blockquote>\n<blockquote>The second line is more interesting:¬†.??..??...?##. 1,1,3 could be a total of four different arrangements. The last¬†? must always be broken (to satisfy the final contiguous group of three broken springs), and each¬†??must hide exactly one of the two broken springs. (Neither¬†?? could be both broken springs or they would form a single contiguous group of two; if that were true, the numbers afterward would have been 2,3 instead.) Since each¬†?? can either be #. or¬†.#, there are four possible arrangements of¬†springs.</blockquote>\n<blockquote>The last line is actually consistent with ten different arrangements! Because the first number is 3, the first and second¬†? must both be¬†. (if either were #, the first number would have to be 4 or higher). However, the remaining run of unknown spring conditions have many different ways they could hold groups of two and one broken¬†springs:</blockquote>\n<blockquote>?###???????? 3,2,1<br>.###.##.#...<br>.###.##..#..<br>.###.##...#.<br>.###.##....#<br>.###..##.#..<br>.###..##..#.<br>.###..##...#<br>.###...##.#.<br>.###...##..#<br>.###....##.#</blockquote>\n<blockquote>In this example, the number of possible arrangements for each row¬†is:</blockquote>\n<blockquote>???.### 1,1,3 - 1 arrangement</blockquote>\n<blockquote>.??..??...?##. 1,1,3 - 4 arrangements</blockquote>\n<blockquote>?#?#?#?#?#?#?#? 1,3,1,6 - 1 arrangement</blockquote>\n<blockquote>????.#...#... 4,1,1 - 1 arrangement</blockquote>\n<blockquote>????.######..#####. 1,6,5 - 4 arrangements</blockquote>\n<blockquote>?###???????? 3,2,1 - 10 arrangements</blockquote>\n<blockquote>Adding all of the possible arrangement counts together produces a total of 21 arrangements.</blockquote>\n<blockquote>For each row, count all of the different arrangements of operational and broken springs that meet the given criteria. What is the sum of those¬†counts?</blockquote>\n<p>Man! Another permutation and combination problem! It seems like Santa knows what I used to hate during my engineering days!¬†ü§ì</p>\n<p>So..let‚Äôs break the problem down, and try not to get ahead of ourself unlike <a href=\"https://medium.com/@jatinkrmalik/day-11-cosmic-expansion-advent-of-code-2023-python-6e545dad06bb\">Day¬†11</a>!</p>\n<p>In an ideal world, our spring records look something like¬†this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HEfawkgl3UkaXOujYeYvhQ.png\"></figure><p>But, since the condition records are partially damaged, some of the springs‚Äô conditions are actually unknown¬†(?):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/988/1*msCo829KuU8oXkABUT8D0w.png\"><figcaption>where `?` denotes the unknown¬†state</figcaption></figure><p>üí° So, before we start talking about combinations possible and all, I think we should assume the ideal case, and write a simple validator that validates the spring_state (left) with damaged_spring_record (right). And this case be our base¬†case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*cs0D_12A8fOC34O7FBHgWg.png\"><figcaption>Quick prototying in¬†REPL</figcaption></figure><p>Here‚Äôs our test¬†case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/795/1*6xYRS2whEuMWeyeqQwio_Q.png\"></figure><p>And here‚Äôs some shabby code just to validate the¬†idea:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/774/1*7IpkGhEBWW00mcYWRbWosQ.png\"></figure><p>Let‚Äôs run this, and we can validate that it indeed¬†works!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>‚úÖ OK: #.#.### 1,1,3<br>‚úÖ OK: .#...#....###. 1,1,3<br>‚úÖ OK: .#.###.#.###### 1,3,1,6<br>‚úÖ OK: ####.#...#... 4,1,1<br>‚úÖ OK: #....######..#####. 1,6,5<br>‚úÖ OK: .###.##....# 3,2,1<br><br>[Done] exited with code=0 in 0.097 seconds</pre>\n<p>So, now that we know the records are not ideal, but indeed damaged and has a lot of unknowns, we will expand the scope of our thinking.</p>\n<p>Well, it‚Äôs clear that our validate_spring_record(spring_record) bool function will play a pivotal role to solve the problem as for an example row from damaged¬†records:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/987/1*yPP9z0Et7UBNJgad-tIfBw.png\"><figcaption>We can use our validator function to help verify correct combinations</figcaption></figure><blockquote>Now, to get all possible combinations, we need to consider each¬†? as a place where 2 choices are possible: either¬†. or #. This is a classic problem of combinatorics where each¬†? represents a <strong>binary¬†choice</strong>.</blockquote>\n<p>In the example row taken above:¬†.??..??‚Ä¶?##.¬†, we have a total of 5¬†? present, where each can be replaced by¬†. or # so, mathematically speaking, that yields: <strong><em>2‚Åµ combinations ==¬†32.</em></strong></p>\n<p>üí≠ We can write a function that replaces each¬†? in the record with either¬†. or #, and then calls itself recursively until all¬†? have been replaced, using that we can generate all the combinations!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zt0yeaKGXxSM6uAVI9KrNg.png\"></figure><p>Let‚Äôs do a quick script¬†test?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*oszF9BgfE6OlziW0E3YOyA.png\"><figcaption>Looks good!</figcaption></figure><p>Now, all we need to do¬†is:</p>\n<ol>\n<li>For each spring_state record, generate all_combinations</li>\n<li>For each combination in all_combinations, count validate_spring_record(combination) ==¬†true</li>\n<li>sum(for each count of valid combination)</li>\n<li>???</li>\n<li>Profit!</li>\n</ol>\n<blockquote>‚ùóÔ∏è Disclaimer: I know this is not the most efficient way, but as always, my first approach is to match a solution to a problem and then try to find optimisations! We will probably have to do that as well, as we are currently generating 2^n combinations where the valid combinations will be super¬†low!</blockquote>\n<p>So, let‚Äôs write¬†üëÜcode:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/957/1*m_JTU9Mlkhm02vv22-ZzFw.png\"></figure><p>And let‚Äôs run for our base test case as given in the question:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>Found 1 valid combinations for ???.### 1,1,3<br>Found 4 valid combinations for .??..??...?##. 1,1,3<br>Found 1 valid combinations for ?#?#?#?#?#?#?#? 1,3,1,6<br>Found 1 valid combinations for ????.#...#... 4,1,1<br>Found 4 valid combinations for ????.######..#####. 1,6,5<br>Found 10 valid combinations for ?###???????? 3,2,1<br>‚úÖ OK - test_sum_spring_record_combinations<br><br>[Done] exited with code=0 in 0.066 seconds</pre>\n<p>Yes!!! Now, let‚Äôs load up the puzzle input and try to get an answer?¬†ü§û</p>\n<p>Ah, well‚Ä¶.this might take some time‚Ä¶and‚Ä¶</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>Found 4 valid combinations for .???#??????#. 6,1<br>Found 2 valid combinations for ???##???##?#??#?#..# 1,14,1<br>Found 2 valid combinations for #??????#????#?###?# 3,1,10,1<br>Found 13 valid combinations for .???????#????. 1,2,1,2<br>Found 4 valid combinations for ?##?.??.???.. 3,2,2<br>Found 1 valid combinations for #.?###?#??. 1,5<br>Found 12 valid combinations for ?#??#??????????.??.? 7,2,3,1<br>Found 1 valid combinations for ???###?#.##??? 8,3<br>...<br>1000 lines later<br>...<br>‚ùóÔ∏è Total valid combinations: XXXX<br><br>[Done] exited with code=0 in 49.445 seconds</pre>\n<p>Not bad! An answer in 49.445 seconds shall be considered a win comapred to last few¬†days!</p>\n<p>Let‚Äôs see if this is the corect¬†answers?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/830/1*a3NavRUiuC2ujHUK9wXbRw.png\"><figcaption>YASS!</figcaption></figure><p>Here‚Äôs my code till¬†now:</p>\n<pre># Day 12: Hot Springs<br><br>from enum import Enum<br><br><br>class SpringState(Enum):<br>    OPERATIONAL = \".\"<br>    DAMAGED = \"#\"<br>    UNKNOWN = \"?\"<br><br><br>def generate_spring_record_combinations(spring_record, index=0):<br>    if index &gt;= len(spring_record):<br>        return [spring_record]<br><br>    if spring_record[index] == SpringState.UNKNOWN.value:<br>        # replace '?' with '.' and combine results<br>        with_operational = generate_spring_record_combinations(<br>            spring_record[:index]<br>            + SpringState.OPERATIONAL.value<br>            + spring_record[index + 1 :],<br>            index + 1,<br>        )<br>        # replace '?' with '#' and combine results<br>        with_damaged = generate_spring_record_combinations(<br>            spring_record[:index]<br>            + SpringState.DAMAGED.value<br>            + spring_record[index + 1 :],<br>            index + 1,<br>        )<br>        return with_operational + with_damaged<br>    else:<br>        # continue recursion for next index<br>        return generate_spring_record_combinations(spring_record, index + 1)<br><br><br>def validate_spring_record(spring_state, damaged_spring_record):<br>    damaged_spring_record = damaged_spring_record.split(\",\")<br>    spring_state = list(spring_state)<br><br>    replica_damaged_spring_record = []<br>    damaged_count = 0<br>    for spring in spring_state:<br>        if spring == SpringState.DAMAGED.value:<br>            damaged_count += 1<br>        else:<br>            if damaged_count &gt; 0:<br>                replica_damaged_spring_record.append(str(damaged_count))<br>                damaged_count = 0<br><br>    if damaged_count &gt; 0:<br>        replica_damaged_spring_record.append(str(damaged_count))<br><br>    return replica_damaged_spring_record == damaged_spring_record<br><br><br>def sum_spring_record_combinations(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        combinations = generate_spring_record_combinations(spring_state)<br>        valid_combinations_length = len(<br>            [<br>                c for c in combinations<br>                if validate_spring_record(c, damaged_spring_record)<br>            ]<br>        )<br>        print(f\"Found {valid_combinations_length} valid combinations for {spring_record}\")<br>        total_combinations += valid_combinations_length<br>    return total_combinations<br><br>def part_one():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    print(f\"‚ùóÔ∏è Total valid combinations: {sum}\")<br><br>def test_sum_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    assert sum == 21, f\"‚ùå Expected: 21, Actual: {sum}\"<br>    print(\"‚úÖ OK - test_sum_spring_record_combinations\")<br><br><br>def test_validate_spring_record_ideal():<br>    ideal_spring_condition_records = \"\"\"#.#.### 1,1,3<br>.#...#....###. 1,1,3<br>.#.###.#.###### 1,3,1,6<br>####.#...#... 4,1,1<br>#....######..#####. 1,6,5<br>.###.##....# 3,2,1<br>\"\"\"<br>    for spring_record in ideal_spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        ok = validate_spring_record(spring_state, damaged_spring_record)<br>        assert ok, f\"‚ùå Expected: True, Actual: {ok}\"<br>        print(f\"‚úÖ OK: {spring_record}\")<br>    print(\"‚úÖ OK - test_validate_spring_record_ideal\")<br><br><br><br>if __name__ == \"__main__\":<br>    # test_validate_spring_record_ideal()<br>    test_sum_spring_record_combinations()<br>    part_one()</pre>\n<blockquote>I am aware that we have a lot of wasted compute that we can optimise here, but let‚Äôs move on to part 2 as that usually changes the requirements drastically and then we will combine refactor our¬†code.</blockquote>\n<h3>Part Two</h3>\n<blockquote>As you look out at the field of springs, you feel like there are way more springs than the condition records list. When you examine the records, you discover that they were actually folded up this whole¬†time!</blockquote>\n<blockquote>To unfold the records, on each row, replace the list of spring conditions with five copies of itself (separated by¬†?) and replace the list of contiguous groups of damaged springs with five copies of itself (separated by¬†,).</blockquote>\n<blockquote>So, this¬†row:</blockquote>\n<blockquote>.# 1</blockquote>\n<blockquote>Would become:</blockquote>\n<blockquote>.#?.#?.#?.#?.# 1,1,1,1,1</blockquote>\n<blockquote>The first line of the above example would¬†become:</blockquote>\n<blockquote>???.###????.###????.###????.###????.### 1,1,3,1,1,3,1,1,3,1,1,3,1,1,3</blockquote>\n<blockquote>In the above example, after unfolding, the number of possible arrangements for some rows is now much¬†larger:</blockquote>\n<blockquote>???.### 1,1,3 - 1 arrangement</blockquote>\n<blockquote>.??..??...?##. 1,1,3 - 16384 arrangements</blockquote>\n<blockquote>?#?#?#?#?#?#?#? 1,3,1,6 - 1 arrangement</blockquote>\n<blockquote>????.#...#... 4,1,1 - 16 arrangements</blockquote>\n<blockquote>????.######..#####. 1,6,5 - 2500 arrangements</blockquote>\n<blockquote>?###???????? 3,2,1 - 506250 arrangements</blockquote>\n<blockquote>After unfolding, adding all of the possible arrangement counts together produces¬†525152.</blockquote>\n<blockquote>Unfold your condition records; what is the new sum of possible arrangement counts?</blockquote>\n<p>Aha! Told you. So, now conviniently, springs were actually <strong>folded up </strong>this whole¬†time!</p>\n<p>To unfold the sequence, we just need to 5x each row of the record, for¬†example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/966/1*s4MTuZ3zRalGpICJhrhfJQ.png\"></figure><p>Clearly, our inefficient code will now not work, as our possible combinations will increase exponentially!</p>\n<blockquote>üí°Well, one simple way I can see to reduce computations is¬†to:</blockquote>\n<blockquote>- just integrate the validation logic directly into the combination generation process</blockquote>\n<blockquote>- instead of store all the combinations and then computing length, we can just return the <strong>valid</strong> number of combinations.</blockquote>\n<p>This way, we only generate valid combinations from the start, significantly reducing the number of combinations we need to¬†handle.</p>\n<p>Updating code for that, let‚Äôs run¬†it!</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>‚úÖ OK - test_sum_spring_record_combinations<br>‚ùóÔ∏è Total valid combinations: 7599<br><br>[Done] exited with code=0 in 48.915 seconds</pre>\n<p>And it saved us a grand total of 49.445‚Äì48.915 = <strong>~530 ms¬†üòÇ</strong></p>\n<a href=\"https://medium.com/media/05826d1b7bcf41e217ad095add326244/href\">https://medium.com/media/05826d1b7bcf41e217ad095add326244/href</a><p>Breaking down the computation, it‚Äôs clear that we are <strong>spending a lot of time in</strong> generating ‚Äúall‚Äù the possible combinations of the record. Since we already have the damaged_spring_record, we should be able to use it to basically just generate correct combinations? Or at the least, do an <strong>early return</strong> for the all incorrect ones!¬†ü§î</p>\n<blockquote>The complexity of this problem lies in correctly interpreting the ‚Äò?‚Äô characters while adhering to the constraints set by the <strong><em>damaged_spring_record</em></strong>.</blockquote>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>üí° We need to find a way to <strong>prune of our search space early</strong> when a rule from damaged_spring_record is violated in our recursive process itself! Let‚Äôs write our early return conditions using our record while navigating through all possible combinations in our recursive function:</p>\n<ul>\n<li>If the damaged_spring_record is empty, <br>- if any spring is damaged: return 0 <br>- else, return¬†1.</li>\n<li>If the spring_state string is empty, <br>- if there are no damaged spring records left to process: return 1<br>- else, return¬†0.</li>\n<li>recursively check each spring state and calculate the total number of valid combinations based on whether the current spring is operational, damaged, or¬†unknown.</li>\n</ul>\n<p>And since now alot of search space will have repeated calculations, we can use @cache decorator from functools to memoize the results of the recursive function get_valid_spring_record_combinations in an LRU cache with no size¬†limit!</p>\n<blockquote>Python does make caching absolutely simple with these nifty OOTB decorators! ü§å</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SOZFKjkeUP6fDZF42V4Ffw.png\"></figure><p>And here, our is_valid_condition would look¬†like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/882/1*9jeKFExvbHulJLyT9qmFQQ.png\"></figure><p>‚ùóÔ∏è Here, _is_valid_condition returns a boolean value that indicates whether the given spring_state and damaged_spring_record meet the following conditions:</p>\n<ol>\n<li>The first element of damaged_spring_record (which represents the number of damaged springs in the first group) is less than or equal to the length of spring_state. This ensures that there are enough springs in spring_state to account for the first group of damaged¬†springs.</li>\n<li>All springs in spring_state up to the index equal to the first element of damaged_spring_record are not operational. This is checked by ensuring that the OPERATIONAL value of the SpringState Enum is not found in the substring of spring_state that ends at the index equal to the first element of damaged_spring_record.</li>\n<li>Either the first element of damaged_spring_record is equal to the length of spring_state (which means that all springs are damaged), or the spring at the index equal to the first element of damaged_spring_record is not damaged. This ensures that there is no damaged spring immediately after the first group of damaged¬†springs.</li>\n</ol>\n<p>Let‚Äôs run this code for our base test case of part¬†1:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/748/1*Hw9kB_F1vPM-PDxQxMNqwQ.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>‚úÖ OK - test_sum_spring_record_combinations<br><br>[Done] exited with code=0 in 0.109 seconds</pre>\n<p>And puzzle input for part¬†1:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*R7ko8-beeAmE7h8LOHK8ig.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>‚ùóÔ∏è Total valid combinations: XXXX<br><br>[Done] exited with code=0 in 0.134 seconds</pre>\n<p>Wow! We get the correct answer in just <strong>0.134 seconds </strong>compare this to our previous brute force approach that took <strong>~49 seconds¬†üòØ</strong></p>\n<p>Now, let‚Äôs also write our base test case for part 2, where all we need to do is, just increase our input per spring_record * 5¬†:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/796/1*1tR0tV2M9F1FkhO9YmgEhg.png\"></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>‚úÖ OK - test_sum_unfolded_spring_record_combinations<br><br>[Done] exited with code=0 in 0.11 seconds</pre>\n<p>Phew! And now let‚Äôs do it for part 2, puzzle¬†input:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*KwV2lKEhMMicGv2y4jS69Q.png\"><figcaption>* 5 for unfolding Í©ú</figcaption></figure><pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_12/hot_springs.py\"<br>‚ùóÔ∏è Total valid combinations: XXXXXXXXXXXXX<br><br>[Done] exited with code=0 in 0.693 seconds</pre>\n<p><strong>Yes! Look at that runtime!¬†üöÄ</strong></p>\n<p>Let‚Äôs put this answer in the text box?¬†And‚Ä¶</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/950/1*HfuXqBmUaJQdhPzx1YC98w.png\"><figcaption>üí•</figcaption></figure><p>Here‚Äôs our super optimised code till now, I am not doing object oriented for this one!¬†:P</p>\n<pre>from enum import Enum<br>from functools import cache<br><br><br>class SpringState(Enum):<br>    OPERATIONAL = \".\"<br>    DAMAGED = \"#\"<br>    UNKNOWN = \"?\"<br><br><br>@cache<br>def get_valid_spring_record_combinations(spring_state, damaged_spring_record):<br>    if not damaged_spring_record:<br>        if SpringState.DAMAGED.value in spring_state:<br>            return 0<br>        else:<br>            return 1<br><br>    if not spring_state:<br>        if not damaged_spring_record:<br>            return 1<br>        else:<br>            return 0<br><br>    total_combinations = 0<br><br>    # if \".\" or \"?\"<br>    if spring_state[0] in [SpringState.OPERATIONAL.value, SpringState.UNKNOWN.value]:<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state[1:], damaged_spring_record<br>        )<br><br>    # if \"#\" or \"?\"<br>    if spring_state[0] in [SpringState.DAMAGED.value, SpringState.UNKNOWN.value]:<br>        if is_valid_condition(spring_state, damaged_spring_record):<br>            total_combinations += get_valid_spring_record_combinations(<br>                spring_state[damaged_spring_record[0] + 1 :], damaged_spring_record[1:]<br>            )<br><br>    return total_combinations<br><br><br>def is_valid_condition(spring_state, damaged_spring_record):<br>    return (<br>        damaged_spring_record[0] &lt;= len(spring_state)<br>        and SpringState.OPERATIONAL.value<br>        not in spring_state[: damaged_spring_record[0]]<br>        and (<br>            damaged_spring_record[0] == len(spring_state)<br>            or spring_state[damaged_spring_record[0]] != SpringState.DAMAGED.value<br>        )<br>    )<br><br><br>def sum_spring_record_combinations(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        damaged_spring_record = tuple(map(int, damaged_spring_record.split(\",\")))<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state, damaged_spring_record<br>        )<br><br>    return total_combinations<br><br><br>def part_one():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    print(f\"‚ùóÔ∏è Total valid combinations: {sum}\")<br><br><br>def sum_spring_record_combinations_unfold(spring_condition_records):<br>    total_combinations = 0<br>    for spring_record in spring_condition_records.splitlines():<br>        spring_state, damaged_spring_record = spring_record.split()<br>        damaged_spring_record = tuple(map(int, damaged_spring_record.split(\",\")))<br>        spring_state = \"?\".join([spring_state] * 5)  # unfolding<br>        damaged_spring_record = damaged_spring_record * 5  # unfolding<br>        total_combinations += get_valid_spring_record_combinations(<br>            spring_state, damaged_spring_record<br>        )<br><br>    return total_combinations<br><br><br>def part_two():<br>    with open(\"day_12/input.txt\") as f:<br>        spring_condition_records = f.read()<br>    sum = sum_spring_record_combinations_unfold(spring_condition_records)<br>    print(f\"‚ùóÔ∏è Total valid combinations: {sum}\")<br><br><br>def test_sum_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations(spring_condition_records)<br>    assert sum == 21, f\"‚ùå Expected: 21, Actual: {sum}\"<br>    print(\"‚úÖ OK - test_sum_spring_record_combinations\")<br><br><br>def test_sum_unfolded_spring_record_combinations():<br>    spring_condition_records = \"\"\"???.### 1,1,3<br>.??..??...?##. 1,1,3<br>?#?#?#?#?#?#?#? 1,3,1,6<br>????.#...#... 4,1,1<br>????.######..#####. 1,6,5<br>?###???????? 3,2,1\"\"\"<br>    sum = sum_spring_record_combinations_unfold(spring_condition_records)<br>    assert sum == 525152, f\"‚ùå Expected: 525152, Actual: {sum}\"<br>    print(\"‚úÖ OK - test_sum_unfolded_spring_record_combinations\")<br><br><br>if __name__ == \"__main__\":<br>    test_sum_spring_record_combinations()<br>    part_one()<br><br>    test_sum_unfolded_spring_record_combinations()<br>    part_two()</pre>\n<p>Man! I am learning so much with <strong>#AdventOfCode2023</strong>, it‚Äôs beautiful that I am getting to revisit a lot of my engineering days concepts that I don‚Äôt get to use in my day to day work while building CRUD apps!¬†ü§ì</p>\n<p>Onto the next day¬†then?!</p>\n<p>p.s: I am deliberating <strong>not adding answers</strong> here so you can actually spend some time trying to understand how we solved the¬†problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine¬†üëá</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! üéÑ</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=77506773abfb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "advent-of-code-2023",
        "python",
        "christmas",
        "advent-of-code"
      ]
    },
    {
      "title": "[Day 11] Cosmic Expansion // Advent of Code 2023 (Python)",
      "pubDate": "2023-12-18 10:39:36",
      "link": "https://medium.com/@jatinkrmalik/day-11-cosmic-expansion-advent-of-code-2023-python-6e545dad06bb?source=rss-ec576e4b06b0------2",
      "guid": "https://medium.com/p/6e545dad06bb",
      "author": "Jatin K Malik",
      "thumbnail": "",
      "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*WU-oHlsxWjavblYa\"><figcaption>Cosmic Expansion (via DALL-E¬†3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/11\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You continue following signs for ‚ÄúHot Springs‚Äù and eventually come across an <a href=\"https://en.wikipedia.org/wiki/Observatory\">observatory</a>. The Elf within turns out to be a researcher studying cosmic expansion using the giant telescope here.</blockquote>\n<blockquote>He doesn‚Äôt know anything about the missing machine parts; he‚Äôs only visiting for this research project. However, he confirms that the hot springs are the next-closest area likely to have people; he‚Äôll even take you straight there once he‚Äôs done with today‚Äôs observation analysis.</blockquote>\n<blockquote>Maybe you can help him with the analysis to speed things¬†up?</blockquote>\n<blockquote>The researcher has collected a bunch of data and compiled the data into a single giant image (your puzzle input). The image includes empty space (.) and galaxies (#). For¬†example:</blockquote>\n<blockquote>...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....</blockquote>\n<blockquote>The researcher is trying to figure out the sum of the lengths of the shortest path between every pair of galaxies. However, there‚Äôs a catch: the universe expanded in the time it took the light from those galaxies to reach the observatory.</blockquote>\n<blockquote>Due to something involving gravitational effects, only some space expands. In fact, the result is that any rows or columns that contain no galaxiesshould all actually be twice as¬†big.</blockquote>\n<blockquote>In the above example, three columns and two rows contain no galaxies:</blockquote>\n<blockquote>v v v<br>¬†...#......<br>¬†.......#..<br> #.........<br>&gt;..........&lt;<br>¬†......#...<br>¬†.#........<br>¬†.........#<br>&gt;..........&lt;<br>¬†.......#..<br> #...#.....<br> ^ ^¬†^</blockquote>\n<blockquote>These rows and columns need to be twice as big; the result of cosmic expansion therefore looks like¬†this:</blockquote>\n<blockquote>....#........<br>.........#...<br>#............<br>.............<br>.............<br>........#....<br>.#...........<br>............#<br>.............<br>.............<br>.........#...<br>#....#.......</blockquote>\n<blockquote>Equipped with this expanded universe, the shortest path between every pair of galaxies can be found. It can help to assign every galaxy a unique¬†number:</blockquote>\n<blockquote>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>............6<br>.............<br>.............<br>.........7...<br>8....9.......</blockquote>\n<blockquote>In these 9 galaxies, there are 36 pairs. Only count each pair once; order within the pair doesn‚Äôt matter. For each pair, find any shortest path between the two galaxies using only steps that move up, down, left, or right exactly one¬†. or # at a time. (The shortest path between two galaxies is allowed to pass through another¬†galaxy.)</blockquote>\n<blockquote>For example, here is one of the shortest paths between galaxies 5 and¬†9:</blockquote>\n<blockquote>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>.##.........6<br>..##.........<br>...##........<br>....##...7...<br>8....9.......</blockquote>\n<blockquote>This path has length 9 because it takes a minimum of nine steps to get from galaxy 5 to galaxy 9 (the eight locations marked # plus the step onto galaxy 9 itself). Here are some other example shortest path¬†lengths:</blockquote>\n<blockquote>Between galaxy 1 and galaxy 7:¬†15</blockquote>\n<blockquote>Between galaxy 3 and galaxy 6:¬†17</blockquote>\n<blockquote>Between galaxy 8 and galaxy 9:¬†5</blockquote>\n<blockquote>In this example, after expanding the universe, the sum of the shortest path between all 36 pairs of galaxies is¬†374.</blockquote>\n<blockquote>Expand the universe, then find the length of the shortest path between every pair of galaxies. What is the sum of these¬†lengths?</blockquote>\n<p><em>Finally! A space exploration problem. I am a sucker for¬†those!</em></p>\n<p>So, let‚Äôs look at the problem, we have an image of space from the observatory and it looks something like¬†this:</p>\n<pre>...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....</pre>\n<p>And we need to compute the sum of the lengths of the shortest path between every pair of galaxies!</p>\n<blockquote>‚ùóÔ∏èThe catch being, that by the time light reaches to us, the space expands due to ever expanding universe, but only some part, resulting in any <strong>rows or columns</strong> that contain <strong>no galaxies</strong> should all actually be <strong>twice as¬†big.</strong>\n</blockquote>\n<p>Let‚Äôs visualise this?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lUFvdLG-8zW-7eo4Vvl74w.png\"><figcaption>This seems like a good first¬†step</figcaption></figure><p>Once we have the final image! We can just number the galaxies¬†like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*hZRn53JjHjOFcBspyvzYLA.png\"></figure><p>And then we can just find the shortest distance from each pair of galaxies!</p>\n<p>Seems pretty straight forward right? Let‚Äôs¬†code!</p>\n<p>As usual, I will begin with writing our base case as the ultimate validator!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/528/1*wpLfzZ-B7q-gkt46Zka26A.png\"></figure><p>And now let‚Äôs start expanding! It‚Äôs clear we first need to <strong><em>expand</em></strong> space by finding empty rows and columns and doubling it. So, let‚Äôs first just do¬†that.</p>\n<p>Here‚Äôs a simple function expand_space that just does¬†that:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IvD01NKWBgQB3m5LNNoSOQ.png\"></figure><blockquote>üí° Caught a bug, as if we modify the space_map while iterating through it, the empty_rows elements start to point to an incorrect index. To fix that, we can just introduce something like a mod_count which can help us keep a track of original index in modified space_map.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VoSoXFEiPUwgq5Kqi7hERw.png\"><figcaption>Fixed!</figcaption></figure><p>Now we can find all the galaxies locations in the expanded_space_map with a simple function:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/471/1*LszcXw2pLv5S_15-MqpBCQ.png\"></figure><p>üí≠ The last step is to now take 1 galaxy and find its shortest distance from all other galaxies and then repeat this process for all galaxies!</p>\n<p>Well, before even touching the code, I can already see a lot of steps to optimise this one! For example: If we have found the shortest distance from Galaxy_1 to Galaxy_2¬†, it will be same other way around, so we can save extra compute by just refering to a¬†cache.</p>\n<pre>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>............6<br>.............<br>.............<br>.........7...<br>8....9.......</pre>\n<p>So, in case of this example, where we have 9 galaxies can could have 81 combinations, since we can‚Äôt repeat a pair, the formula¬†becomes:</p>\n<blockquote>Number of combinations= <em>n</em>! / <em>r</em>!(<em>n</em>‚àí<em>r</em>)!‚Äã</blockquote>\n<p>Solving for our¬†case:</p>\n<blockquote>\n<em>9C</em>2‚Äã = 9! / 2!(9‚àí2)! ‚Äã=¬†36</blockquote>\n<p><strong>36 combinations!</strong></p>\n<p>Let‚Äôs write some code? I will be using good‚Äôol <strong>BFS (breadth first search)</strong> to find the shortest path for each pair of galaxies. <em>We may come back and optimise this to a more greedy approach for faster computation!</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fnAe9-H1FYiZRcnQHgc26Q.png\"><figcaption>Classic BFS!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*2_MOrRwleCiWT4-DMKLxNg.png\"><figcaption>Ofcourse, I forgot `list` is unhashable ü§¶‚Äç‚ôÇÔ∏è</figcaption></figure><p>We can always hash a tupple though!¬†;)</p>\n<p>Finally after a lot of iterations:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HOtCjKwT6txXLOfaCZCd9w.png\"><figcaption>36!</figcaption></figure><p>Let‚Äôs check our test case¬†now?</p>\n<p>Here‚Äôs our MVP code till¬†now:</p>\n<pre># Day 11: Cosmic Expansion<br><br>from enum import Enum<br><br><br>EMPTY_SPACE = \".\"<br>GALAXY = \"#\"<br>DISTANCE_MAP = {}<br><br>class Direction(Enum):<br>        RIGHT = (0, 1)<br>        LEFT = (0, -1)<br>        DOWN = (1, 0)<br>        UP = (-1, 0)<br><br><br>def expand_space_map(space_map):<br>    empty_rows, empty_cols = [], []<br><br>    for i, row in enumerate(space_map):<br>        if GALAXY not in row:<br>            empty_rows.append(i)<br><br>    for i, col in enumerate(space_map[0]):<br>        if GALAXY not in [row[i] for row in space_map]:<br>            empty_cols.append(i)<br><br>    mod_count = 0<br>    for i in empty_rows:<br>        space_map.insert(i + mod_count, EMPTY_SPACE * len(space_map[i]))<br>        mod_count += 1<br><br>    mod_count = 0<br>    for i in empty_cols:<br>        for j, row in enumerate(space_map):<br>            space_map[j] = row[: i + mod_count] + EMPTY_SPACE + row[i + mod_count :]<br>        mod_count += 1<br><br>    return space_map<br><br><br>def find_shortest_distance(galaxy1, galaxy2, space_map):<br>    print(f\"Finding shortest distance between {galaxy1} and {galaxy2}\")<br>    # check if the distance between the two galaxies is already calculated<br>    distance = DISTANCE_MAP.get(galaxy1, {}).get(galaxy2) or DISTANCE_MAP.get(<br>        galaxy2, {}<br>    ).get(galaxy1)<br>    if distance:<br>        return distance<br><br>    # using BFS to find the shortest path between two galaxies<br>    queue = [galaxy1]  # initialize the queue with the starting galaxy<br>    visited = set()  # set to keep track of visited galaxies<br>    distance = 0  # initialize the distance to 0<br>    while queue:<br>        for _ in range(len(queue)):<br>            current = queue.pop(0)  # get the next galaxy from the queue<br>            if current == galaxy2:  # if we reach the destination galaxy<br>                if galaxy1 not in DISTANCE_MAP:<br>                    DISTANCE_MAP[galaxy1] = {}<br>                DISTANCE_MAP[galaxy1][galaxy2] = distance  # store the distance between the galaxies<br>                return distance<br>            visited.add(current)  # mark the current galaxy as visited<br><br>            for direction in Direction:  # explore all possible directions<br>                i, j = current[0] + direction.value[0], current[1] + direction.value[1]<br>                if (<br>                    0 &lt;= i &lt; len(space_map)<br>                    and 0 &lt;= j &lt; len(space_map[0])<br>                    and (i, j) not in visited<br>                ):<br>                    queue.append((i, j))  # add the neighboring galaxy to the queue<br>        distance += 1  # increment the distance after exploring all galaxies at the current level<br><br>    raise Exception(\"No path found between the two galaxies\")<br><br><br>def find_all_galaxies(space_map):<br>    galaxies = []<br>    for i, row in enumerate(space_map):<br>        for j, col in enumerate(row):<br>            if col == GALAXY:<br>                galaxies.append((i, j))<br>    return galaxies<br><br><br>def analyze_space(space_map):<br>    expanded_space_map = expand_space_map(space_map)<br>    print(f\"Expanded space map is {len(expanded_space_map)} x {len(expanded_space_map[0])}\")<br>    galaxies_locations = find_all_galaxies(expanded_space_map)<br>    print(f\"Number of galaxies: {len(galaxies_locations)}\")<br><br>    for galaxy1 in galaxies_locations:<br>        for galaxy2 in galaxies_locations:<br>            if galaxy1 != galaxy2:<br>                find_shortest_distance(galaxy1, galaxy2, expanded_space_map)<br><br>    sum = 0 <br>    for k,v in DISTANCE_MAP.items():<br>        for k1,v1 in v.items():<br>            sum += v1<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br>    sum =  analyze_space(space_map)<br>    print(f\"‚ùóÔ∏è Sum of the lengths of the shortest path between every pair of galaxies: {sum}\")<br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br><br>    sum = analyze_space(space_map.splitlines())<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"‚úÖ Passed test_analyze_observation()\")<br><br><br>if __name__ == \"__main__\":<br>    test_analyze_space()<br>    # part_one()</pre>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>‚úÖ Passed test_analyze_observation()<br><br>[Done] exited with code=0 in 7.131 seconds</pre>\n<p>Well, it did took 7.131 seconds to compute for a simple testcase, let‚Äôs see if it can do it for puzzle¬†input?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/991/1*qsb5pCVb9HnxVVOv7uzGzQ.png\"></figure><p>And compute!!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*NTrAEUF4t-HG-9FlN3uA6Q.png\"><figcaption>2 mins in, doesn‚Äôt seem¬†likely!</figcaption></figure><p>Let‚Äôs add some logging to understand the scale of the¬†problem?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/896/1*KatgSN7P3HCewqc06-gjLw.gif\"><figcaption>Yeah‚Ä¶.this is not gonna¬†compute!</figcaption></figure><p>We have 426 Galaxies in a map of size 151 x 147 which gives us 426C2 combinations, equaling 90525 possible pairs! We need to make it more efficient!</p>\n<blockquote>While, I can take the easy path of just doings the <strong>Bi-directional BFS</strong> where I can look up from both Galaxy 1 and Galaxy 2, I feels it‚Äôs better to take a peak into <strong>A* or Dijkstra‚Äôs </strong>Algorithm for our shortest path finding to be more efficient!</blockquote>\n<p>I am bit rusty don‚Äôt remember A* algo exactly but I do remember that A* is a type of <strong>greedy approch</strong> which does a <strong>smart search</strong> through a maze, where at each step it makes an <strong>informed guess</strong> about the best next step based on <em>how far it has already traveled</em> and <em>how far it still has to go</em>, according to the map. It‚Äôs a blend of exploring and using what you know to make good guesses, which makes it efficient and effective for finding¬†paths.</p>\n<p>Let‚Äôs use Github Copilot to quickly generate a A* method for searching and then refactor it to suit our galaxy and space_map problem:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YrmYmgoRwh7xZY6OUTjUHQ.png\"><figcaption>Looks good!</figcaption></figure><p>Now, let‚Äôs run for the base test case with our logging¬†enabled?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>Expanded space map is 12 x 13<br>Number of galaxies: 9<br>Finding shortest distance between (0, 4) and (1, 9)<br>Finding shortest distance between (0, 4) and (2, 0)<br>Finding shortest distance between (0, 4) and (5, 8)<br>Finding shortest distance between (0, 4) and (6, 1)<br>Finding shortest distance between (0, 4) and (7, 12)<br>Finding shortest distance between (0, 4) and (10, 9)<br>Finding shortest distance between (0, 4) and (11, 0)<br>Finding shortest distance between (0, 4) and (11, 5)<br>Finding shortest distance between (1, 9) and (0, 4)<br>Finding shortest distance between (1, 9) and (2, 0)<br>Finding shortest distance between (1, 9) and (5, 8)<br>Finding shortest distance between (1, 9) and (6, 1)<br>Finding shortest distance between (1, 9) and (7, 12)<br>Finding shortest distance between (1, 9) and (10, 9)<br>Finding shortest distance between (1, 9) and (11, 0)<br>Finding shortest distance between (1, 9) and (11, 5)<br>Finding shortest distance between (2, 0) and (0, 4)<br>Finding shortest distance between (2, 0) and (1, 9)<br>Finding shortest distance between (2, 0) and (5, 8)<br>Finding shortest distance between (2, 0) and (6, 1)<br>Finding shortest distance between (2, 0) and (7, 12)<br>Finding shortest distance between (2, 0) and (10, 9)<br>Finding shortest distance between (2, 0) and (11, 0)<br>Finding shortest distance between (2, 0) and (11, 5)<br>Finding shortest distance between (5, 8) and (0, 4)<br>Finding shortest distance between (5, 8) and (1, 9)<br>Finding shortest distance between (5, 8) and (2, 0)<br>Finding shortest distance between (5, 8) and (6, 1)<br>Finding shortest distance between (5, 8) and (7, 12)<br>Finding shortest distance between (5, 8) and (10, 9)<br>Finding shortest distance between (5, 8) and (11, 0)<br>Finding shortest distance between (5, 8) and (11, 5)<br>Finding shortest distance between (6, 1) and (0, 4)<br>Finding shortest distance between (6, 1) and (1, 9)<br>Finding shortest distance between (6, 1) and (2, 0)<br>Finding shortest distance between (6, 1) and (5, 8)<br>Finding shortest distance between (6, 1) and (7, 12)<br>Finding shortest distance between (6, 1) and (10, 9)<br>Finding shortest distance between (6, 1) and (11, 0)<br>Finding shortest distance between (6, 1) and (11, 5)<br>Finding shortest distance between (7, 12) and (0, 4)<br>Finding shortest distance between (7, 12) and (1, 9)<br>Finding shortest distance between (7, 12) and (2, 0)<br>Finding shortest distance between (7, 12) and (5, 8)<br>Finding shortest distance between (7, 12) and (6, 1)<br>Finding shortest distance between (7, 12) and (10, 9)<br>Finding shortest distance between (7, 12) and (11, 0)<br>Finding shortest distance between (7, 12) and (11, 5)<br>Finding shortest distance between (10, 9) and (0, 4)<br>Finding shortest distance between (10, 9) and (1, 9)<br>Finding shortest distance between (10, 9) and (2, 0)<br>Finding shortest distance between (10, 9) and (5, 8)<br>Finding shortest distance between (10, 9) and (6, 1)<br>Finding shortest distance between (10, 9) and (7, 12)<br>Finding shortest distance between (10, 9) and (11, 0)<br>Finding shortest distance between (10, 9) and (11, 5)<br>Finding shortest distance between (11, 0) and (0, 4)<br>Finding shortest distance between (11, 0) and (1, 9)<br>Finding shortest distance between (11, 0) and (2, 0)<br>Finding shortest distance between (11, 0) and (5, 8)<br>Finding shortest distance between (11, 0) and (6, 1)<br>Finding shortest distance between (11, 0) and (7, 12)<br>Finding shortest distance between (11, 0) and (10, 9)<br>Finding shortest distance between (11, 0) and (11, 5)<br>Finding shortest distance between (11, 5) and (0, 4)<br>Finding shortest distance between (11, 5) and (1, 9)<br>Finding shortest distance between (11, 5) and (2, 0)<br>Finding shortest distance between (11, 5) and (5, 8)<br>Finding shortest distance between (11, 5) and (6, 1)<br>Finding shortest distance between (11, 5) and (7, 12)<br>Finding shortest distance between (11, 5) and (10, 9)<br>Finding shortest distance between (11, 5) and (11, 0)<br>‚úÖ Passed test_analyze_observation()<br><br>[Done] exited with code=0 in 0.121 seconds</pre>\n<blockquote>Woah! <strong>0.121 seconds</strong> for the base test case. Comparing this to our previous <em>BFS</em> approach that took <strong>7.131 seconds </strong>to churn out the answers, <em>A*</em> approach is almost <strong>~59x faster!¬†üöÄ</strong>\n</blockquote>\n<p>Let‚Äôs run for our puzzle input and go make a coffee!¬†‚òïÔ∏è</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br><br>‚ùóÔ∏è Sum of the lengths of the shortest path between every pair of galaxies: XXXXX<br><br>[Done] exited with code=0 in 982.651 seconds</pre>\n<p>Well, this took only <strong>982.651 seconds ~ 16.377 minutes</strong> to run! And this happened because I just ran it and went to make coffee and when I came back, I was it was somewhere around 148th row. Since, I knew we have a total 151 rows only, I just let it¬†run!</p>\n<pre>Finding shortest distance between (148, 104) and (119, 66)<br>Finding shortest distance between (148, 104) and (119, 105)<br>Finding shortest distance between (148, 104) and (119, 116)</pre>\n<p>So, let‚Äôs input our answer into the box¬†and‚Ä¶</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/830/1*Nld_W8c57EDwOGkKVJHi_g.png\"><figcaption>Yay! üôå</figcaption></figure><p>Here‚Äôs our unpythonic code till now, I will optimise it in Part¬†2:</p>\n<pre># Day 11: Cosmic Expansion<br><br>from enum import Enum<br>import heapq<br><br><br>EMPTY_SPACE = \".\"<br>GALAXY = \"#\"<br>DISTANCE_MAP = {}<br><br><br>class Direction(Enum):<br>    RIGHT = (0, 1)<br>    LEFT = (0, -1)<br>    DOWN = (1, 0)<br>    UP = (-1, 0)<br><br><br>def calculate_distance(a, b):<br>    return abs(a[0] - b[0]) + abs(a[1] - b[1])  # Manhattan distance<br><br><br>def get_adjacent_galaxies(space_map, galaxy):<br>    adjacent_galaxies = []<br>    for direction in Direction:<br>        i, j = galaxy[0] + direction.value[0], galaxy[1] + direction.value[1]<br>        if 0 &lt;= i &lt; len(space_map) and 0 &lt;= j &lt; len(space_map[0]):<br>            adjacent_galaxies.append((i, j))<br>    return adjacent_galaxies<br><br><br>def find_shortest_path(space_map, start_galaxy, end_galaxy):<br>    galaxies_to_visit = []<br>    heapq.heappush(galaxies_to_visit, (0, start_galaxy))<br>    previous_galaxy = {}<br>    cost_to_reach = {start_galaxy: 0}<br>    estimated_total_cost = {start_galaxy: calculate_distance(start_galaxy, end_galaxy)}<br><br>    while galaxies_to_visit:<br>        current_galaxy = heapq.heappop(galaxies_to_visit)[1]<br><br>        if current_galaxy == end_galaxy:<br>            return cost_to_reach[<br>                current_galaxy<br>            ]  # Return the cost to reach the end galaxy<br><br>        for adjacent_galaxy in get_adjacent_galaxies(space_map, current_galaxy):<br>            tentative_cost = cost_to_reach[current_galaxy] + 1  # assuming uniform cost<br>            if (<br>                adjacent_galaxy not in cost_to_reach<br>                or tentative_cost &lt; cost_to_reach[adjacent_galaxy]<br>            ):<br>                previous_galaxy[adjacent_galaxy] = current_galaxy<br>                cost_to_reach[adjacent_galaxy] = tentative_cost<br>                estimated_total_cost[<br>                    adjacent_galaxy<br>                ] = tentative_cost + calculate_distance(adjacent_galaxy, end_galaxy)<br>                heapq.heappush(<br>                    galaxies_to_visit,<br>                    (estimated_total_cost[adjacent_galaxy], adjacent_galaxy),<br>                )<br><br>    raise Exception(\"No path found between the two galaxies\")<br><br><br>def expand_space_map(space_map):<br>    empty_rows, empty_cols = [], []<br><br>    for i, row in enumerate(space_map):<br>        if GALAXY not in row:<br>            empty_rows.append(i)<br><br>    for i, col in enumerate(space_map[0]):<br>        if GALAXY not in [row[i] for row in space_map]:<br>            empty_cols.append(i)<br><br>    mod_count = 0<br>    for i in empty_rows:<br>        space_map.insert(i + mod_count, EMPTY_SPACE * len(space_map[i]))<br>        mod_count += 1<br><br>    mod_count = 0<br>    for i in empty_cols:<br>        for j, row in enumerate(space_map):<br>            space_map[j] = row[: i + mod_count] + EMPTY_SPACE + row[i + mod_count :]<br>        mod_count += 1<br><br>    return space_map<br><br><br>def find_shortest_distance(galaxy1, galaxy2, space_map):<br>    print(f\"Finding shortest distance between {galaxy1} and {galaxy2}\")<br><br>    distance = DISTANCE_MAP.get(galaxy1, {}).get(galaxy2) or DISTANCE_MAP.get(<br>        galaxy2, {}<br>    ).get(galaxy1)<br>    if distance:<br>        return distance<br><br>    distance = find_shortest_path(space_map, galaxy1, galaxy2)  # Use A* for pathfinding<br><br>    if galaxy1 not in DISTANCE_MAP:<br>        DISTANCE_MAP[galaxy1] = {}<br>    DISTANCE_MAP[galaxy1][galaxy2] = distance<br>    return distance<br><br><br>def find_all_galaxies(space_map):<br>    galaxies = []<br>    for i, row in enumerate(space_map):<br>        for j, col in enumerate(row):<br>            if col == GALAXY:<br>                galaxies.append((i, j))<br>    return galaxies<br><br><br>def analyze_space(space_map):<br>    expanded_space_map = expand_space_map(space_map)<br>    print(<br>        f\"Expanded space map is {len(expanded_space_map)} x {len(expanded_space_map[0])}\"<br>    )<br>    galaxies_locations = find_all_galaxies(expanded_space_map)<br>    print(f\"Number of galaxies: {len(galaxies_locations)}\")<br><br>    for galaxy1 in galaxies_locations:<br>        for galaxy2 in galaxies_locations:<br>            if galaxy1 != galaxy2:<br>                find_shortest_distance(galaxy1, galaxy2, expanded_space_map)<br><br>    sum = 0<br>    for k, v in DISTANCE_MAP.items():<br>        for k1, v1 in v.items():<br>            sum += v1<br><br>    return sum<br><br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br>    sum = analyze_space(space_map)<br>    print(<br>        f\"‚ùóÔ∏è Sum of the lengths of the shortest path between every pair of galaxies: {sum}\"<br>    )<br><br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br><br>    sum = analyze_space(space_map.splitlines())<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"‚úÖ Passed test_analyze_observation()\")<br><br><br>if __name__ == \"__main__\":<br>    # test_analyze_space()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>The galaxies are much older (and thus much farther apart) than the researcher initially estimated.</blockquote>\n<blockquote>Now, instead of the expansion you did before, make each empty row or column one million times larger. That is, each empty row should be replaced with 1000000 empty rows, and each empty column should be replaced with 1000000empty columns.</blockquote>\n<blockquote>(In the example above, if each empty row or column were merely 10 times larger, the sum of the shortest paths between every pair of galaxies would be 1030. If each empty row or column were merely 100 times larger, the sum of the shortest paths between every pair of galaxies would be 8410. However, your universe will need to expand far beyond these¬†values.)</blockquote>\n<blockquote>Starting with the same initial image, expand the universe according to these new rules, then find the length of the shortest path between every pair of galaxies. What is the sum of these¬†lengths?</blockquote>\n<p>Well, of course, the galaxies are much¬†<strong>older!</strong></p>\n<p>So, looks like we need to update how we expand our space map buy a factor of <strong>one million times, </strong>that is<strong>, 1000000x, </strong>for each empty row and¬†column!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*pwCxlg2tQmeeKVJebYZhTQ.png\"></figure><blockquote>Yep! Our current code will not scale at all. <strong>Probably</strong> our solar system sun will collapse into itself before our single threaded Python will be able to compute anything!</blockquote>\n<p>So‚Ä¶let‚Äôs rethink¬†this!</p>\n<p>.</p>\n<p>.</p>\n<blockquote>Well shit! Why do I even need any path finding algo here? Isn‚Äôt this just simple matrix manipulation? I think I ended up doing over-engineering here! This is classic trap of being Principal Engineer, making problems look more complex than they actually¬†are!</blockquote>\n<h3>Revisting Part¬†1</h3>\n<p>This problem required solving just <strong>Manhattan distance</strong> between 2 nodes. Here‚Äôs an example to get distance between (Galaxy 1, Galaxy 4) and (Galaxy 5, Galaxy¬†8):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/406/1*FeZ6DaSbYqtfO-B15zLeWg.png\"></figure><p>The formula to get this is absurdly simple as¬†well:</p>\n<blockquote>Manhattan Distance = |x1‚Ää‚Äî‚Ääy1| + |x2‚Ää‚Äî‚Ääy2|</blockquote>\n<p>Which makes my code as simple¬†as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/837/1*Ro92d-LT-I3LQGcqxirC3A.png\"></figure><p>Solving for part 1, testing with base test case and puzzle¬†input:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>Expanded space map is 12 x 13<br>Number of galaxies: 9<br>Number of possible pairs of galaxies: 36<br>‚úÖ Passed test_analyze_observation()<br>Expanded space map is 151 x 147<br>Number of galaxies: 426<br>Number of possible pairs of galaxies: 90525<br>‚ùóÔ∏è Sum of the lengths of the shortest path between every pair of galaxies: xxxxxx<br><br>[Done] exited with code=0 in 0.199 seconds</pre>\n<p>Yep, correct answer!¬†ü•≤</p>\n<h4>Back to Part¬†2</h4>\n<p>Now, all that is changing is, the <strong>expansion distance</strong> between pairs of galaxies.</p>\n<p>üí≠ If we can somehow just find the number of rows + cols to be modified compared to initial galaxy, we can just do the computation on original space_map and then just increase the distance by a factor of¬†1000000</p>\n<blockquote>üí° We can further simplify our code by not having to do the expansion at all as per part¬†1</blockquote>\n<p>We can introduce a new param‚Ää‚Äî‚Ääexpansion_factor which we can pass as 2 for the part one, and 1000000 for part two to keep our code¬†modular.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*w3rB_I5L5KXzI1CY-AY8ow.png\"></figure><p>Let‚Äôs update our base test¬†case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/817/1*FgsL03tvwa3UA2ExhCPylg.png\"></figure><p>And let‚Äôs run¬†this:</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>‚úÖ Passed test_analyze_observation() for expansion_factor=2<br>‚úÖ Passed test_analyze_observation() for expansion_factor=10<br>‚úÖ Passed test_analyze_observation() for expansion_factor=100</pre>\n<p>Phew! We can now just load up our puzzle input and call for our 10‚Å∂ expansion_factor¬†:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qbE8EN2SEYiGUYEuTEw2bA.png\"></figure><p>Let‚Äôs run this¬†up!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>‚úÖ Passed test_analyze_observation() for expansion_factor=2<br>‚úÖ Passed test_analyze_observation() for expansion_factor=10<br>‚úÖ Passed test_analyze_observation() for expansion_factor=100<br>‚ùóÔ∏è Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=2: xxxx<br>‚ÄºÔ∏è Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=1000000: xxxxxxxxxx<br><br>[Done] exited with code=0 in 0.843 seconds</pre>\n<p>We get the answer in <strong>0.843 seconds‚Ä¶.for BOTH the parts + 3 test cases</strong>!¬†üòπ</p>\n<p>This is why I absolutely love¬†coding!</p>\n<p>Let‚Äôs put this answer in the input box and‚Ä¶.profit!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/821/1*Me6mzkKI4sceFKZRH8rVWg.png\"><figcaption>üååüååüåå</figcaption></figure><p>Here‚Äôs our final pythonic yet highly performant code:</p>\n<pre># Day 11: Cosmic Expansion<br><br>class CosmicGrid:<br>    def __init__(self, space_grid):<br>        # Initialize the cosmic grid with the provided space grid<br>        self.space_grid = space_grid<br>        self.grid_height = len(space_grid)<br>        self.grid_width = len(space_grid[0])<br>        # Find rows and columns that are entirely empty<br>        self.empty_rows = self._find_empty_rows()<br>        self.empty_columns = self._find_empty_columns()<br>        # Locate all galaxies within the grid<br>        self.galaxy_positions = self._find_galaxy_positions()<br><br>    def _find_empty_rows(self):<br>        # Identify rows that contain only empty space<br>        empty_rows = set()<br>        for row in range(self.grid_height):<br>            if all(cell == '.' for cell in self.space_grid[row]):<br>                empty_rows.add(row)<br>        return empty_rows<br><br>    def _find_empty_columns(self):<br>        # Identify columns that contain only empty space<br>        empty_columns = set()<br>        for col in range(self.grid_width):<br>            if all(self.space_grid[row][col] == '.' for row in range(self.grid_height)):<br>                empty_columns.add(col)<br>        return empty_columns<br><br>    def _find_galaxy_positions(self):<br>        # Record the positions of all galaxies in the grid<br>        galaxy_positions = []<br>        for row in range(self.grid_height):<br>            for col in range(self.grid_width):<br>                if self.space_grid[row][col] == '#':<br>                    galaxy_positions.append((row, col))<br>        return galaxy_positions<br><br>    def find_shortest_distance(self, galaxy1, galaxy2, expansion_factor):<br>        # Calculate the shortest distance between two galaxies, factoring in cosmic expansion<br>        row_distance = 0<br>        for r in range(min(galaxy1[0], galaxy2[0]), max(galaxy1[0], galaxy2[0]) + 1):<br>            if r in self.empty_rows:<br>                row_distance += 1<br><br>        col_distance = 0<br>        for c in range(min(galaxy1[1], galaxy2[1]), max(galaxy1[1], galaxy2[1]) + 1):<br>            if c in self.empty_columns:<br>                col_distance += 1<br><br>        # Expanded distance is calculated by multiplying empty distances by the expansion factor<br>        # Direct distance is the straight line distance, not through empty space<br>        expanded_row_distance = row_distance * expansion_factor<br>        expanded_col_distance = col_distance * expansion_factor<br>        direct_distance = abs(galaxy1[0] - galaxy2[0]) + abs(galaxy1[1] - galaxy2[1])<br><br>        return expanded_row_distance + expanded_col_distance + direct_distance - row_distance - col_distance<br><br>    def sum_of_shortest_paths(self, expansion_factor):<br>        # Sum the shortest paths between all pairs of galaxies<br>        total_distance = 0<br>        for i, galaxy1 in enumerate(self.galaxy_positions):<br>            for galaxy2 in self.galaxy_positions[i + 1:]:<br>                total_distance += self.find_shortest_distance(galaxy1, galaxy2, expansion_factor)<br>        return total_distance<br><br><br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br><br>    cosmic_grid = CosmicGrid(space_map)<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=2)<br>    print(<br>        f\"‚ùóÔ∏è Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=2: {sum}\"<br>    )<br><br><br>def part_two():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br><br>    cosmic_grid = CosmicGrid(space_map)<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=1000000)<br>    print(<br>        f\"‚ÄºÔ∏è Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=1000000: {sum}\"<br>    )<br><br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br>    cosmic_grid = CosmicGrid(space_map.splitlines())<br>    # part one<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=2)<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"‚úÖ Passed test_analyze_observation() for expansion_factor=2\")<br><br>    # part two<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=10)<br>    assert sum == 1030, f\"Expected 1030, got {sum}\"<br>    print(\"‚úÖ Passed test_analyze_observation() for expansion_factor=10\")<br><br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=100)<br>    assert sum == 8410, f\"Expected 8410, got {sum}\"<br>    print(\"‚úÖ Passed test_analyze_observation() for expansion_factor=100\")<br><br><br>if __name__ == \"__main__\":<br>    test_analyze_space()<br>    part_one()<br>    part_two()</pre>\n<p><strong>‚òòÔ∏è Moral of the story? </strong>As a Principal Engineer, I‚Äôm wired to navigate complex problems, often defaulting to intricate solutions like BFS, DFS, Dijkstra, and¬†A*.</p>\n<p>Here, I overcomplicated a straightforward task that simply needed the Manhattan distance formula. This experience was a humbling reminder that sometimes, <strong>simplicity is key</strong>. It‚Äôs easy to overlook the obvious when your mind is tuned to complexity. It‚Äôs crucial to step back and reassess, as the simplest path often leads to the most elegant solution.</p>\n<blockquote><strong><em>This was a lesson in the beauty of simplicity in problem-solving.</em></strong></blockquote>\n<p>p.s: I am deliberating not adding answers here so you can actually spend some time trying to understand how we solved the¬†problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine¬†üëá</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! üéÑ</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6e545dad06bb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*WU-oHlsxWjavblYa\"><figcaption>Cosmic Expansion (via DALL-E¬†3)</figcaption></figure><p><a href=\"https://adventofcode.com/2023/day/11\">Advent of Code</a></p>\n<h3>Part One</h3>\n<blockquote>You continue following signs for ‚ÄúHot Springs‚Äù and eventually come across an <a href=\"https://en.wikipedia.org/wiki/Observatory\">observatory</a>. The Elf within turns out to be a researcher studying cosmic expansion using the giant telescope here.</blockquote>\n<blockquote>He doesn‚Äôt know anything about the missing machine parts; he‚Äôs only visiting for this research project. However, he confirms that the hot springs are the next-closest area likely to have people; he‚Äôll even take you straight there once he‚Äôs done with today‚Äôs observation analysis.</blockquote>\n<blockquote>Maybe you can help him with the analysis to speed things¬†up?</blockquote>\n<blockquote>The researcher has collected a bunch of data and compiled the data into a single giant image (your puzzle input). The image includes empty space (.) and galaxies (#). For¬†example:</blockquote>\n<blockquote>...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....</blockquote>\n<blockquote>The researcher is trying to figure out the sum of the lengths of the shortest path between every pair of galaxies. However, there‚Äôs a catch: the universe expanded in the time it took the light from those galaxies to reach the observatory.</blockquote>\n<blockquote>Due to something involving gravitational effects, only some space expands. In fact, the result is that any rows or columns that contain no galaxiesshould all actually be twice as¬†big.</blockquote>\n<blockquote>In the above example, three columns and two rows contain no galaxies:</blockquote>\n<blockquote>v v v<br>¬†...#......<br>¬†.......#..<br> #.........<br>&gt;..........&lt;<br>¬†......#...<br>¬†.#........<br>¬†.........#<br>&gt;..........&lt;<br>¬†.......#..<br> #...#.....<br> ^ ^¬†^</blockquote>\n<blockquote>These rows and columns need to be twice as big; the result of cosmic expansion therefore looks like¬†this:</blockquote>\n<blockquote>....#........<br>.........#...<br>#............<br>.............<br>.............<br>........#....<br>.#...........<br>............#<br>.............<br>.............<br>.........#...<br>#....#.......</blockquote>\n<blockquote>Equipped with this expanded universe, the shortest path between every pair of galaxies can be found. It can help to assign every galaxy a unique¬†number:</blockquote>\n<blockquote>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>............6<br>.............<br>.............<br>.........7...<br>8....9.......</blockquote>\n<blockquote>In these 9 galaxies, there are 36 pairs. Only count each pair once; order within the pair doesn‚Äôt matter. For each pair, find any shortest path between the two galaxies using only steps that move up, down, left, or right exactly one¬†. or # at a time. (The shortest path between two galaxies is allowed to pass through another¬†galaxy.)</blockquote>\n<blockquote>For example, here is one of the shortest paths between galaxies 5 and¬†9:</blockquote>\n<blockquote>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>.##.........6<br>..##.........<br>...##........<br>....##...7...<br>8....9.......</blockquote>\n<blockquote>This path has length 9 because it takes a minimum of nine steps to get from galaxy 5 to galaxy 9 (the eight locations marked # plus the step onto galaxy 9 itself). Here are some other example shortest path¬†lengths:</blockquote>\n<blockquote>Between galaxy 1 and galaxy 7:¬†15</blockquote>\n<blockquote>Between galaxy 3 and galaxy 6:¬†17</blockquote>\n<blockquote>Between galaxy 8 and galaxy 9:¬†5</blockquote>\n<blockquote>In this example, after expanding the universe, the sum of the shortest path between all 36 pairs of galaxies is¬†374.</blockquote>\n<blockquote>Expand the universe, then find the length of the shortest path between every pair of galaxies. What is the sum of these¬†lengths?</blockquote>\n<p><em>Finally! A space exploration problem. I am a sucker for¬†those!</em></p>\n<p>So, let‚Äôs look at the problem, we have an image of space from the observatory and it looks something like¬†this:</p>\n<pre>...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....</pre>\n<p>And we need to compute the sum of the lengths of the shortest path between every pair of galaxies!</p>\n<blockquote>‚ùóÔ∏èThe catch being, that by the time light reaches to us, the space expands due to ever expanding universe, but only some part, resulting in any <strong>rows or columns</strong> that contain <strong>no galaxies</strong> should all actually be <strong>twice as¬†big.</strong>\n</blockquote>\n<p>Let‚Äôs visualise this?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lUFvdLG-8zW-7eo4Vvl74w.png\"><figcaption>This seems like a good first¬†step</figcaption></figure><p>Once we have the final image! We can just number the galaxies¬†like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*hZRn53JjHjOFcBspyvzYLA.png\"></figure><p>And then we can just find the shortest distance from each pair of galaxies!</p>\n<p>Seems pretty straight forward right? Let‚Äôs¬†code!</p>\n<p>As usual, I will begin with writing our base case as the ultimate validator!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/528/1*wpLfzZ-B7q-gkt46Zka26A.png\"></figure><p>And now let‚Äôs start expanding! It‚Äôs clear we first need to <strong><em>expand</em></strong> space by finding empty rows and columns and doubling it. So, let‚Äôs first just do¬†that.</p>\n<p>Here‚Äôs a simple function expand_space that just does¬†that:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IvD01NKWBgQB3m5LNNoSOQ.png\"></figure><blockquote>üí° Caught a bug, as if we modify the space_map while iterating through it, the empty_rows elements start to point to an incorrect index. To fix that, we can just introduce something like a mod_count which can help us keep a track of original index in modified space_map.</blockquote>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VoSoXFEiPUwgq5Kqi7hERw.png\"><figcaption>Fixed!</figcaption></figure><p>Now we can find all the galaxies locations in the expanded_space_map with a simple function:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/471/1*LszcXw2pLv5S_15-MqpBCQ.png\"></figure><p>üí≠ The last step is to now take 1 galaxy and find its shortest distance from all other galaxies and then repeat this process for all galaxies!</p>\n<p>Well, before even touching the code, I can already see a lot of steps to optimise this one! For example: If we have found the shortest distance from Galaxy_1 to Galaxy_2¬†, it will be same other way around, so we can save extra compute by just refering to a¬†cache.</p>\n<pre>....1........<br>.........2...<br>3............<br>.............<br>.............<br>........4....<br>.5...........<br>............6<br>.............<br>.............<br>.........7...<br>8....9.......</pre>\n<p>So, in case of this example, where we have 9 galaxies can could have 81 combinations, since we can‚Äôt repeat a pair, the formula¬†becomes:</p>\n<blockquote>Number of combinations= <em>n</em>! / <em>r</em>!(<em>n</em>‚àí<em>r</em>)!‚Äã</blockquote>\n<p>Solving for our¬†case:</p>\n<blockquote>\n<em>9C</em>2‚Äã = 9! / 2!(9‚àí2)! ‚Äã=¬†36</blockquote>\n<p><strong>36 combinations!</strong></p>\n<p>Let‚Äôs write some code? I will be using good‚Äôol <strong>BFS (breadth first search)</strong> to find the shortest path for each pair of galaxies. <em>We may come back and optimise this to a more greedy approach for faster computation!</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fnAe9-H1FYiZRcnQHgc26Q.png\"><figcaption>Classic BFS!</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*2_MOrRwleCiWT4-DMKLxNg.png\"><figcaption>Ofcourse, I forgot `list` is unhashable ü§¶‚Äç‚ôÇÔ∏è</figcaption></figure><p>We can always hash a tupple though!¬†;)</p>\n<p>Finally after a lot of iterations:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HOtCjKwT6txXLOfaCZCd9w.png\"><figcaption>36!</figcaption></figure><p>Let‚Äôs check our test case¬†now?</p>\n<p>Here‚Äôs our MVP code till¬†now:</p>\n<pre># Day 11: Cosmic Expansion<br><br>from enum import Enum<br><br><br>EMPTY_SPACE = \".\"<br>GALAXY = \"#\"<br>DISTANCE_MAP = {}<br><br>class Direction(Enum):<br>        RIGHT = (0, 1)<br>        LEFT = (0, -1)<br>        DOWN = (1, 0)<br>        UP = (-1, 0)<br><br><br>def expand_space_map(space_map):<br>    empty_rows, empty_cols = [], []<br><br>    for i, row in enumerate(space_map):<br>        if GALAXY not in row:<br>            empty_rows.append(i)<br><br>    for i, col in enumerate(space_map[0]):<br>        if GALAXY not in [row[i] for row in space_map]:<br>            empty_cols.append(i)<br><br>    mod_count = 0<br>    for i in empty_rows:<br>        space_map.insert(i + mod_count, EMPTY_SPACE * len(space_map[i]))<br>        mod_count += 1<br><br>    mod_count = 0<br>    for i in empty_cols:<br>        for j, row in enumerate(space_map):<br>            space_map[j] = row[: i + mod_count] + EMPTY_SPACE + row[i + mod_count :]<br>        mod_count += 1<br><br>    return space_map<br><br><br>def find_shortest_distance(galaxy1, galaxy2, space_map):<br>    print(f\"Finding shortest distance between {galaxy1} and {galaxy2}\")<br>    # check if the distance between the two galaxies is already calculated<br>    distance = DISTANCE_MAP.get(galaxy1, {}).get(galaxy2) or DISTANCE_MAP.get(<br>        galaxy2, {}<br>    ).get(galaxy1)<br>    if distance:<br>        return distance<br><br>    # using BFS to find the shortest path between two galaxies<br>    queue = [galaxy1]  # initialize the queue with the starting galaxy<br>    visited = set()  # set to keep track of visited galaxies<br>    distance = 0  # initialize the distance to 0<br>    while queue:<br>        for _ in range(len(queue)):<br>            current = queue.pop(0)  # get the next galaxy from the queue<br>            if current == galaxy2:  # if we reach the destination galaxy<br>                if galaxy1 not in DISTANCE_MAP:<br>                    DISTANCE_MAP[galaxy1] = {}<br>                DISTANCE_MAP[galaxy1][galaxy2] = distance  # store the distance between the galaxies<br>                return distance<br>            visited.add(current)  # mark the current galaxy as visited<br><br>            for direction in Direction:  # explore all possible directions<br>                i, j = current[0] + direction.value[0], current[1] + direction.value[1]<br>                if (<br>                    0 &lt;= i &lt; len(space_map)<br>                    and 0 &lt;= j &lt; len(space_map[0])<br>                    and (i, j) not in visited<br>                ):<br>                    queue.append((i, j))  # add the neighboring galaxy to the queue<br>        distance += 1  # increment the distance after exploring all galaxies at the current level<br><br>    raise Exception(\"No path found between the two galaxies\")<br><br><br>def find_all_galaxies(space_map):<br>    galaxies = []<br>    for i, row in enumerate(space_map):<br>        for j, col in enumerate(row):<br>            if col == GALAXY:<br>                galaxies.append((i, j))<br>    return galaxies<br><br><br>def analyze_space(space_map):<br>    expanded_space_map = expand_space_map(space_map)<br>    print(f\"Expanded space map is {len(expanded_space_map)} x {len(expanded_space_map[0])}\")<br>    galaxies_locations = find_all_galaxies(expanded_space_map)<br>    print(f\"Number of galaxies: {len(galaxies_locations)}\")<br><br>    for galaxy1 in galaxies_locations:<br>        for galaxy2 in galaxies_locations:<br>            if galaxy1 != galaxy2:<br>                find_shortest_distance(galaxy1, galaxy2, expanded_space_map)<br><br>    sum = 0 <br>    for k,v in DISTANCE_MAP.items():<br>        for k1,v1 in v.items():<br>            sum += v1<br><br>    return sum<br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br>    sum =  analyze_space(space_map)<br>    print(f\"‚ùóÔ∏è Sum of the lengths of the shortest path between every pair of galaxies: {sum}\")<br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br><br>    sum = analyze_space(space_map.splitlines())<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"‚úÖ Passed test_analyze_observation()\")<br><br><br>if __name__ == \"__main__\":<br>    test_analyze_space()<br>    # part_one()</pre>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>‚úÖ Passed test_analyze_observation()<br><br>[Done] exited with code=0 in 7.131 seconds</pre>\n<p>Well, it did took 7.131 seconds to compute for a simple testcase, let‚Äôs see if it can do it for puzzle¬†input?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/991/1*qsb5pCVb9HnxVVOv7uzGzQ.png\"></figure><p>And compute!!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*NTrAEUF4t-HG-9FlN3uA6Q.png\"><figcaption>2 mins in, doesn‚Äôt seem¬†likely!</figcaption></figure><p>Let‚Äôs add some logging to understand the scale of the¬†problem?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/896/1*KatgSN7P3HCewqc06-gjLw.gif\"><figcaption>Yeah‚Ä¶.this is not gonna¬†compute!</figcaption></figure><p>We have 426 Galaxies in a map of size 151 x 147 which gives us 426C2 combinations, equaling 90525 possible pairs! We need to make it more efficient!</p>\n<blockquote>While, I can take the easy path of just doings the <strong>Bi-directional BFS</strong> where I can look up from both Galaxy 1 and Galaxy 2, I feels it‚Äôs better to take a peak into <strong>A* or Dijkstra‚Äôs </strong>Algorithm for our shortest path finding to be more efficient!</blockquote>\n<p>I am bit rusty don‚Äôt remember A* algo exactly but I do remember that A* is a type of <strong>greedy approch</strong> which does a <strong>smart search</strong> through a maze, where at each step it makes an <strong>informed guess</strong> about the best next step based on <em>how far it has already traveled</em> and <em>how far it still has to go</em>, according to the map. It‚Äôs a blend of exploring and using what you know to make good guesses, which makes it efficient and effective for finding¬†paths.</p>\n<p>Let‚Äôs use Github Copilot to quickly generate a A* method for searching and then refactor it to suit our galaxy and space_map problem:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YrmYmgoRwh7xZY6OUTjUHQ.png\"><figcaption>Looks good!</figcaption></figure><p>Now, let‚Äôs run for the base test case with our logging¬†enabled?</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>Expanded space map is 12 x 13<br>Number of galaxies: 9<br>Finding shortest distance between (0, 4) and (1, 9)<br>Finding shortest distance between (0, 4) and (2, 0)<br>Finding shortest distance between (0, 4) and (5, 8)<br>Finding shortest distance between (0, 4) and (6, 1)<br>Finding shortest distance between (0, 4) and (7, 12)<br>Finding shortest distance between (0, 4) and (10, 9)<br>Finding shortest distance between (0, 4) and (11, 0)<br>Finding shortest distance between (0, 4) and (11, 5)<br>Finding shortest distance between (1, 9) and (0, 4)<br>Finding shortest distance between (1, 9) and (2, 0)<br>Finding shortest distance between (1, 9) and (5, 8)<br>Finding shortest distance between (1, 9) and (6, 1)<br>Finding shortest distance between (1, 9) and (7, 12)<br>Finding shortest distance between (1, 9) and (10, 9)<br>Finding shortest distance between (1, 9) and (11, 0)<br>Finding shortest distance between (1, 9) and (11, 5)<br>Finding shortest distance between (2, 0) and (0, 4)<br>Finding shortest distance between (2, 0) and (1, 9)<br>Finding shortest distance between (2, 0) and (5, 8)<br>Finding shortest distance between (2, 0) and (6, 1)<br>Finding shortest distance between (2, 0) and (7, 12)<br>Finding shortest distance between (2, 0) and (10, 9)<br>Finding shortest distance between (2, 0) and (11, 0)<br>Finding shortest distance between (2, 0) and (11, 5)<br>Finding shortest distance between (5, 8) and (0, 4)<br>Finding shortest distance between (5, 8) and (1, 9)<br>Finding shortest distance between (5, 8) and (2, 0)<br>Finding shortest distance between (5, 8) and (6, 1)<br>Finding shortest distance between (5, 8) and (7, 12)<br>Finding shortest distance between (5, 8) and (10, 9)<br>Finding shortest distance between (5, 8) and (11, 0)<br>Finding shortest distance between (5, 8) and (11, 5)<br>Finding shortest distance between (6, 1) and (0, 4)<br>Finding shortest distance between (6, 1) and (1, 9)<br>Finding shortest distance between (6, 1) and (2, 0)<br>Finding shortest distance between (6, 1) and (5, 8)<br>Finding shortest distance between (6, 1) and (7, 12)<br>Finding shortest distance between (6, 1) and (10, 9)<br>Finding shortest distance between (6, 1) and (11, 0)<br>Finding shortest distance between (6, 1) and (11, 5)<br>Finding shortest distance between (7, 12) and (0, 4)<br>Finding shortest distance between (7, 12) and (1, 9)<br>Finding shortest distance between (7, 12) and (2, 0)<br>Finding shortest distance between (7, 12) and (5, 8)<br>Finding shortest distance between (7, 12) and (6, 1)<br>Finding shortest distance between (7, 12) and (10, 9)<br>Finding shortest distance between (7, 12) and (11, 0)<br>Finding shortest distance between (7, 12) and (11, 5)<br>Finding shortest distance between (10, 9) and (0, 4)<br>Finding shortest distance between (10, 9) and (1, 9)<br>Finding shortest distance between (10, 9) and (2, 0)<br>Finding shortest distance between (10, 9) and (5, 8)<br>Finding shortest distance between (10, 9) and (6, 1)<br>Finding shortest distance between (10, 9) and (7, 12)<br>Finding shortest distance between (10, 9) and (11, 0)<br>Finding shortest distance between (10, 9) and (11, 5)<br>Finding shortest distance between (11, 0) and (0, 4)<br>Finding shortest distance between (11, 0) and (1, 9)<br>Finding shortest distance between (11, 0) and (2, 0)<br>Finding shortest distance between (11, 0) and (5, 8)<br>Finding shortest distance between (11, 0) and (6, 1)<br>Finding shortest distance between (11, 0) and (7, 12)<br>Finding shortest distance between (11, 0) and (10, 9)<br>Finding shortest distance between (11, 0) and (11, 5)<br>Finding shortest distance between (11, 5) and (0, 4)<br>Finding shortest distance between (11, 5) and (1, 9)<br>Finding shortest distance between (11, 5) and (2, 0)<br>Finding shortest distance between (11, 5) and (5, 8)<br>Finding shortest distance between (11, 5) and (6, 1)<br>Finding shortest distance between (11, 5) and (7, 12)<br>Finding shortest distance between (11, 5) and (10, 9)<br>Finding shortest distance between (11, 5) and (11, 0)<br>‚úÖ Passed test_analyze_observation()<br><br>[Done] exited with code=0 in 0.121 seconds</pre>\n<blockquote>Woah! <strong>0.121 seconds</strong> for the base test case. Comparing this to our previous <em>BFS</em> approach that took <strong>7.131 seconds </strong>to churn out the answers, <em>A*</em> approach is almost <strong>~59x faster!¬†üöÄ</strong>\n</blockquote>\n<p>Let‚Äôs run for our puzzle input and go make a coffee!¬†‚òïÔ∏è</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br><br>‚ùóÔ∏è Sum of the lengths of the shortest path between every pair of galaxies: XXXXX<br><br>[Done] exited with code=0 in 982.651 seconds</pre>\n<p>Well, this took only <strong>982.651 seconds ~ 16.377 minutes</strong> to run! And this happened because I just ran it and went to make coffee and when I came back, I was it was somewhere around 148th row. Since, I knew we have a total 151 rows only, I just let it¬†run!</p>\n<pre>Finding shortest distance between (148, 104) and (119, 66)<br>Finding shortest distance between (148, 104) and (119, 105)<br>Finding shortest distance between (148, 104) and (119, 116)</pre>\n<p>So, let‚Äôs input our answer into the box¬†and‚Ä¶</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/830/1*Nld_W8c57EDwOGkKVJHi_g.png\"><figcaption>Yay! üôå</figcaption></figure><p>Here‚Äôs our unpythonic code till now, I will optimise it in Part¬†2:</p>\n<pre># Day 11: Cosmic Expansion<br><br>from enum import Enum<br>import heapq<br><br><br>EMPTY_SPACE = \".\"<br>GALAXY = \"#\"<br>DISTANCE_MAP = {}<br><br><br>class Direction(Enum):<br>    RIGHT = (0, 1)<br>    LEFT = (0, -1)<br>    DOWN = (1, 0)<br>    UP = (-1, 0)<br><br><br>def calculate_distance(a, b):<br>    return abs(a[0] - b[0]) + abs(a[1] - b[1])  # Manhattan distance<br><br><br>def get_adjacent_galaxies(space_map, galaxy):<br>    adjacent_galaxies = []<br>    for direction in Direction:<br>        i, j = galaxy[0] + direction.value[0], galaxy[1] + direction.value[1]<br>        if 0 &lt;= i &lt; len(space_map) and 0 &lt;= j &lt; len(space_map[0]):<br>            adjacent_galaxies.append((i, j))<br>    return adjacent_galaxies<br><br><br>def find_shortest_path(space_map, start_galaxy, end_galaxy):<br>    galaxies_to_visit = []<br>    heapq.heappush(galaxies_to_visit, (0, start_galaxy))<br>    previous_galaxy = {}<br>    cost_to_reach = {start_galaxy: 0}<br>    estimated_total_cost = {start_galaxy: calculate_distance(start_galaxy, end_galaxy)}<br><br>    while galaxies_to_visit:<br>        current_galaxy = heapq.heappop(galaxies_to_visit)[1]<br><br>        if current_galaxy == end_galaxy:<br>            return cost_to_reach[<br>                current_galaxy<br>            ]  # Return the cost to reach the end galaxy<br><br>        for adjacent_galaxy in get_adjacent_galaxies(space_map, current_galaxy):<br>            tentative_cost = cost_to_reach[current_galaxy] + 1  # assuming uniform cost<br>            if (<br>                adjacent_galaxy not in cost_to_reach<br>                or tentative_cost &lt; cost_to_reach[adjacent_galaxy]<br>            ):<br>                previous_galaxy[adjacent_galaxy] = current_galaxy<br>                cost_to_reach[adjacent_galaxy] = tentative_cost<br>                estimated_total_cost[<br>                    adjacent_galaxy<br>                ] = tentative_cost + calculate_distance(adjacent_galaxy, end_galaxy)<br>                heapq.heappush(<br>                    galaxies_to_visit,<br>                    (estimated_total_cost[adjacent_galaxy], adjacent_galaxy),<br>                )<br><br>    raise Exception(\"No path found between the two galaxies\")<br><br><br>def expand_space_map(space_map):<br>    empty_rows, empty_cols = [], []<br><br>    for i, row in enumerate(space_map):<br>        if GALAXY not in row:<br>            empty_rows.append(i)<br><br>    for i, col in enumerate(space_map[0]):<br>        if GALAXY not in [row[i] for row in space_map]:<br>            empty_cols.append(i)<br><br>    mod_count = 0<br>    for i in empty_rows:<br>        space_map.insert(i + mod_count, EMPTY_SPACE * len(space_map[i]))<br>        mod_count += 1<br><br>    mod_count = 0<br>    for i in empty_cols:<br>        for j, row in enumerate(space_map):<br>            space_map[j] = row[: i + mod_count] + EMPTY_SPACE + row[i + mod_count :]<br>        mod_count += 1<br><br>    return space_map<br><br><br>def find_shortest_distance(galaxy1, galaxy2, space_map):<br>    print(f\"Finding shortest distance between {galaxy1} and {galaxy2}\")<br><br>    distance = DISTANCE_MAP.get(galaxy1, {}).get(galaxy2) or DISTANCE_MAP.get(<br>        galaxy2, {}<br>    ).get(galaxy1)<br>    if distance:<br>        return distance<br><br>    distance = find_shortest_path(space_map, galaxy1, galaxy2)  # Use A* for pathfinding<br><br>    if galaxy1 not in DISTANCE_MAP:<br>        DISTANCE_MAP[galaxy1] = {}<br>    DISTANCE_MAP[galaxy1][galaxy2] = distance<br>    return distance<br><br><br>def find_all_galaxies(space_map):<br>    galaxies = []<br>    for i, row in enumerate(space_map):<br>        for j, col in enumerate(row):<br>            if col == GALAXY:<br>                galaxies.append((i, j))<br>    return galaxies<br><br><br>def analyze_space(space_map):<br>    expanded_space_map = expand_space_map(space_map)<br>    print(<br>        f\"Expanded space map is {len(expanded_space_map)} x {len(expanded_space_map[0])}\"<br>    )<br>    galaxies_locations = find_all_galaxies(expanded_space_map)<br>    print(f\"Number of galaxies: {len(galaxies_locations)}\")<br><br>    for galaxy1 in galaxies_locations:<br>        for galaxy2 in galaxies_locations:<br>            if galaxy1 != galaxy2:<br>                find_shortest_distance(galaxy1, galaxy2, expanded_space_map)<br><br>    sum = 0<br>    for k, v in DISTANCE_MAP.items():<br>        for k1, v1 in v.items():<br>            sum += v1<br><br>    return sum<br><br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br>    sum = analyze_space(space_map)<br>    print(<br>        f\"‚ùóÔ∏è Sum of the lengths of the shortest path between every pair of galaxies: {sum}\"<br>    )<br><br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br><br>    sum = analyze_space(space_map.splitlines())<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"‚úÖ Passed test_analyze_observation()\")<br><br><br>if __name__ == \"__main__\":<br>    # test_analyze_space()<br>    part_one()</pre>\n<h3>Part Two</h3>\n<blockquote>The galaxies are much older (and thus much farther apart) than the researcher initially estimated.</blockquote>\n<blockquote>Now, instead of the expansion you did before, make each empty row or column one million times larger. That is, each empty row should be replaced with 1000000 empty rows, and each empty column should be replaced with 1000000empty columns.</blockquote>\n<blockquote>(In the example above, if each empty row or column were merely 10 times larger, the sum of the shortest paths between every pair of galaxies would be 1030. If each empty row or column were merely 100 times larger, the sum of the shortest paths between every pair of galaxies would be 8410. However, your universe will need to expand far beyond these¬†values.)</blockquote>\n<blockquote>Starting with the same initial image, expand the universe according to these new rules, then find the length of the shortest path between every pair of galaxies. What is the sum of these¬†lengths?</blockquote>\n<p>Well, of course, the galaxies are much¬†<strong>older!</strong></p>\n<p>So, looks like we need to update how we expand our space map buy a factor of <strong>one million times, </strong>that is<strong>, 1000000x, </strong>for each empty row and¬†column!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*pwCxlg2tQmeeKVJebYZhTQ.png\"></figure><blockquote>Yep! Our current code will not scale at all. <strong>Probably</strong> our solar system sun will collapse into itself before our single threaded Python will be able to compute anything!</blockquote>\n<p>So‚Ä¶let‚Äôs rethink¬†this!</p>\n<p>.</p>\n<p>.</p>\n<blockquote>Well shit! Why do I even need any path finding algo here? Isn‚Äôt this just simple matrix manipulation? I think I ended up doing over-engineering here! This is classic trap of being Principal Engineer, making problems look more complex than they actually¬†are!</blockquote>\n<h3>Revisting Part¬†1</h3>\n<p>This problem required solving just <strong>Manhattan distance</strong> between 2 nodes. Here‚Äôs an example to get distance between (Galaxy 1, Galaxy 4) and (Galaxy 5, Galaxy¬†8):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/406/1*FeZ6DaSbYqtfO-B15zLeWg.png\"></figure><p>The formula to get this is absurdly simple as¬†well:</p>\n<blockquote>Manhattan Distance = |x1‚Ää‚Äî‚Ääy1| + |x2‚Ää‚Äî‚Ääy2|</blockquote>\n<p>Which makes my code as simple¬†as:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/837/1*Ro92d-LT-I3LQGcqxirC3A.png\"></figure><p>Solving for part 1, testing with base test case and puzzle¬†input:</p>\n<pre>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>Expanded space map is 12 x 13<br>Number of galaxies: 9<br>Number of possible pairs of galaxies: 36<br>‚úÖ Passed test_analyze_observation()<br>Expanded space map is 151 x 147<br>Number of galaxies: 426<br>Number of possible pairs of galaxies: 90525<br>‚ùóÔ∏è Sum of the lengths of the shortest path between every pair of galaxies: xxxxxx<br><br>[Done] exited with code=0 in 0.199 seconds</pre>\n<p>Yep, correct answer!¬†ü•≤</p>\n<h4>Back to Part¬†2</h4>\n<p>Now, all that is changing is, the <strong>expansion distance</strong> between pairs of galaxies.</p>\n<p>üí≠ If we can somehow just find the number of rows + cols to be modified compared to initial galaxy, we can just do the computation on original space_map and then just increase the distance by a factor of¬†1000000</p>\n<blockquote>üí° We can further simplify our code by not having to do the expansion at all as per part¬†1</blockquote>\n<p>We can introduce a new param‚Ää‚Äî‚Ääexpansion_factor which we can pass as 2 for the part one, and 1000000 for part two to keep our code¬†modular.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*w3rB_I5L5KXzI1CY-AY8ow.png\"></figure><p>Let‚Äôs update our base test¬†case:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/817/1*FgsL03tvwa3UA2ExhCPylg.png\"></figure><p>And let‚Äôs run¬†this:</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>‚úÖ Passed test_analyze_observation() for expansion_factor=2<br>‚úÖ Passed test_analyze_observation() for expansion_factor=10<br>‚úÖ Passed test_analyze_observation() for expansion_factor=100</pre>\n<p>Phew! We can now just load up our puzzle input and call for our 10‚Å∂ expansion_factor¬†:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qbE8EN2SEYiGUYEuTEw2bA.png\"></figure><p>Let‚Äôs run this¬†up!</p>\n<pre><br>[Running] python3 \"/Users/jmalik/github/advent-of-code-2023/day_11/cosmic_expansion.py\"<br>‚úÖ Passed test_analyze_observation() for expansion_factor=2<br>‚úÖ Passed test_analyze_observation() for expansion_factor=10<br>‚úÖ Passed test_analyze_observation() for expansion_factor=100<br>‚ùóÔ∏è Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=2: xxxx<br>‚ÄºÔ∏è Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=1000000: xxxxxxxxxx<br><br>[Done] exited with code=0 in 0.843 seconds</pre>\n<p>We get the answer in <strong>0.843 seconds‚Ä¶.for BOTH the parts + 3 test cases</strong>!¬†üòπ</p>\n<p>This is why I absolutely love¬†coding!</p>\n<p>Let‚Äôs put this answer in the input box and‚Ä¶.profit!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/821/1*Me6mzkKI4sceFKZRH8rVWg.png\"><figcaption>üååüååüåå</figcaption></figure><p>Here‚Äôs our final pythonic yet highly performant code:</p>\n<pre># Day 11: Cosmic Expansion<br><br>class CosmicGrid:<br>    def __init__(self, space_grid):<br>        # Initialize the cosmic grid with the provided space grid<br>        self.space_grid = space_grid<br>        self.grid_height = len(space_grid)<br>        self.grid_width = len(space_grid[0])<br>        # Find rows and columns that are entirely empty<br>        self.empty_rows = self._find_empty_rows()<br>        self.empty_columns = self._find_empty_columns()<br>        # Locate all galaxies within the grid<br>        self.galaxy_positions = self._find_galaxy_positions()<br><br>    def _find_empty_rows(self):<br>        # Identify rows that contain only empty space<br>        empty_rows = set()<br>        for row in range(self.grid_height):<br>            if all(cell == '.' for cell in self.space_grid[row]):<br>                empty_rows.add(row)<br>        return empty_rows<br><br>    def _find_empty_columns(self):<br>        # Identify columns that contain only empty space<br>        empty_columns = set()<br>        for col in range(self.grid_width):<br>            if all(self.space_grid[row][col] == '.' for row in range(self.grid_height)):<br>                empty_columns.add(col)<br>        return empty_columns<br><br>    def _find_galaxy_positions(self):<br>        # Record the positions of all galaxies in the grid<br>        galaxy_positions = []<br>        for row in range(self.grid_height):<br>            for col in range(self.grid_width):<br>                if self.space_grid[row][col] == '#':<br>                    galaxy_positions.append((row, col))<br>        return galaxy_positions<br><br>    def find_shortest_distance(self, galaxy1, galaxy2, expansion_factor):<br>        # Calculate the shortest distance between two galaxies, factoring in cosmic expansion<br>        row_distance = 0<br>        for r in range(min(galaxy1[0], galaxy2[0]), max(galaxy1[0], galaxy2[0]) + 1):<br>            if r in self.empty_rows:<br>                row_distance += 1<br><br>        col_distance = 0<br>        for c in range(min(galaxy1[1], galaxy2[1]), max(galaxy1[1], galaxy2[1]) + 1):<br>            if c in self.empty_columns:<br>                col_distance += 1<br><br>        # Expanded distance is calculated by multiplying empty distances by the expansion factor<br>        # Direct distance is the straight line distance, not through empty space<br>        expanded_row_distance = row_distance * expansion_factor<br>        expanded_col_distance = col_distance * expansion_factor<br>        direct_distance = abs(galaxy1[0] - galaxy2[0]) + abs(galaxy1[1] - galaxy2[1])<br><br>        return expanded_row_distance + expanded_col_distance + direct_distance - row_distance - col_distance<br><br>    def sum_of_shortest_paths(self, expansion_factor):<br>        # Sum the shortest paths between all pairs of galaxies<br>        total_distance = 0<br>        for i, galaxy1 in enumerate(self.galaxy_positions):<br>            for galaxy2 in self.galaxy_positions[i + 1:]:<br>                total_distance += self.find_shortest_distance(galaxy1, galaxy2, expansion_factor)<br>        return total_distance<br><br><br><br>def part_one():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br><br>    cosmic_grid = CosmicGrid(space_map)<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=2)<br>    print(<br>        f\"‚ùóÔ∏è Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=2: {sum}\"<br>    )<br><br><br>def part_two():<br>    with open(\"day_11/input.txt\") as f:<br>        space_map = f.read().splitlines()<br><br>    cosmic_grid = CosmicGrid(space_map)<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=1000000)<br>    print(<br>        f\"‚ÄºÔ∏è Sum of the lengths of the shortest path between every pair of galaxies for expansion_factor=1000000: {sum}\"<br>    )<br><br><br>def test_analyze_space():<br>    space_map = \"\"\"...#......<br>.......#..<br>#.........<br>..........<br>......#...<br>.#........<br>.........#<br>..........<br>.......#..<br>#...#.....\"\"\"<br>    cosmic_grid = CosmicGrid(space_map.splitlines())<br>    # part one<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=2)<br>    assert sum == 374, f\"Expected 374, got {sum}\"<br>    print(\"‚úÖ Passed test_analyze_observation() for expansion_factor=2\")<br><br>    # part two<br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=10)<br>    assert sum == 1030, f\"Expected 1030, got {sum}\"<br>    print(\"‚úÖ Passed test_analyze_observation() for expansion_factor=10\")<br><br>    sum = cosmic_grid.sum_of_shortest_paths(expansion_factor=100)<br>    assert sum == 8410, f\"Expected 8410, got {sum}\"<br>    print(\"‚úÖ Passed test_analyze_observation() for expansion_factor=100\")<br><br><br>if __name__ == \"__main__\":<br>    test_analyze_space()<br>    part_one()<br>    part_two()</pre>\n<p><strong>‚òòÔ∏è Moral of the story? </strong>As a Principal Engineer, I‚Äôm wired to navigate complex problems, often defaulting to intricate solutions like BFS, DFS, Dijkstra, and¬†A*.</p>\n<p>Here, I overcomplicated a straightforward task that simply needed the Manhattan distance formula. This experience was a humbling reminder that sometimes, <strong>simplicity is key</strong>. It‚Äôs easy to overlook the obvious when your mind is tuned to complexity. It‚Äôs crucial to step back and reassess, as the simplest path often leads to the most elegant solution.</p>\n<blockquote><strong><em>This was a lesson in the beauty of simplicity in problem-solving.</em></strong></blockquote>\n<p>p.s: I am deliberating not adding answers here so you can actually spend some time trying to understand how we solved the¬†problem!</p>\n<p>Feel free to checkout code on my Github repo and try to set it up and run on your machine¬†üëá</p>\n<p><a href=\"https://github.com/jatinkrmalik/advent-of-code-2023\">GitHub - jatinkrmalik/advent-of-code-2023: Well, here's my attempt to solve all 25 problems of Advent of Code 2023 with Python! üéÑ</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6e545dad06bb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "christmas",
        "python",
        "advent-of-code-2023",
        "advent-of-code"
      ]
    }
  ]
}